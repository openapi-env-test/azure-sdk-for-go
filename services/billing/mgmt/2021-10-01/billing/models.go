package billing

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/billing/mgmt/2021-10-01/billing"

// Amount the amount.
type Amount struct {
	// Currency - READ-ONLY; The currency for the amount value.
	Currency *string `json:"currency,omitempty"`
	// Value - READ-ONLY; Amount value.
	Value *float64 `json:"value,omitempty"`
}

// MarshalJSON is the custom marshaler for Amount.
func (a Amount) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DetachPaymentMethodEligibilityError the details of the error.
type DetachPaymentMethodEligibilityError struct {
	// Code - READ-ONLY; Error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Error message.
	Message *string `json:"message,omitempty"`
	// Details - READ-ONLY; The list of detach payment method eligibility errors.
	Details *[]DetachPaymentMethodErrorDetails `json:"details,omitempty"`
}

// MarshalJSON is the custom marshaler for DetachPaymentMethodEligibilityError.
func (dpmee DetachPaymentMethodEligibilityError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DetachPaymentMethodEligibilityResult error response indicates that payment method cannot be detached
// from billing profile.
type DetachPaymentMethodEligibilityResult struct {
	// Error - The details of the error.
	Error *DetachPaymentMethodEligibilityError `json:"error,omitempty"`
}

// DetachPaymentMethodErrorDetails error details of the detach payment method eligibility validation.
type DetachPaymentMethodErrorDetails struct {
	// Code - Error code for the detach payment method eligibility validation. Possible values include: 'AzureSubscriptions', 'RecurringCharges', 'ReservedInstances', 'OutstandingCharges', 'PendingCharges'
	Code DetachPaymentMethodEligibilityErrorCode `json:"code,omitempty"`
	// Message - Error message for the detach payment method eligibility validation.
	Message *string `json:"message,omitempty"`
}

// EnrollmentAccountSubscriptionDetails the billing properties that can be modified. This field is
// available only for the Enterprise Agreement billing accounts.
type EnrollmentAccountSubscriptionDetails struct {
	// SubscriptionEnrollmentAccountStatus - READ-ONLY; The current enrollment account status of the subscription. This field is available only for the Enterprise Agreement billing accounts. Possible values include: 'SubscriptionEnrollmentAccountStatusActive', 'SubscriptionEnrollmentAccountStatusCancelled', 'SubscriptionEnrollmentAccountStatusExpired', 'SubscriptionEnrollmentAccountStatusDeleted', 'SubscriptionEnrollmentAccountStatusTransferredOut', 'SubscriptionEnrollmentAccountStatusTransferring'
	SubscriptionEnrollmentAccountStatus SubscriptionEnrollmentAccountStatus `json:"subscriptionEnrollmentAccountStatus,omitempty"`
	// EnrollmentAccountStartDate - READ-ONLY; The enrollment Account and the subscription association start date. This field is available only for the Enterprise Agreement billing accounts.
	EnrollmentAccountStartDate *date.Time `json:"enrollmentAccountStartDate,omitempty"`
}

// MarshalJSON is the custom marshaler for EnrollmentAccountSubscriptionDetails.
func (easd EnrollmentAccountSubscriptionDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorDetails the details of the error.
type ErrorDetails struct {
	// Code - READ-ONLY; Error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Error message indicating why the operation failed.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; The target of the particular error.
	Target *string `json:"target,omitempty"`
	// Details - The sub details of the error.
	Details *[]ErrorSubDetailsItem `json:"details,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorDetails.
func (ed ErrorDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ed.Details != nil {
		objectMap["details"] = ed.Details
	}
	return json.Marshal(objectMap)
}

// ErrorResponse error response indicates that the service is not able to process the incoming request. The
// reason is provided in the error message.
type ErrorResponse struct {
	// Error - The details of the error.
	Error *ErrorDetails `json:"error,omitempty"`
}

// ErrorSubDetailsItem ...
type ErrorSubDetailsItem struct {
	// Code - READ-ONLY; Error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Error message indicating why the operation failed.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; The target of the particular error.
	Target *string `json:"target,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorSubDetailsItem.
func (esdi ErrorSubDetailsItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// MoveBillingSubscriptionRequest request parameters to transfer billing subscription.
type MoveBillingSubscriptionRequest struct {
	// DestinationEnrollmentAccountID - The destination enrollment account id.
	DestinationEnrollmentAccountID *string `json:"destinationEnrollmentAccountId,omitempty"`
	// DestinationInvoiceSectionID - The destination invoice section id.
	DestinationInvoiceSectionID *string `json:"destinationInvoiceSectionId,omitempty"`
}

// NextBillingCycleDetails the next billing cycle details of the subscription.
type NextBillingCycleDetails struct {
	// BillingFrequency - READ-ONLY; The billing frequency of the subscription in the next billing cycle.
	BillingFrequency *string `json:"billingFrequency,omitempty"`
}

// MarshalJSON is the custom marshaler for NextBillingCycleDetails.
func (nbcd NextBillingCycleDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Operation a Billing REST API operation.
type Operation struct {
	// Name - READ-ONLY; Operation name: {provider}/{resource}/{operation}.
	Name *string `json:"name,omitempty"`
	// IsDataAction - READ-ONLY; Identifies if the operation is a data operation.
	IsDataAction *bool `json:"isDataAction,omitempty"`
	// Display - The object that represents the operation.
	Display *OperationDisplay `json:"display,omitempty"`
}

// MarshalJSON is the custom marshaler for Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if o.Display != nil {
		objectMap["display"] = o.Display
	}
	return json.Marshal(objectMap)
}

// OperationDisplay the object that represents the operation.
type OperationDisplay struct {
	// Provider - READ-ONLY; Service provider: Microsoft.Billing.
	Provider *string `json:"provider,omitempty"`
	// Resource - READ-ONLY; Resource on which the operation is performed such as invoice and billing subscription.
	Resource *string `json:"resource,omitempty"`
	// Operation - READ-ONLY; Operation type such as read, write and delete.
	Operation *string `json:"operation,omitempty"`
	// Description - READ-ONLY; Description of operation.
	Description *string `json:"description,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// OperationListResult the list of billing operations and a URL link to get the next set of results.
type OperationListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of billing operations supported by the Microsoft.Billing resource provider.
	Value *[]Operation `json:"value,omitempty"`
	// NextLink - READ-ONLY; URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationListResult.
func (olr OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// OperationListResultIterator provides access to a complete listing of Operation values.
type OperationListResultIterator struct {
	i    int
	page OperationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationListResultIterator) Response() OperationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationListResultIterator) Value() Operation {
	if !iter.page.NotDone() {
		return Operation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationListResultIterator type.
func NewOperationListResultIterator(page OperationListResultPage) OperationListResultIterator {
	return OperationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (olr OperationListResult) IsEmpty() bool {
	return olr.Value == nil || len(*olr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (olr OperationListResult) hasNextLink() bool {
	return olr.NextLink != nil && len(*olr.NextLink) != 0
}

// operationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (olr OperationListResult) operationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !olr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(olr.NextLink)))
}

// OperationListResultPage contains a page of Operation values.
type OperationListResultPage struct {
	fn  func(context.Context, OperationListResult) (OperationListResult, error)
	olr OperationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.olr)
		if err != nil {
			return err
		}
		page.olr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationListResultPage) NotDone() bool {
	return !page.olr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationListResultPage) Response() OperationListResult {
	return page.olr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationListResultPage) Values() []Operation {
	if page.olr.IsEmpty() {
		return nil
	}
	return *page.olr.Value
}

// Creates a new instance of the OperationListResultPage type.
func NewOperationListResultPage(cur OperationListResult, getNextPage func(context.Context, OperationListResult) (OperationListResult, error)) OperationListResultPage {
	return OperationListResultPage{
		fn:  getNextPage,
		olr: cur,
	}
}

// PaymentMethod a payment method.
type PaymentMethod struct {
	autorest.Response        `json:"-"`
	*PaymentMethodProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PaymentMethod.
func (pm PaymentMethod) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pm.PaymentMethodProperties != nil {
		objectMap["properties"] = pm.PaymentMethodProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PaymentMethod struct.
func (pm *PaymentMethod) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var paymentMethodProperties PaymentMethodProperties
				err = json.Unmarshal(*v, &paymentMethodProperties)
				if err != nil {
					return err
				}
				pm.PaymentMethodProperties = &paymentMethodProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pm.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pm.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pm.Type = &typeVar
			}
		}
	}

	return nil
}

// PaymentMethodLink a payment method link.
type PaymentMethodLink struct {
	autorest.Response            `json:"-"`
	*PaymentMethodLinkProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for PaymentMethodLink.
func (pml PaymentMethodLink) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pml.PaymentMethodLinkProperties != nil {
		objectMap["properties"] = pml.PaymentMethodLinkProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PaymentMethodLink struct.
func (pml *PaymentMethodLink) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var paymentMethodLinkProperties PaymentMethodLinkProperties
				err = json.Unmarshal(*v, &paymentMethodLinkProperties)
				if err != nil {
					return err
				}
				pml.PaymentMethodLinkProperties = &paymentMethodLinkProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pml.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pml.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pml.Type = &typeVar
			}
		}
	}

	return nil
}

// PaymentMethodLinkProperties the properties of a payment method link.
type PaymentMethodLinkProperties struct {
	// PaymentMethod - Projection of a payment method
	PaymentMethod *PaymentMethodProjectionProperties `json:"paymentMethod,omitempty"`
}

// PaymentMethodLinksListResult the list of payment method links.
type PaymentMethodLinksListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of payment method links.
	Value *[]PaymentMethodLink `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for PaymentMethodLinksListResult.
func (pmllr PaymentMethodLinksListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// PaymentMethodLinksListResultIterator provides access to a complete listing of PaymentMethodLink values.
type PaymentMethodLinksListResultIterator struct {
	i    int
	page PaymentMethodLinksListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PaymentMethodLinksListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaymentMethodLinksListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PaymentMethodLinksListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PaymentMethodLinksListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PaymentMethodLinksListResultIterator) Response() PaymentMethodLinksListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PaymentMethodLinksListResultIterator) Value() PaymentMethodLink {
	if !iter.page.NotDone() {
		return PaymentMethodLink{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PaymentMethodLinksListResultIterator type.
func NewPaymentMethodLinksListResultIterator(page PaymentMethodLinksListResultPage) PaymentMethodLinksListResultIterator {
	return PaymentMethodLinksListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pmllr PaymentMethodLinksListResult) IsEmpty() bool {
	return pmllr.Value == nil || len(*pmllr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pmllr PaymentMethodLinksListResult) hasNextLink() bool {
	return pmllr.NextLink != nil && len(*pmllr.NextLink) != 0
}

// paymentMethodLinksListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pmllr PaymentMethodLinksListResult) paymentMethodLinksListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !pmllr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pmllr.NextLink)))
}

// PaymentMethodLinksListResultPage contains a page of PaymentMethodLink values.
type PaymentMethodLinksListResultPage struct {
	fn    func(context.Context, PaymentMethodLinksListResult) (PaymentMethodLinksListResult, error)
	pmllr PaymentMethodLinksListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PaymentMethodLinksListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaymentMethodLinksListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pmllr)
		if err != nil {
			return err
		}
		page.pmllr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PaymentMethodLinksListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PaymentMethodLinksListResultPage) NotDone() bool {
	return !page.pmllr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PaymentMethodLinksListResultPage) Response() PaymentMethodLinksListResult {
	return page.pmllr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PaymentMethodLinksListResultPage) Values() []PaymentMethodLink {
	if page.pmllr.IsEmpty() {
		return nil
	}
	return *page.pmllr.Value
}

// Creates a new instance of the PaymentMethodLinksListResultPage type.
func NewPaymentMethodLinksListResultPage(cur PaymentMethodLinksListResult, getNextPage func(context.Context, PaymentMethodLinksListResult) (PaymentMethodLinksListResult, error)) PaymentMethodLinksListResultPage {
	return PaymentMethodLinksListResultPage{
		fn:    getNextPage,
		pmllr: cur,
	}
}

// PaymentMethodLogo logo of payment method.
type PaymentMethodLogo struct {
	// MimeType - READ-ONLY; MIME type of the logo.
	MimeType *string `json:"mimeType,omitempty"`
	// URL - READ-ONLY; Public URL of image of the logo.
	URL *string `json:"url,omitempty"`
}

// MarshalJSON is the custom marshaler for PaymentMethodLogo.
func (pml PaymentMethodLogo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// PaymentMethodProjectionProperties the properties of a payment method projection.
type PaymentMethodProjectionProperties struct {
	// ID - READ-ONLY; Id of payment method.
	ID *string `json:"id,omitempty"`
	// Family - The family of payment method. Possible values include: 'CreditCard', 'CheckWire'
	Family PaymentMethodFamily `json:"family,omitempty"`
	// Type - READ-ONLY; The type of payment method.
	Type *string `json:"type,omitempty"`
	// AccountHolderName - READ-ONLY; The account holder name for the payment method. This is only supported for payment methods with family CreditCard.
	AccountHolderName *string `json:"accountHolderName,omitempty"`
	// Expiration - READ-ONLY; The expiration month and year of the payment method. This is only supported for payment methods with family CreditCard.
	Expiration *string `json:"expiration,omitempty"`
	// LastFourDigits - READ-ONLY; Last four digits of payment method.
	LastFourDigits *string `json:"lastFourDigits,omitempty"`
	// DisplayName - READ-ONLY; The display name of the payment method.
	DisplayName *string `json:"displayName,omitempty"`
	// Logos - The list of logos for the payment method.
	Logos *[]PaymentMethodLogo `json:"logos,omitempty"`
	// Status - Status of the payment method. Possible values include: 'Active', 'Inactive'
	Status PaymentMethodStatus `json:"status,omitempty"`
}

// MarshalJSON is the custom marshaler for PaymentMethodProjectionProperties.
func (pmpp PaymentMethodProjectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pmpp.Family != "" {
		objectMap["family"] = pmpp.Family
	}
	if pmpp.Logos != nil {
		objectMap["logos"] = pmpp.Logos
	}
	if pmpp.Status != "" {
		objectMap["status"] = pmpp.Status
	}
	return json.Marshal(objectMap)
}

// PaymentMethodProperties the properties of a payment method.
type PaymentMethodProperties struct {
	// Family - The family of payment method. Possible values include: 'CreditCard', 'CheckWire'
	Family PaymentMethodFamily `json:"family,omitempty"`
	// Type - READ-ONLY; The type of payment method.
	Type *string `json:"type,omitempty"`
	// AccountHolderName - READ-ONLY; The account holder name for the payment method. This is only supported for payment methods with family CreditCard.
	AccountHolderName *string `json:"accountHolderName,omitempty"`
	// Expiration - READ-ONLY; The expiration month and year of the payment method. This is only supported for payment methods with family CreditCard.
	Expiration *string `json:"expiration,omitempty"`
	// LastFourDigits - READ-ONLY; Last four digits of payment method.
	LastFourDigits *string `json:"lastFourDigits,omitempty"`
	// DisplayName - READ-ONLY; The display name of the payment method.
	DisplayName *string `json:"displayName,omitempty"`
	// Logos - The list of logos for the payment method.
	Logos *[]PaymentMethodLogo `json:"logos,omitempty"`
	// Status - Status of the payment method. Possible values include: 'Active', 'Inactive'
	Status PaymentMethodStatus `json:"status,omitempty"`
}

// MarshalJSON is the custom marshaler for PaymentMethodProperties.
func (pmp PaymentMethodProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pmp.Family != "" {
		objectMap["family"] = pmp.Family
	}
	if pmp.Logos != nil {
		objectMap["logos"] = pmp.Logos
	}
	if pmp.Status != "" {
		objectMap["status"] = pmp.Status
	}
	return json.Marshal(objectMap)
}

// PaymentMethodResource the payment method resource model definition.
type PaymentMethodResource struct {
	// PaymentMethodID - The ID that uniquely identifies a payment method.
	PaymentMethodID *string `json:"paymentMethodId,omitempty"`
}

// PaymentMethodsDeleteAtBillingProfileFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type PaymentMethodsDeleteAtBillingProfileFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PaymentMethodsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PaymentMethodsDeleteAtBillingProfileFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PaymentMethodsDeleteAtBillingProfileFuture.Result.
func (future *PaymentMethodsDeleteAtBillingProfileFuture) result(client PaymentMethodsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.PaymentMethodsDeleteAtBillingProfileFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("billing.PaymentMethodsDeleteAtBillingProfileFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// PaymentMethodsListResult the list of payment methods.
type PaymentMethodsListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of payment methods.
	Value *[]PaymentMethod `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for PaymentMethodsListResult.
func (pmlr PaymentMethodsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// PaymentMethodsListResultIterator provides access to a complete listing of PaymentMethod values.
type PaymentMethodsListResultIterator struct {
	i    int
	page PaymentMethodsListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PaymentMethodsListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaymentMethodsListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PaymentMethodsListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PaymentMethodsListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PaymentMethodsListResultIterator) Response() PaymentMethodsListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PaymentMethodsListResultIterator) Value() PaymentMethod {
	if !iter.page.NotDone() {
		return PaymentMethod{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PaymentMethodsListResultIterator type.
func NewPaymentMethodsListResultIterator(page PaymentMethodsListResultPage) PaymentMethodsListResultIterator {
	return PaymentMethodsListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pmlr PaymentMethodsListResult) IsEmpty() bool {
	return pmlr.Value == nil || len(*pmlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pmlr PaymentMethodsListResult) hasNextLink() bool {
	return pmlr.NextLink != nil && len(*pmlr.NextLink) != 0
}

// paymentMethodsListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pmlr PaymentMethodsListResult) paymentMethodsListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !pmlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pmlr.NextLink)))
}

// PaymentMethodsListResultPage contains a page of PaymentMethod values.
type PaymentMethodsListResultPage struct {
	fn   func(context.Context, PaymentMethodsListResult) (PaymentMethodsListResult, error)
	pmlr PaymentMethodsListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PaymentMethodsListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PaymentMethodsListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pmlr)
		if err != nil {
			return err
		}
		page.pmlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PaymentMethodsListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PaymentMethodsListResultPage) NotDone() bool {
	return !page.pmlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PaymentMethodsListResultPage) Response() PaymentMethodsListResult {
	return page.pmlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PaymentMethodsListResultPage) Values() []PaymentMethod {
	if page.pmlr.IsEmpty() {
		return nil
	}
	return *page.pmlr.Value
}

// Creates a new instance of the PaymentMethodsListResultPage type.
func NewPaymentMethodsListResultPage(cur PaymentMethodsListResult, getNextPage func(context.Context, PaymentMethodsListResult) (PaymentMethodsListResult, error)) PaymentMethodsListResultPage {
	return PaymentMethodsListResultPage{
		fn:   getNextPage,
		pmlr: cur,
	}
}

// RenewalTermDetails the term details of the subscription at renewal.
type RenewalTermDetails struct {
	// BillingFrequency - READ-ONLY; The billing frequency of the subscription.
	BillingFrequency *string `json:"billingFrequency,omitempty"`
	// ProductTypeID - READ-ONLY; The ID of the product.
	ProductTypeID *string `json:"productTypeId,omitempty"`
	// Quantity - The number of licenses
	Quantity *int64 `json:"quantity,omitempty"`
	// SkuID - READ-ONLY; The SKU ID of the product
	SkuID *string `json:"skuId,omitempty"`
	// TermDuration - READ-ONLY; The term duration of the subscription. Example P1M and P1Y
	TermDuration *string `json:"termDuration,omitempty"`
}

// MarshalJSON is the custom marshaler for RenewalTermDetails.
func (rtd RenewalTermDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rtd.Quantity != nil {
		objectMap["quantity"] = rtd.Quantity
	}
	return json.Marshal(objectMap)
}

// Reseller details of the reseller.
type Reseller struct {
	// ResellerID - READ-ONLY; The MPN ID of the reseller.
	ResellerID *string `json:"resellerId,omitempty"`
	// Description - READ-ONLY; The name of the reseller.
	Description *string `json:"description,omitempty"`
}

// MarshalJSON is the custom marshaler for Reseller.
func (r Reseller) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Resource the resource model definition.
type Resource struct {
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Subscription a billing subscription.
type Subscription struct {
	autorest.Response       `json:"-"`
	*SubscriptionProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Subscription.
func (s Subscription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if s.SubscriptionProperties != nil {
		objectMap["properties"] = s.SubscriptionProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Subscription struct.
func (s *Subscription) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var subscriptionProperties SubscriptionProperties
				err = json.Unmarshal(*v, &subscriptionProperties)
				if err != nil {
					return err
				}
				s.SubscriptionProperties = &subscriptionProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				s.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				s.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				s.Type = &typeVar
			}
		}
	}

	return nil
}

// SubscriptionAlias a billing subscription alias.
type SubscriptionAlias struct {
	autorest.Response            `json:"-"`
	*SubscriptionAliasProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Resource Id.
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for SubscriptionAlias.
func (sa SubscriptionAlias) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sa.SubscriptionAliasProperties != nil {
		objectMap["properties"] = sa.SubscriptionAliasProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SubscriptionAlias struct.
func (sa *SubscriptionAlias) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var subscriptionAliasProperties SubscriptionAliasProperties
				err = json.Unmarshal(*v, &subscriptionAliasProperties)
				if err != nil {
					return err
				}
				sa.SubscriptionAliasProperties = &subscriptionAliasProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sa.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sa.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sa.Type = &typeVar
			}
		}
	}

	return nil
}

// SubscriptionAliasListResult the list of billing subscription aliases.
type SubscriptionAliasListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of billing subscription aliases.
	Value *[]SubscriptionAlias `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for SubscriptionAliasListResult.
func (salr SubscriptionAliasListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SubscriptionAliasListResultIterator provides access to a complete listing of SubscriptionAlias values.
type SubscriptionAliasListResultIterator struct {
	i    int
	page SubscriptionAliasListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SubscriptionAliasListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SubscriptionAliasListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SubscriptionAliasListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SubscriptionAliasListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SubscriptionAliasListResultIterator) Response() SubscriptionAliasListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SubscriptionAliasListResultIterator) Value() SubscriptionAlias {
	if !iter.page.NotDone() {
		return SubscriptionAlias{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SubscriptionAliasListResultIterator type.
func NewSubscriptionAliasListResultIterator(page SubscriptionAliasListResultPage) SubscriptionAliasListResultIterator {
	return SubscriptionAliasListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (salr SubscriptionAliasListResult) IsEmpty() bool {
	return salr.Value == nil || len(*salr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (salr SubscriptionAliasListResult) hasNextLink() bool {
	return salr.NextLink != nil && len(*salr.NextLink) != 0
}

// subscriptionAliasListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (salr SubscriptionAliasListResult) subscriptionAliasListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !salr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(salr.NextLink)))
}

// SubscriptionAliasListResultPage contains a page of SubscriptionAlias values.
type SubscriptionAliasListResultPage struct {
	fn   func(context.Context, SubscriptionAliasListResult) (SubscriptionAliasListResult, error)
	salr SubscriptionAliasListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SubscriptionAliasListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SubscriptionAliasListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.salr)
		if err != nil {
			return err
		}
		page.salr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SubscriptionAliasListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SubscriptionAliasListResultPage) NotDone() bool {
	return !page.salr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SubscriptionAliasListResultPage) Response() SubscriptionAliasListResult {
	return page.salr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SubscriptionAliasListResultPage) Values() []SubscriptionAlias {
	if page.salr.IsEmpty() {
		return nil
	}
	return *page.salr.Value
}

// Creates a new instance of the SubscriptionAliasListResultPage type.
func NewSubscriptionAliasListResultPage(cur SubscriptionAliasListResult, getNextPage func(context.Context, SubscriptionAliasListResult) (SubscriptionAliasListResult, error)) SubscriptionAliasListResultPage {
	return SubscriptionAliasListResultPage{
		fn:   getNextPage,
		salr: cur,
	}
}

// SubscriptionAliasProperties billing subscription alias properties.
type SubscriptionAliasProperties struct {
	// BillingSubscriptionID - READ-ONLY; The ID of the billing subscription with the subscription alias.
	BillingSubscriptionID *string `json:"billingSubscriptionId,omitempty"`
	// AutoRenew - Indicates whether auto renewal is turned on or off for a subscription. Possible values include: 'Off', 'On'
	AutoRenew AutoRenew `json:"autoRenew,omitempty"`
	// BeneficiaryTenantID - The provisioning tenant of the subscription.
	BeneficiaryTenantID *string `json:"beneficiaryTenantId,omitempty"`
	// BillingFrequency - The billing frequency of the subscription in the ISO8601 format. Example: P1M, P3M, P1Y
	BillingFrequency *string `json:"billingFrequency,omitempty"`
	// BillingProfileID - The ID of the billing profile to which the subscription is billed. This field is only applicable for Microsoft Customer Agreement billing accounts.
	BillingProfileID *string `json:"billingProfileId,omitempty"`
	// BillingPolicies - READ-ONLY; Dictionary of billing policies associated with the subscription.
	BillingPolicies map[string]*string `json:"billingPolicies"`
	// BillingProfileDisplayName - READ-ONLY; The display name of the billing profile to which the subscription is billed. This field is only applicable for Microsoft Customer Agreement billing accounts.
	BillingProfileDisplayName *string `json:"billingProfileDisplayName,omitempty"`
	// BillingProfileName - READ-ONLY; The name of the billing profile to which the subscription is billed. This field is only applicable for Microsoft Customer Agreement billing accounts.
	BillingProfileName *string `json:"billingProfileName,omitempty"`
	// ConsumptionCostCenter - The cost center applied to the subscription. This field is only available for consumption subscriptions of Microsoft Customer Agreement Type billing accounts.
	ConsumptionCostCenter *string `json:"consumptionCostCenter,omitempty"`
	// CustomerID - The ID of the customer for whom the subscription was created. The field is applicable only for Microsoft Partner Agreement billing accounts.
	CustomerID *string `json:"customerId,omitempty"`
	// CustomerDisplayName - READ-ONLY; The name of the customer for whom the subscription was created. The field is applicable only for Microsoft Partner Agreement billing accounts.
	CustomerDisplayName *string `json:"customerDisplayName,omitempty"`
	// DisplayName - The name of the subscription.
	DisplayName *string `json:"displayName,omitempty"`
	// EnrollmentAccountID - READ-ONLY; The enrollment Account ID associated with the subscription. This field is available only for the Enterprise Agreement billing accounts.
	EnrollmentAccountID *string `json:"enrollmentAccountId,omitempty"`
	// EnrollmentAccountDisplayName - READ-ONLY; The enrollment Account name associated with the subscription. This field is available only for the Enterprise Agreement billing accounts.
	EnrollmentAccountDisplayName          *string `json:"enrollmentAccountDisplayName,omitempty"`
	*EnrollmentAccountSubscriptionDetails `json:"enrollmentAccountSubscriptionDetails,omitempty"`
	// InvoiceSectionID - The ID of the invoice section to which the subscription is billed. The field is applicable only for Microsoft Partner Agreement billing accounts.
	InvoiceSectionID *string `json:"invoiceSectionId,omitempty"`
	// InvoiceSectionDisplayName - READ-ONLY; The display name of the invoice section to which the subscription is billed. The field is applicable only for Microsoft Partner Agreement billing accounts.
	InvoiceSectionDisplayName *string `json:"invoiceSectionDisplayName,omitempty"`
	// InvoiceSectionName - READ-ONLY; The name of the invoice section to which the subscription is billed. The field is applicable only for Microsoft Partner Agreement billing accounts.
	InvoiceSectionName *string `json:"invoiceSectionName,omitempty"`
	// LastMonthCharges - The last month's charges. This field is only available for usage based subscriptions of Microsoft Customer Agreement billing accounts.
	LastMonthCharges *Amount `json:"lastMonthCharges,omitempty"`
	// MonthToDateCharges - The current month to date charges. This field is only available for usage based subscriptions of Microsoft Customer Agreement billing accounts.
	MonthToDateCharges *Amount `json:"monthToDateCharges,omitempty"`
	// NextBillingCycleDetails - Next billing cycle details of the subscription.
	NextBillingCycleDetails *NextBillingCycleDetails `json:"nextBillingCycleDetails,omitempty"`
	// OfferID - READ-ONLY; The offer ID for the subscription. This field is only available for the Microsoft Online Services Program billing accounts.
	OfferID *string `json:"offerId,omitempty"`
	// ProductCategory - READ-ONLY; The category of the product for which the subscription is purchased. Possible values include: AzureSupport, Hardware, ReservationOrder, SaaS, SavingsPlanOrder, Software, UsageBased, Other
	ProductCategory *string `json:"productCategory,omitempty"`
	// ProductType - READ-ONLY; The type of the product for which the subscription is purchased
	ProductType *string `json:"productType,omitempty"`
	// ProductTypeID - The ID of the product for which the subscription is purchased
	ProductTypeID *string `json:"productTypeId,omitempty"`
	// PurchaseDate - READ-ONLY; The purchase date of the subscription in UTC time.
	PurchaseDate *date.Time `json:"purchaseDate,omitempty"`
	// Quantity - The number of licenses purchased for the subscription
	Quantity *int64 `json:"quantity,omitempty"`
	// Reseller - The reseller for which the subscription is created. The field is available for Microsoft Partner Agreement billing accounts.
	Reseller *Reseller `json:"reseller,omitempty"`
	// RenewalTermDetails - The term details of the subscription at the next renewal.
	RenewalTermDetails *RenewalTermDetails `json:"renewalTermDetails,omitempty"`
	// SkuDescription - READ-ONLY; The SKU description of the product for which the subscription is purchased. This field is only available for Microsoft Customer Agreement billing accounts.
	SkuDescription *string `json:"skuDescription,omitempty"`
	// SkuID - The SKU ID of the product for which the subscription is purchased. This field is only available for Microsoft Customer Agreement billing accounts.
	SkuID *string `json:"skuId,omitempty"`
	// Status - READ-ONLY; The status of the subscription. This field is not available for Enterprise Agreement billing accounts. Possible values include: 'SubscriptionStatusUnknown', 'SubscriptionStatusActive', 'SubscriptionStatusDisabled', 'SubscriptionStatusDeleted', 'SubscriptionStatusWarned', 'SubscriptionStatusExpiring', 'SubscriptionStatusExpired', 'SubscriptionStatusAutoRenew', 'SubscriptionStatusCancelled', 'SubscriptionStatusSuspended'
	Status SubscriptionStatus `json:"status,omitempty"`
	// SubscriptionID - READ-ONLY; The ID of the usage-based subscription. This field is only available for usage-based subscriptions of Microsoft Customer Agreement billing accounts.
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	// SuspensionReasons - READ-ONLY; The suspension reason for the subscription. This field is not available for Enterprise Agreement billing accounts.
	SuspensionReasons *[]string `json:"suspensionReasons,omitempty"`
	// TermDuration - The duration for which you can use the subscription. Example P1Y and P1M
	TermDuration *string `json:"termDuration,omitempty"`
	// TermStartDate - READ-ONLY; The start date of the term in UTC time.
	TermStartDate *date.Time `json:"termStartDate,omitempty"`
	// TermEndDate - READ-ONLY; The end date of the term in UTC time.
	TermEndDate *date.Time `json:"termEndDate,omitempty"`
}

// MarshalJSON is the custom marshaler for SubscriptionAliasProperties.
func (sap SubscriptionAliasProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sap.AutoRenew != "" {
		objectMap["autoRenew"] = sap.AutoRenew
	}
	if sap.BeneficiaryTenantID != nil {
		objectMap["beneficiaryTenantId"] = sap.BeneficiaryTenantID
	}
	if sap.BillingFrequency != nil {
		objectMap["billingFrequency"] = sap.BillingFrequency
	}
	if sap.BillingProfileID != nil {
		objectMap["billingProfileId"] = sap.BillingProfileID
	}
	if sap.ConsumptionCostCenter != nil {
		objectMap["consumptionCostCenter"] = sap.ConsumptionCostCenter
	}
	if sap.CustomerID != nil {
		objectMap["customerId"] = sap.CustomerID
	}
	if sap.DisplayName != nil {
		objectMap["displayName"] = sap.DisplayName
	}
	if sap.EnrollmentAccountSubscriptionDetails != nil {
		objectMap["enrollmentAccountSubscriptionDetails"] = sap.EnrollmentAccountSubscriptionDetails
	}
	if sap.InvoiceSectionID != nil {
		objectMap["invoiceSectionId"] = sap.InvoiceSectionID
	}
	if sap.LastMonthCharges != nil {
		objectMap["lastMonthCharges"] = sap.LastMonthCharges
	}
	if sap.MonthToDateCharges != nil {
		objectMap["monthToDateCharges"] = sap.MonthToDateCharges
	}
	if sap.NextBillingCycleDetails != nil {
		objectMap["nextBillingCycleDetails"] = sap.NextBillingCycleDetails
	}
	if sap.ProductTypeID != nil {
		objectMap["productTypeId"] = sap.ProductTypeID
	}
	if sap.Quantity != nil {
		objectMap["quantity"] = sap.Quantity
	}
	if sap.Reseller != nil {
		objectMap["reseller"] = sap.Reseller
	}
	if sap.RenewalTermDetails != nil {
		objectMap["renewalTermDetails"] = sap.RenewalTermDetails
	}
	if sap.SkuID != nil {
		objectMap["skuId"] = sap.SkuID
	}
	if sap.TermDuration != nil {
		objectMap["termDuration"] = sap.TermDuration
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SubscriptionAliasProperties struct.
func (sap *SubscriptionAliasProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "billingSubscriptionId":
			if v != nil {
				var billingSubscriptionID string
				err = json.Unmarshal(*v, &billingSubscriptionID)
				if err != nil {
					return err
				}
				sap.BillingSubscriptionID = &billingSubscriptionID
			}
		case "autoRenew":
			if v != nil {
				var autoRenew AutoRenew
				err = json.Unmarshal(*v, &autoRenew)
				if err != nil {
					return err
				}
				sap.AutoRenew = autoRenew
			}
		case "beneficiaryTenantId":
			if v != nil {
				var beneficiaryTenantID string
				err = json.Unmarshal(*v, &beneficiaryTenantID)
				if err != nil {
					return err
				}
				sap.BeneficiaryTenantID = &beneficiaryTenantID
			}
		case "billingFrequency":
			if v != nil {
				var billingFrequency string
				err = json.Unmarshal(*v, &billingFrequency)
				if err != nil {
					return err
				}
				sap.BillingFrequency = &billingFrequency
			}
		case "billingProfileId":
			if v != nil {
				var billingProfileID string
				err = json.Unmarshal(*v, &billingProfileID)
				if err != nil {
					return err
				}
				sap.BillingProfileID = &billingProfileID
			}
		case "billingPolicies":
			if v != nil {
				var billingPolicies map[string]*string
				err = json.Unmarshal(*v, &billingPolicies)
				if err != nil {
					return err
				}
				sap.BillingPolicies = billingPolicies
			}
		case "billingProfileDisplayName":
			if v != nil {
				var billingProfileDisplayName string
				err = json.Unmarshal(*v, &billingProfileDisplayName)
				if err != nil {
					return err
				}
				sap.BillingProfileDisplayName = &billingProfileDisplayName
			}
		case "billingProfileName":
			if v != nil {
				var billingProfileName string
				err = json.Unmarshal(*v, &billingProfileName)
				if err != nil {
					return err
				}
				sap.BillingProfileName = &billingProfileName
			}
		case "consumptionCostCenter":
			if v != nil {
				var consumptionCostCenter string
				err = json.Unmarshal(*v, &consumptionCostCenter)
				if err != nil {
					return err
				}
				sap.ConsumptionCostCenter = &consumptionCostCenter
			}
		case "customerId":
			if v != nil {
				var customerID string
				err = json.Unmarshal(*v, &customerID)
				if err != nil {
					return err
				}
				sap.CustomerID = &customerID
			}
		case "customerDisplayName":
			if v != nil {
				var customerDisplayName string
				err = json.Unmarshal(*v, &customerDisplayName)
				if err != nil {
					return err
				}
				sap.CustomerDisplayName = &customerDisplayName
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				sap.DisplayName = &displayName
			}
		case "enrollmentAccountId":
			if v != nil {
				var enrollmentAccountID string
				err = json.Unmarshal(*v, &enrollmentAccountID)
				if err != nil {
					return err
				}
				sap.EnrollmentAccountID = &enrollmentAccountID
			}
		case "enrollmentAccountDisplayName":
			if v != nil {
				var enrollmentAccountDisplayName string
				err = json.Unmarshal(*v, &enrollmentAccountDisplayName)
				if err != nil {
					return err
				}
				sap.EnrollmentAccountDisplayName = &enrollmentAccountDisplayName
			}
		case "enrollmentAccountSubscriptionDetails":
			if v != nil {
				var enrollmentAccountSubscriptionDetails EnrollmentAccountSubscriptionDetails
				err = json.Unmarshal(*v, &enrollmentAccountSubscriptionDetails)
				if err != nil {
					return err
				}
				sap.EnrollmentAccountSubscriptionDetails = &enrollmentAccountSubscriptionDetails
			}
		case "invoiceSectionId":
			if v != nil {
				var invoiceSectionID string
				err = json.Unmarshal(*v, &invoiceSectionID)
				if err != nil {
					return err
				}
				sap.InvoiceSectionID = &invoiceSectionID
			}
		case "invoiceSectionDisplayName":
			if v != nil {
				var invoiceSectionDisplayName string
				err = json.Unmarshal(*v, &invoiceSectionDisplayName)
				if err != nil {
					return err
				}
				sap.InvoiceSectionDisplayName = &invoiceSectionDisplayName
			}
		case "invoiceSectionName":
			if v != nil {
				var invoiceSectionName string
				err = json.Unmarshal(*v, &invoiceSectionName)
				if err != nil {
					return err
				}
				sap.InvoiceSectionName = &invoiceSectionName
			}
		case "lastMonthCharges":
			if v != nil {
				var lastMonthCharges Amount
				err = json.Unmarshal(*v, &lastMonthCharges)
				if err != nil {
					return err
				}
				sap.LastMonthCharges = &lastMonthCharges
			}
		case "monthToDateCharges":
			if v != nil {
				var monthToDateCharges Amount
				err = json.Unmarshal(*v, &monthToDateCharges)
				if err != nil {
					return err
				}
				sap.MonthToDateCharges = &monthToDateCharges
			}
		case "nextBillingCycleDetails":
			if v != nil {
				var nextBillingCycleDetails NextBillingCycleDetails
				err = json.Unmarshal(*v, &nextBillingCycleDetails)
				if err != nil {
					return err
				}
				sap.NextBillingCycleDetails = &nextBillingCycleDetails
			}
		case "offerId":
			if v != nil {
				var offerID string
				err = json.Unmarshal(*v, &offerID)
				if err != nil {
					return err
				}
				sap.OfferID = &offerID
			}
		case "productCategory":
			if v != nil {
				var productCategory string
				err = json.Unmarshal(*v, &productCategory)
				if err != nil {
					return err
				}
				sap.ProductCategory = &productCategory
			}
		case "productType":
			if v != nil {
				var productType string
				err = json.Unmarshal(*v, &productType)
				if err != nil {
					return err
				}
				sap.ProductType = &productType
			}
		case "productTypeId":
			if v != nil {
				var productTypeID string
				err = json.Unmarshal(*v, &productTypeID)
				if err != nil {
					return err
				}
				sap.ProductTypeID = &productTypeID
			}
		case "purchaseDate":
			if v != nil {
				var purchaseDate date.Time
				err = json.Unmarshal(*v, &purchaseDate)
				if err != nil {
					return err
				}
				sap.PurchaseDate = &purchaseDate
			}
		case "quantity":
			if v != nil {
				var quantity int64
				err = json.Unmarshal(*v, &quantity)
				if err != nil {
					return err
				}
				sap.Quantity = &quantity
			}
		case "reseller":
			if v != nil {
				var reseller Reseller
				err = json.Unmarshal(*v, &reseller)
				if err != nil {
					return err
				}
				sap.Reseller = &reseller
			}
		case "renewalTermDetails":
			if v != nil {
				var renewalTermDetails RenewalTermDetails
				err = json.Unmarshal(*v, &renewalTermDetails)
				if err != nil {
					return err
				}
				sap.RenewalTermDetails = &renewalTermDetails
			}
		case "skuDescription":
			if v != nil {
				var skuDescription string
				err = json.Unmarshal(*v, &skuDescription)
				if err != nil {
					return err
				}
				sap.SkuDescription = &skuDescription
			}
		case "skuId":
			if v != nil {
				var skuID string
				err = json.Unmarshal(*v, &skuID)
				if err != nil {
					return err
				}
				sap.SkuID = &skuID
			}
		case "status":
			if v != nil {
				var status SubscriptionStatus
				err = json.Unmarshal(*v, &status)
				if err != nil {
					return err
				}
				sap.Status = status
			}
		case "subscriptionId":
			if v != nil {
				var subscriptionID string
				err = json.Unmarshal(*v, &subscriptionID)
				if err != nil {
					return err
				}
				sap.SubscriptionID = &subscriptionID
			}
		case "suspensionReasons":
			if v != nil {
				var suspensionReasons []string
				err = json.Unmarshal(*v, &suspensionReasons)
				if err != nil {
					return err
				}
				sap.SuspensionReasons = &suspensionReasons
			}
		case "termDuration":
			if v != nil {
				var termDuration string
				err = json.Unmarshal(*v, &termDuration)
				if err != nil {
					return err
				}
				sap.TermDuration = &termDuration
			}
		case "termStartDate":
			if v != nil {
				var termStartDate date.Time
				err = json.Unmarshal(*v, &termStartDate)
				if err != nil {
					return err
				}
				sap.TermStartDate = &termStartDate
			}
		case "termEndDate":
			if v != nil {
				var termEndDate date.Time
				err = json.Unmarshal(*v, &termEndDate)
				if err != nil {
					return err
				}
				sap.TermEndDate = &termEndDate
			}
		}
	}

	return nil
}

// SubscriptionMergeRequest request to merge two billing subscriptions
type SubscriptionMergeRequest struct {
	// TargetBillingSubscriptionName - The ID of the target billing subscription that will be merged with the source subscription provided in the request.
	TargetBillingSubscriptionName *string `json:"targetBillingSubscriptionName,omitempty"`
	// Quantity - The quantity of the source billing subscription that will be merged with the target billing subscription.
	Quantity *int32 `json:"quantity,omitempty"`
}

// SubscriptionProperties the billing properties of a subscription.
type SubscriptionProperties struct {
	// AutoRenew - Indicates whether auto renewal is turned on or off for a subscription. Possible values include: 'Off', 'On'
	AutoRenew AutoRenew `json:"autoRenew,omitempty"`
	// BeneficiaryTenantID - The provisioning tenant of the subscription.
	BeneficiaryTenantID *string `json:"beneficiaryTenantId,omitempty"`
	// BillingFrequency - The billing frequency of the subscription in the ISO8601 format. Example: P1M, P3M, P1Y
	BillingFrequency *string `json:"billingFrequency,omitempty"`
	// BillingProfileID - The ID of the billing profile to which the subscription is billed. This field is only applicable for Microsoft Customer Agreement billing accounts.
	BillingProfileID *string `json:"billingProfileId,omitempty"`
	// BillingPolicies - READ-ONLY; Dictionary of billing policies associated with the subscription.
	BillingPolicies map[string]*string `json:"billingPolicies"`
	// BillingProfileDisplayName - READ-ONLY; The display name of the billing profile to which the subscription is billed. This field is only applicable for Microsoft Customer Agreement billing accounts.
	BillingProfileDisplayName *string `json:"billingProfileDisplayName,omitempty"`
	// BillingProfileName - READ-ONLY; The name of the billing profile to which the subscription is billed. This field is only applicable for Microsoft Customer Agreement billing accounts.
	BillingProfileName *string `json:"billingProfileName,omitempty"`
	// ConsumptionCostCenter - The cost center applied to the subscription. This field is only available for consumption subscriptions of Microsoft Customer Agreement Type billing accounts.
	ConsumptionCostCenter *string `json:"consumptionCostCenter,omitempty"`
	// CustomerID - The ID of the customer for whom the subscription was created. The field is applicable only for Microsoft Partner Agreement billing accounts.
	CustomerID *string `json:"customerId,omitempty"`
	// CustomerDisplayName - READ-ONLY; The name of the customer for whom the subscription was created. The field is applicable only for Microsoft Partner Agreement billing accounts.
	CustomerDisplayName *string `json:"customerDisplayName,omitempty"`
	// DisplayName - The name of the subscription.
	DisplayName *string `json:"displayName,omitempty"`
	// EnrollmentAccountID - READ-ONLY; The enrollment Account ID associated with the subscription. This field is available only for the Enterprise Agreement billing accounts.
	EnrollmentAccountID *string `json:"enrollmentAccountId,omitempty"`
	// EnrollmentAccountDisplayName - READ-ONLY; The enrollment Account name associated with the subscription. This field is available only for the Enterprise Agreement billing accounts.
	EnrollmentAccountDisplayName          *string `json:"enrollmentAccountDisplayName,omitempty"`
	*EnrollmentAccountSubscriptionDetails `json:"enrollmentAccountSubscriptionDetails,omitempty"`
	// InvoiceSectionID - The ID of the invoice section to which the subscription is billed. The field is applicable only for Microsoft Partner Agreement billing accounts.
	InvoiceSectionID *string `json:"invoiceSectionId,omitempty"`
	// InvoiceSectionDisplayName - READ-ONLY; The display name of the invoice section to which the subscription is billed. The field is applicable only for Microsoft Partner Agreement billing accounts.
	InvoiceSectionDisplayName *string `json:"invoiceSectionDisplayName,omitempty"`
	// InvoiceSectionName - READ-ONLY; The name of the invoice section to which the subscription is billed. The field is applicable only for Microsoft Partner Agreement billing accounts.
	InvoiceSectionName *string `json:"invoiceSectionName,omitempty"`
	// LastMonthCharges - The last month's charges. This field is only available for usage based subscriptions of Microsoft Customer Agreement billing accounts.
	LastMonthCharges *Amount `json:"lastMonthCharges,omitempty"`
	// MonthToDateCharges - The current month to date charges. This field is only available for usage based subscriptions of Microsoft Customer Agreement billing accounts.
	MonthToDateCharges *Amount `json:"monthToDateCharges,omitempty"`
	// NextBillingCycleDetails - Next billing cycle details of the subscription.
	NextBillingCycleDetails *NextBillingCycleDetails `json:"nextBillingCycleDetails,omitempty"`
	// OfferID - READ-ONLY; The offer ID for the subscription. This field is only available for the Microsoft Online Services Program billing accounts.
	OfferID *string `json:"offerId,omitempty"`
	// ProductCategory - READ-ONLY; The category of the product for which the subscription is purchased. Possible values include: AzureSupport, Hardware, ReservationOrder, SaaS, SavingsPlanOrder, Software, UsageBased, Other
	ProductCategory *string `json:"productCategory,omitempty"`
	// ProductType - READ-ONLY; The type of the product for which the subscription is purchased
	ProductType *string `json:"productType,omitempty"`
	// ProductTypeID - The ID of the product for which the subscription is purchased
	ProductTypeID *string `json:"productTypeId,omitempty"`
	// PurchaseDate - READ-ONLY; The purchase date of the subscription in UTC time.
	PurchaseDate *date.Time `json:"purchaseDate,omitempty"`
	// Quantity - The number of licenses purchased for the subscription
	Quantity *int64 `json:"quantity,omitempty"`
	// Reseller - The reseller for which the subscription is created. The field is available for Microsoft Partner Agreement billing accounts.
	Reseller *Reseller `json:"reseller,omitempty"`
	// RenewalTermDetails - The term details of the subscription at the next renewal.
	RenewalTermDetails *RenewalTermDetails `json:"renewalTermDetails,omitempty"`
	// SkuDescription - READ-ONLY; The SKU description of the product for which the subscription is purchased. This field is only available for Microsoft Customer Agreement billing accounts.
	SkuDescription *string `json:"skuDescription,omitempty"`
	// SkuID - The SKU ID of the product for which the subscription is purchased. This field is only available for Microsoft Customer Agreement billing accounts.
	SkuID *string `json:"skuId,omitempty"`
	// Status - READ-ONLY; The status of the subscription. This field is not available for Enterprise Agreement billing accounts. Possible values include: 'SubscriptionStatusUnknown', 'SubscriptionStatusActive', 'SubscriptionStatusDisabled', 'SubscriptionStatusDeleted', 'SubscriptionStatusWarned', 'SubscriptionStatusExpiring', 'SubscriptionStatusExpired', 'SubscriptionStatusAutoRenew', 'SubscriptionStatusCancelled', 'SubscriptionStatusSuspended'
	Status SubscriptionStatus `json:"status,omitempty"`
	// SubscriptionID - READ-ONLY; The ID of the usage-based subscription. This field is only available for usage-based subscriptions of Microsoft Customer Agreement billing accounts.
	SubscriptionID *string `json:"subscriptionId,omitempty"`
	// SuspensionReasons - READ-ONLY; The suspension reason for the subscription. This field is not available for Enterprise Agreement billing accounts.
	SuspensionReasons *[]string `json:"suspensionReasons,omitempty"`
	// TermDuration - The duration for which you can use the subscription. Example P1Y and P1M
	TermDuration *string `json:"termDuration,omitempty"`
	// TermStartDate - READ-ONLY; The start date of the term in UTC time.
	TermStartDate *date.Time `json:"termStartDate,omitempty"`
	// TermEndDate - READ-ONLY; The end date of the term in UTC time.
	TermEndDate *date.Time `json:"termEndDate,omitempty"`
}

// MarshalJSON is the custom marshaler for SubscriptionProperties.
func (sp SubscriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sp.AutoRenew != "" {
		objectMap["autoRenew"] = sp.AutoRenew
	}
	if sp.BeneficiaryTenantID != nil {
		objectMap["beneficiaryTenantId"] = sp.BeneficiaryTenantID
	}
	if sp.BillingFrequency != nil {
		objectMap["billingFrequency"] = sp.BillingFrequency
	}
	if sp.BillingProfileID != nil {
		objectMap["billingProfileId"] = sp.BillingProfileID
	}
	if sp.ConsumptionCostCenter != nil {
		objectMap["consumptionCostCenter"] = sp.ConsumptionCostCenter
	}
	if sp.CustomerID != nil {
		objectMap["customerId"] = sp.CustomerID
	}
	if sp.DisplayName != nil {
		objectMap["displayName"] = sp.DisplayName
	}
	if sp.EnrollmentAccountSubscriptionDetails != nil {
		objectMap["enrollmentAccountSubscriptionDetails"] = sp.EnrollmentAccountSubscriptionDetails
	}
	if sp.InvoiceSectionID != nil {
		objectMap["invoiceSectionId"] = sp.InvoiceSectionID
	}
	if sp.LastMonthCharges != nil {
		objectMap["lastMonthCharges"] = sp.LastMonthCharges
	}
	if sp.MonthToDateCharges != nil {
		objectMap["monthToDateCharges"] = sp.MonthToDateCharges
	}
	if sp.NextBillingCycleDetails != nil {
		objectMap["nextBillingCycleDetails"] = sp.NextBillingCycleDetails
	}
	if sp.ProductTypeID != nil {
		objectMap["productTypeId"] = sp.ProductTypeID
	}
	if sp.Quantity != nil {
		objectMap["quantity"] = sp.Quantity
	}
	if sp.Reseller != nil {
		objectMap["reseller"] = sp.Reseller
	}
	if sp.RenewalTermDetails != nil {
		objectMap["renewalTermDetails"] = sp.RenewalTermDetails
	}
	if sp.SkuID != nil {
		objectMap["skuId"] = sp.SkuID
	}
	if sp.TermDuration != nil {
		objectMap["termDuration"] = sp.TermDuration
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SubscriptionProperties struct.
func (sp *SubscriptionProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "autoRenew":
			if v != nil {
				var autoRenew AutoRenew
				err = json.Unmarshal(*v, &autoRenew)
				if err != nil {
					return err
				}
				sp.AutoRenew = autoRenew
			}
		case "beneficiaryTenantId":
			if v != nil {
				var beneficiaryTenantID string
				err = json.Unmarshal(*v, &beneficiaryTenantID)
				if err != nil {
					return err
				}
				sp.BeneficiaryTenantID = &beneficiaryTenantID
			}
		case "billingFrequency":
			if v != nil {
				var billingFrequency string
				err = json.Unmarshal(*v, &billingFrequency)
				if err != nil {
					return err
				}
				sp.BillingFrequency = &billingFrequency
			}
		case "billingProfileId":
			if v != nil {
				var billingProfileID string
				err = json.Unmarshal(*v, &billingProfileID)
				if err != nil {
					return err
				}
				sp.BillingProfileID = &billingProfileID
			}
		case "billingPolicies":
			if v != nil {
				var billingPolicies map[string]*string
				err = json.Unmarshal(*v, &billingPolicies)
				if err != nil {
					return err
				}
				sp.BillingPolicies = billingPolicies
			}
		case "billingProfileDisplayName":
			if v != nil {
				var billingProfileDisplayName string
				err = json.Unmarshal(*v, &billingProfileDisplayName)
				if err != nil {
					return err
				}
				sp.BillingProfileDisplayName = &billingProfileDisplayName
			}
		case "billingProfileName":
			if v != nil {
				var billingProfileName string
				err = json.Unmarshal(*v, &billingProfileName)
				if err != nil {
					return err
				}
				sp.BillingProfileName = &billingProfileName
			}
		case "consumptionCostCenter":
			if v != nil {
				var consumptionCostCenter string
				err = json.Unmarshal(*v, &consumptionCostCenter)
				if err != nil {
					return err
				}
				sp.ConsumptionCostCenter = &consumptionCostCenter
			}
		case "customerId":
			if v != nil {
				var customerID string
				err = json.Unmarshal(*v, &customerID)
				if err != nil {
					return err
				}
				sp.CustomerID = &customerID
			}
		case "customerDisplayName":
			if v != nil {
				var customerDisplayName string
				err = json.Unmarshal(*v, &customerDisplayName)
				if err != nil {
					return err
				}
				sp.CustomerDisplayName = &customerDisplayName
			}
		case "displayName":
			if v != nil {
				var displayName string
				err = json.Unmarshal(*v, &displayName)
				if err != nil {
					return err
				}
				sp.DisplayName = &displayName
			}
		case "enrollmentAccountId":
			if v != nil {
				var enrollmentAccountID string
				err = json.Unmarshal(*v, &enrollmentAccountID)
				if err != nil {
					return err
				}
				sp.EnrollmentAccountID = &enrollmentAccountID
			}
		case "enrollmentAccountDisplayName":
			if v != nil {
				var enrollmentAccountDisplayName string
				err = json.Unmarshal(*v, &enrollmentAccountDisplayName)
				if err != nil {
					return err
				}
				sp.EnrollmentAccountDisplayName = &enrollmentAccountDisplayName
			}
		case "enrollmentAccountSubscriptionDetails":
			if v != nil {
				var enrollmentAccountSubscriptionDetails EnrollmentAccountSubscriptionDetails
				err = json.Unmarshal(*v, &enrollmentAccountSubscriptionDetails)
				if err != nil {
					return err
				}
				sp.EnrollmentAccountSubscriptionDetails = &enrollmentAccountSubscriptionDetails
			}
		case "invoiceSectionId":
			if v != nil {
				var invoiceSectionID string
				err = json.Unmarshal(*v, &invoiceSectionID)
				if err != nil {
					return err
				}
				sp.InvoiceSectionID = &invoiceSectionID
			}
		case "invoiceSectionDisplayName":
			if v != nil {
				var invoiceSectionDisplayName string
				err = json.Unmarshal(*v, &invoiceSectionDisplayName)
				if err != nil {
					return err
				}
				sp.InvoiceSectionDisplayName = &invoiceSectionDisplayName
			}
		case "invoiceSectionName":
			if v != nil {
				var invoiceSectionName string
				err = json.Unmarshal(*v, &invoiceSectionName)
				if err != nil {
					return err
				}
				sp.InvoiceSectionName = &invoiceSectionName
			}
		case "lastMonthCharges":
			if v != nil {
				var lastMonthCharges Amount
				err = json.Unmarshal(*v, &lastMonthCharges)
				if err != nil {
					return err
				}
				sp.LastMonthCharges = &lastMonthCharges
			}
		case "monthToDateCharges":
			if v != nil {
				var monthToDateCharges Amount
				err = json.Unmarshal(*v, &monthToDateCharges)
				if err != nil {
					return err
				}
				sp.MonthToDateCharges = &monthToDateCharges
			}
		case "nextBillingCycleDetails":
			if v != nil {
				var nextBillingCycleDetails NextBillingCycleDetails
				err = json.Unmarshal(*v, &nextBillingCycleDetails)
				if err != nil {
					return err
				}
				sp.NextBillingCycleDetails = &nextBillingCycleDetails
			}
		case "offerId":
			if v != nil {
				var offerID string
				err = json.Unmarshal(*v, &offerID)
				if err != nil {
					return err
				}
				sp.OfferID = &offerID
			}
		case "productCategory":
			if v != nil {
				var productCategory string
				err = json.Unmarshal(*v, &productCategory)
				if err != nil {
					return err
				}
				sp.ProductCategory = &productCategory
			}
		case "productType":
			if v != nil {
				var productType string
				err = json.Unmarshal(*v, &productType)
				if err != nil {
					return err
				}
				sp.ProductType = &productType
			}
		case "productTypeId":
			if v != nil {
				var productTypeID string
				err = json.Unmarshal(*v, &productTypeID)
				if err != nil {
					return err
				}
				sp.ProductTypeID = &productTypeID
			}
		case "purchaseDate":
			if v != nil {
				var purchaseDate date.Time
				err = json.Unmarshal(*v, &purchaseDate)
				if err != nil {
					return err
				}
				sp.PurchaseDate = &purchaseDate
			}
		case "quantity":
			if v != nil {
				var quantity int64
				err = json.Unmarshal(*v, &quantity)
				if err != nil {
					return err
				}
				sp.Quantity = &quantity
			}
		case "reseller":
			if v != nil {
				var reseller Reseller
				err = json.Unmarshal(*v, &reseller)
				if err != nil {
					return err
				}
				sp.Reseller = &reseller
			}
		case "renewalTermDetails":
			if v != nil {
				var renewalTermDetails RenewalTermDetails
				err = json.Unmarshal(*v, &renewalTermDetails)
				if err != nil {
					return err
				}
				sp.RenewalTermDetails = &renewalTermDetails
			}
		case "skuDescription":
			if v != nil {
				var skuDescription string
				err = json.Unmarshal(*v, &skuDescription)
				if err != nil {
					return err
				}
				sp.SkuDescription = &skuDescription
			}
		case "skuId":
			if v != nil {
				var skuID string
				err = json.Unmarshal(*v, &skuID)
				if err != nil {
					return err
				}
				sp.SkuID = &skuID
			}
		case "status":
			if v != nil {
				var status SubscriptionStatus
				err = json.Unmarshal(*v, &status)
				if err != nil {
					return err
				}
				sp.Status = status
			}
		case "subscriptionId":
			if v != nil {
				var subscriptionID string
				err = json.Unmarshal(*v, &subscriptionID)
				if err != nil {
					return err
				}
				sp.SubscriptionID = &subscriptionID
			}
		case "suspensionReasons":
			if v != nil {
				var suspensionReasons []string
				err = json.Unmarshal(*v, &suspensionReasons)
				if err != nil {
					return err
				}
				sp.SuspensionReasons = &suspensionReasons
			}
		case "termDuration":
			if v != nil {
				var termDuration string
				err = json.Unmarshal(*v, &termDuration)
				if err != nil {
					return err
				}
				sp.TermDuration = &termDuration
			}
		case "termStartDate":
			if v != nil {
				var termStartDate date.Time
				err = json.Unmarshal(*v, &termStartDate)
				if err != nil {
					return err
				}
				sp.TermStartDate = &termStartDate
			}
		case "termEndDate":
			if v != nil {
				var termEndDate date.Time
				err = json.Unmarshal(*v, &termEndDate)
				if err != nil {
					return err
				}
				sp.TermEndDate = &termEndDate
			}
		}
	}

	return nil
}

// SubscriptionsAliasesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SubscriptionsAliasesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubscriptionsAliasesClient) (SubscriptionAlias, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SubscriptionsAliasesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SubscriptionsAliasesCreateOrUpdateFuture.Result.
func (future *SubscriptionsAliasesCreateOrUpdateFuture) result(client SubscriptionsAliasesClient) (sa SubscriptionAlias, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.SubscriptionsAliasesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sa.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("billing.SubscriptionsAliasesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sa.Response.Response, err = future.GetResult(sender); err == nil && sa.Response.Response.StatusCode != http.StatusNoContent {
		sa, err = client.CreateOrUpdateResponder(sa.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "billing.SubscriptionsAliasesCreateOrUpdateFuture", "Result", sa.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SubscriptionsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SubscriptionsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubscriptionsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SubscriptionsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SubscriptionsDeleteFuture.Result.
func (future *SubscriptionsDeleteFuture) result(client SubscriptionsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.SubscriptionsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("billing.SubscriptionsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// SubscriptionsListResult the list of billing subscriptions.
type SubscriptionsListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; The list of billing subscriptions.
	Value *[]Subscription `json:"value,omitempty"`
	// NextLink - READ-ONLY; The link (url) to the next page of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for SubscriptionsListResult.
func (slr SubscriptionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SubscriptionsListResultIterator provides access to a complete listing of Subscription values.
type SubscriptionsListResultIterator struct {
	i    int
	page SubscriptionsListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SubscriptionsListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SubscriptionsListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SubscriptionsListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SubscriptionsListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SubscriptionsListResultIterator) Response() SubscriptionsListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SubscriptionsListResultIterator) Value() Subscription {
	if !iter.page.NotDone() {
		return Subscription{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SubscriptionsListResultIterator type.
func NewSubscriptionsListResultIterator(page SubscriptionsListResultPage) SubscriptionsListResultIterator {
	return SubscriptionsListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (slr SubscriptionsListResult) IsEmpty() bool {
	return slr.Value == nil || len(*slr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (slr SubscriptionsListResult) hasNextLink() bool {
	return slr.NextLink != nil && len(*slr.NextLink) != 0
}

// subscriptionsListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (slr SubscriptionsListResult) subscriptionsListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !slr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(slr.NextLink)))
}

// SubscriptionsListResultPage contains a page of Subscription values.
type SubscriptionsListResultPage struct {
	fn  func(context.Context, SubscriptionsListResult) (SubscriptionsListResult, error)
	slr SubscriptionsListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SubscriptionsListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SubscriptionsListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.slr)
		if err != nil {
			return err
		}
		page.slr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SubscriptionsListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SubscriptionsListResultPage) NotDone() bool {
	return !page.slr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SubscriptionsListResultPage) Response() SubscriptionsListResult {
	return page.slr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SubscriptionsListResultPage) Values() []Subscription {
	if page.slr.IsEmpty() {
		return nil
	}
	return *page.slr.Value
}

// Creates a new instance of the SubscriptionsListResultPage type.
func NewSubscriptionsListResultPage(cur SubscriptionsListResult, getNextPage func(context.Context, SubscriptionsListResult) (SubscriptionsListResult, error)) SubscriptionsListResultPage {
	return SubscriptionsListResultPage{
		fn:  getNextPage,
		slr: cur,
	}
}

// SubscriptionsMergeFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SubscriptionsMergeFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubscriptionsClient) (Subscription, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SubscriptionsMergeFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SubscriptionsMergeFuture.Result.
func (future *SubscriptionsMergeFuture) result(client SubscriptionsClient) (s Subscription, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.SubscriptionsMergeFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("billing.SubscriptionsMergeFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.MergeResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "billing.SubscriptionsMergeFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SubscriptionsMoveFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SubscriptionsMoveFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubscriptionsClient) (Subscription, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SubscriptionsMoveFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SubscriptionsMoveFuture.Result.
func (future *SubscriptionsMoveFuture) result(client SubscriptionsClient) (s Subscription, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.SubscriptionsMoveFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("billing.SubscriptionsMoveFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.MoveResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "billing.SubscriptionsMoveFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SubscriptionSplitRequest request to split a billing subscription
type SubscriptionSplitRequest struct {
	// BillingFrequency - The billing frequency of the target subscription in the ISO8601 format. Example: P1M, P3M, P1Y
	BillingFrequency *string `json:"billingFrequency,omitempty"`
	// Quantity - The quantity of the target product to which the subscription needs to be split into.
	Quantity *int32 `json:"quantity,omitempty"`
	// TargetProductTypeID - The ID of the target product to which the subscription needs to be split into. This value is not same as the value returned in Get API call and can be retrieved from Catalog API to know the product id to split into.
	TargetProductTypeID *string `json:"targetProductTypeId,omitempty"`
	// TargetSkuID - The ID of the target product to which the subscription needs to be split into. This value is not same as the value returned in Get API call and can be retrieved from Catalog API to know the sku id to split into.
	TargetSkuID *string `json:"targetSkuId,omitempty"`
	// TermDuration - The term duration of the target in ISO8601 format product to which the subscription needs to be split into. Example: P1M, P1Y
	TermDuration *string `json:"termDuration,omitempty"`
}

// SubscriptionsSplitFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SubscriptionsSplitFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubscriptionsClient) (Subscription, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SubscriptionsSplitFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SubscriptionsSplitFuture.Result.
func (future *SubscriptionsSplitFuture) result(client SubscriptionsClient) (s Subscription, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.SubscriptionsSplitFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("billing.SubscriptionsSplitFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.SplitResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "billing.SubscriptionsSplitFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SubscriptionsUpdateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SubscriptionsUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SubscriptionsClient) (Subscription, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SubscriptionsUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SubscriptionsUpdateFuture.Result.
func (future *SubscriptionsUpdateFuture) result(client SubscriptionsClient) (s Subscription, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "billing.SubscriptionsUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		s.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("billing.SubscriptionsUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if s.Response.Response, err = future.GetResult(sender); err == nil && s.Response.Response.StatusCode != http.StatusNoContent {
		s, err = client.UpdateResponder(s.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "billing.SubscriptionsUpdateFuture", "Result", s.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ValidateMoveBillingSubscriptionEligibilityError error details of the transfer eligibility validation
type ValidateMoveBillingSubscriptionEligibilityError struct {
	// Code - Error code for the billing subscription move validation. Possible values include: 'AccountIsLocked', 'AssetNotActive', 'AssetHasCap', 'BillingAccountInactive', 'BillingProfilePastDue', 'CrossBillingAccountNotAllowed', 'DestinationBillingProfileNotFound', 'DestinationBillingProfileInactive', 'DestinationBillingProfilePastDue', 'DestinationInvoiceSectionNotFound', 'DestinationInvoiceSectionInactive', 'InvalidDestination', 'InvalidSource', 'InvoiceSectionIsRestricted', 'InsufficientPermissionOnDestination', 'InsufficientPermissionOnSource', 'MarketplaceNotEnabledOnDestination', 'ProductNotFound', 'ProductInactive', 'ProductTypeNotSupported', 'SourceBillingProfilePastDue', 'SourceInvoiceSectionInactive', 'SubscriptionNotActive', 'SubscriptionTypeNotSupported'
	Code SubscriptionTransferValidationErrorCode `json:"code,omitempty"`
	// Message - The error message.
	Message *string `json:"message,omitempty"`
	// Details - Detailed error message explaining the error.
	Details *string `json:"details,omitempty"`
}

// ValidateMoveBillingSubscriptionEligibilityResult result of the transfer eligibility validation.
type ValidateMoveBillingSubscriptionEligibilityResult struct {
	autorest.Response `json:"-"`
	// IsMoveEligible - READ-ONLY; Specifies whether the subscription is eligible to move.
	IsMoveEligible *bool `json:"isMoveEligible,omitempty"`
	// ErrorDetails - Validation error details.
	ErrorDetails *ValidateMoveBillingSubscriptionEligibilityError `json:"errorDetails,omitempty"`
}

// MarshalJSON is the custom marshaler for ValidateMoveBillingSubscriptionEligibilityResult.
func (vmbser ValidateMoveBillingSubscriptionEligibilityResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vmbser.ErrorDetails != nil {
		objectMap["errorDetails"] = vmbser.ErrorDetails
	}
	return json.Marshal(objectMap)
}
