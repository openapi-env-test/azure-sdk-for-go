package workloads

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"github.com/gofrs/uuid"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/workloads/mgmt/2021-12-01-preview/workloads"

// ApplicationServerConfiguration gets or sets the application server configuration.
type ApplicationServerConfiguration struct {
	// SubnetID - The subnet id.
	SubnetID *string `json:"subnetId,omitempty"`
	// VirtualMachineConfiguration - Gets or sets the virtual machine configuration.
	VirtualMachineConfiguration *VirtualMachineConfiguration `json:"virtualMachineConfiguration,omitempty"`
	// InstanceCount - The number of app server instances.
	InstanceCount *int64 `json:"instanceCount,omitempty"`
}

// AzureEntityResource the resource model definition for an Azure Resource Manager resource with an etag.
type AzureEntityResource struct {
	// Etag - READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureEntityResource.
func (aer AzureEntityResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// BackupProfile backup profile
type BackupProfile struct {
	// BackupEnabled - Whether to enable Azure backup for the workload. Possible values include: 'EnableBackupEnabled', 'EnableBackupDisabled'
	BackupEnabled EnableBackup `json:"backupEnabled,omitempty"`
	// VaultResourceID - READ-ONLY; Backup vault resource Id
	VaultResourceID *string `json:"vaultResourceId,omitempty"`
}

// MarshalJSON is the custom marshaler for BackupProfile.
func (bp BackupProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if bp.BackupEnabled != "" {
		objectMap["backupEnabled"] = bp.BackupEnabled
	}
	return json.Marshal(objectMap)
}

// CacheProfile cache profile
type CacheProfile struct {
	// Name - Cache name
	Name *string `json:"name,omitempty"`
	// SkuName - Cache SKU name
	SkuName *string `json:"skuName,omitempty"`
	// Family - Cache family. Possible values include: 'C', 'P'
	Family RedisCacheFamily `json:"family,omitempty"`
	// Capacity - Cache capacity
	Capacity *int64 `json:"capacity,omitempty"`
	// CacheResourceID - READ-ONLY; Cache resource Id
	CacheResourceID *string `json:"cacheResourceId,omitempty"`
}

// MarshalJSON is the custom marshaler for CacheProfile.
func (cp CacheProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if cp.Name != nil {
		objectMap["name"] = cp.Name
	}
	if cp.SkuName != nil {
		objectMap["skuName"] = cp.SkuName
	}
	if cp.Family != "" {
		objectMap["family"] = cp.Family
	}
	if cp.Capacity != nil {
		objectMap["capacity"] = cp.Capacity
	}
	return json.Marshal(objectMap)
}

// CentralServerConfiguration gets or sets the central server configuration.
type CentralServerConfiguration struct {
	// SubnetID - The subnet id.
	SubnetID *string `json:"subnetId,omitempty"`
	// VirtualMachineConfiguration - Gets or sets the virtual machine configuration.
	VirtualMachineConfiguration *VirtualMachineConfiguration `json:"virtualMachineConfiguration,omitempty"`
	// InstanceCount - The number of central server VMs.
	InstanceCount *int64 `json:"instanceCount,omitempty"`
}

// CentralServerVMDetails the Central Server VM Details.
type CentralServerVMDetails struct {
	// Type - READ-ONLY; Possible values include: 'Primary', 'Secondary', 'Unknown', 'ASCS', 'ERSInactive', 'ERS', 'Standby'
	Type CentralServerVirtualMachineType `json:"type,omitempty"`
	// VirtualMachineID - READ-ONLY
	VirtualMachineID *string `json:"virtualMachineId,omitempty"`
}

// MarshalJSON is the custom marshaler for CentralServerVMDetails.
func (csvd CentralServerVMDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DatabaseConfiguration gets or sets the database configuration.
type DatabaseConfiguration struct {
	// DatabaseType - The database type. Possible values include: 'HANA', 'DB2'
	DatabaseType SAPDatabaseType `json:"databaseType,omitempty"`
	// SubnetID - The subnet id.
	SubnetID *string `json:"subnetId,omitempty"`
	// VirtualMachineConfiguration - Gets or sets the virtual machine configuration.
	VirtualMachineConfiguration *VirtualMachineConfiguration `json:"virtualMachineConfiguration,omitempty"`
	// InstanceCount - The number of database VMs.
	InstanceCount *int64 `json:"instanceCount,omitempty"`
}

// DatabaseProfile workload database profile
type DatabaseProfile struct {
	// Type - Database type
	Type *string `json:"type,omitempty"`
	// ServerName - Database server name
	ServerName *string `json:"serverName,omitempty"`
	// Version - Database version
	Version *string `json:"version,omitempty"`
	// Sku - The name of the server SKU, e.g. Standard_D32s_v4
	Sku *string `json:"sku,omitempty"`
	// Tier - Tier of the server SKU. Possible values include: 'Burstable', 'GeneralPurpose', 'MemoryOptimized'
	Tier DatabaseTier `json:"tier,omitempty"`
	// HaEnabled - Whether to enable HA for the server. Possible values include: 'HAEnabledEnabled', 'HAEnabledDisabled'
	HaEnabled HAEnabled `json:"haEnabled,omitempty"`
	// StorageSku - SKU name for database storage
	StorageSku *string `json:"storageSku,omitempty"`
	// StorageInGB - Database storage size in GB
	StorageInGB *int64 `json:"storageInGB,omitempty"`
	// StorageIops - Storage IOPS for the server
	StorageIops *int64 `json:"storageIops,omitempty"`
	// BackupRetentionDays - Backup retention days for the server
	BackupRetentionDays *int32 `json:"backupRetentionDays,omitempty"`
	// SslEnforcementEnabled - Whether to enable SSL enforcement on the database. Possible values include: 'EnableSslEnforcementEnabled', 'EnableSslEnforcementDisabled'
	SslEnforcementEnabled EnableSslEnforcement `json:"sslEnforcementEnabled,omitempty"`
	// ServerResourceID - READ-ONLY; Azure Database Server resource Id
	ServerResourceID *string `json:"serverResourceId,omitempty"`
}

// MarshalJSON is the custom marshaler for DatabaseProfile.
func (dp DatabaseProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if dp.Type != nil {
		objectMap["type"] = dp.Type
	}
	if dp.ServerName != nil {
		objectMap["serverName"] = dp.ServerName
	}
	if dp.Version != nil {
		objectMap["version"] = dp.Version
	}
	if dp.Sku != nil {
		objectMap["sku"] = dp.Sku
	}
	if dp.Tier != "" {
		objectMap["tier"] = dp.Tier
	}
	if dp.HaEnabled != "" {
		objectMap["haEnabled"] = dp.HaEnabled
	}
	if dp.StorageSku != nil {
		objectMap["storageSku"] = dp.StorageSku
	}
	if dp.StorageInGB != nil {
		objectMap["storageInGB"] = dp.StorageInGB
	}
	if dp.StorageIops != nil {
		objectMap["storageIops"] = dp.StorageIops
	}
	if dp.BackupRetentionDays != nil {
		objectMap["backupRetentionDays"] = dp.BackupRetentionDays
	}
	if dp.SslEnforcementEnabled != "" {
		objectMap["sslEnforcementEnabled"] = dp.SslEnforcementEnabled
	}
	return json.Marshal(objectMap)
}

// DatabaseVMDetails the Database VM Details.
type DatabaseVMDetails struct {
	// VirtualMachineID - READ-ONLY
	VirtualMachineID *string `json:"virtualMachineId,omitempty"`
	// Status - READ-ONLY; Possible values include: 'Starting', 'Running', 'Stopping', 'Offline', 'PartiallyRunning', 'Unavailable'
	Status SAPVirtualInstanceStatus `json:"status,omitempty"`
}

// MarshalJSON is the custom marshaler for DatabaseVMDetails.
func (dvd DatabaseVMDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// DB2ProviderInstanceProperties gets or sets the DB2 provider properties.
type DB2ProviderInstanceProperties struct {
	// Hostname - Gets or sets the target virtual machine name.
	Hostname *string `json:"hostname,omitempty"`
	// DbName - Gets or sets the db2 database name.
	DbName *string `json:"dbName,omitempty"`
	// DbPort - Gets or sets the db2 database sql port.
	DbPort *string `json:"dbPort,omitempty"`
	// DbUsername - Gets or sets the db2 database user name.
	DbUsername *string `json:"dbUsername,omitempty"`
	// DbPassword - Gets or sets the db2 database password.
	DbPassword *string `json:"dbPassword,omitempty"`
	// DbPasswordURI - Gets or sets the key vault URI to secret with the database password.
	DbPasswordURI *string `json:"dbPasswordUri,omitempty"`
	// SapSid - Gets or sets the SAP System Identifier
	SapSid *string `json:"sapSid,omitempty"`
	// ProviderType - Possible values include: 'ProviderTypeProviderSpecificProperties', 'ProviderTypeSapHana', 'ProviderTypeSapNetWeaver', 'ProviderTypePrometheusOS', 'ProviderTypeDb2', 'ProviderTypePrometheusHaCluster', 'ProviderTypeMsSQLServer'
	ProviderType ProviderType `json:"providerType,omitempty"`
}

// MarshalJSON is the custom marshaler for DB2ProviderInstanceProperties.
func (dpip DB2ProviderInstanceProperties) MarshalJSON() ([]byte, error) {
	dpip.ProviderType = ProviderTypeDb2
	objectMap := make(map[string]interface{})
	if dpip.Hostname != nil {
		objectMap["hostname"] = dpip.Hostname
	}
	if dpip.DbName != nil {
		objectMap["dbName"] = dpip.DbName
	}
	if dpip.DbPort != nil {
		objectMap["dbPort"] = dpip.DbPort
	}
	if dpip.DbUsername != nil {
		objectMap["dbUsername"] = dpip.DbUsername
	}
	if dpip.DbPassword != nil {
		objectMap["dbPassword"] = dpip.DbPassword
	}
	if dpip.DbPasswordURI != nil {
		objectMap["dbPasswordUri"] = dpip.DbPasswordURI
	}
	if dpip.SapSid != nil {
		objectMap["sapSid"] = dpip.SapSid
	}
	if dpip.ProviderType != "" {
		objectMap["providerType"] = dpip.ProviderType
	}
	return json.Marshal(objectMap)
}

// AsHanaDbProviderInstanceProperties is the BasicProviderSpecificProperties implementation for DB2ProviderInstanceProperties.
func (dpip DB2ProviderInstanceProperties) AsHanaDbProviderInstanceProperties() (*HanaDbProviderInstanceProperties, bool) {
	return nil, false
}

// AsSapNetWeaverProviderInstanceProperties is the BasicProviderSpecificProperties implementation for DB2ProviderInstanceProperties.
func (dpip DB2ProviderInstanceProperties) AsSapNetWeaverProviderInstanceProperties() (*SapNetWeaverProviderInstanceProperties, bool) {
	return nil, false
}

// AsPrometheusOSProviderInstanceProperties is the BasicProviderSpecificProperties implementation for DB2ProviderInstanceProperties.
func (dpip DB2ProviderInstanceProperties) AsPrometheusOSProviderInstanceProperties() (*PrometheusOSProviderInstanceProperties, bool) {
	return nil, false
}

// AsDB2ProviderInstanceProperties is the BasicProviderSpecificProperties implementation for DB2ProviderInstanceProperties.
func (dpip DB2ProviderInstanceProperties) AsDB2ProviderInstanceProperties() (*DB2ProviderInstanceProperties, bool) {
	return &dpip, true
}

// AsPrometheusHaClusterProviderInstanceProperties is the BasicProviderSpecificProperties implementation for DB2ProviderInstanceProperties.
func (dpip DB2ProviderInstanceProperties) AsPrometheusHaClusterProviderInstanceProperties() (*PrometheusHaClusterProviderInstanceProperties, bool) {
	return nil, false
}

// AsMsSQLServerProviderInstanceProperties is the BasicProviderSpecificProperties implementation for DB2ProviderInstanceProperties.
func (dpip DB2ProviderInstanceProperties) AsMsSQLServerProviderInstanceProperties() (*MsSQLServerProviderInstanceProperties, bool) {
	return nil, false
}

// AsProviderSpecificProperties is the BasicProviderSpecificProperties implementation for DB2ProviderInstanceProperties.
func (dpip DB2ProviderInstanceProperties) AsProviderSpecificProperties() (*ProviderSpecificProperties, bool) {
	return nil, false
}

// AsBasicProviderSpecificProperties is the BasicProviderSpecificProperties implementation for DB2ProviderInstanceProperties.
func (dpip DB2ProviderInstanceProperties) AsBasicProviderSpecificProperties() (BasicProviderSpecificProperties, bool) {
	return &dpip, true
}

// DeployerVMPackages defines the url and storage account ID where deployer VM packages are uploaded
type DeployerVMPackages struct {
	// URL - The URL to the deployer VM packages file.
	URL *string `json:"url,omitempty"`
	// StorageAccountID - The deployer VM packages storage account id
	StorageAccountID *string `json:"storageAccountId,omitempty"`
}

// DeploymentConfiguration deployment Configuration.
type DeploymentConfiguration struct {
	// AppLocation - The geo-location where the SAP system is to be created.
	AppLocation *string `json:"appLocation,omitempty"`
	// InfrastructureConfiguration - The infrastructure configuration.
	InfrastructureConfiguration BasicInfrastructureConfiguration `json:"infrastructureConfiguration,omitempty"`
	// SoftwareConfiguration - The software configuration.
	SoftwareConfiguration BasicSoftwareConfiguration `json:"softwareConfiguration,omitempty"`
	// ConfigurationType - Possible values include: 'ConfigurationTypeSAPConfiguration', 'ConfigurationTypeDiscovery', 'ConfigurationTypeDeployment', 'ConfigurationTypeDeploymentWithOSConfig'
	ConfigurationType ConfigurationType `json:"configurationType,omitempty"`
}

// MarshalJSON is the custom marshaler for DeploymentConfiguration.
func (dc DeploymentConfiguration) MarshalJSON() ([]byte, error) {
	dc.ConfigurationType = ConfigurationTypeDeployment
	objectMap := make(map[string]interface{})
	if dc.AppLocation != nil {
		objectMap["appLocation"] = dc.AppLocation
	}
	objectMap["infrastructureConfiguration"] = dc.InfrastructureConfiguration
	objectMap["softwareConfiguration"] = dc.SoftwareConfiguration
	if dc.ConfigurationType != "" {
		objectMap["configurationType"] = dc.ConfigurationType
	}
	return json.Marshal(objectMap)
}

// AsDiscoveryConfiguration is the BasicSAPConfiguration implementation for DeploymentConfiguration.
func (dc DeploymentConfiguration) AsDiscoveryConfiguration() (*DiscoveryConfiguration, bool) {
	return nil, false
}

// AsDeploymentConfiguration is the BasicSAPConfiguration implementation for DeploymentConfiguration.
func (dc DeploymentConfiguration) AsDeploymentConfiguration() (*DeploymentConfiguration, bool) {
	return &dc, true
}

// AsDeploymentWithOSConfiguration is the BasicSAPConfiguration implementation for DeploymentConfiguration.
func (dc DeploymentConfiguration) AsDeploymentWithOSConfiguration() (*DeploymentWithOSConfiguration, bool) {
	return nil, false
}

// AsSAPConfiguration is the BasicSAPConfiguration implementation for DeploymentConfiguration.
func (dc DeploymentConfiguration) AsSAPConfiguration() (*SAPConfiguration, bool) {
	return nil, false
}

// AsBasicSAPConfiguration is the BasicSAPConfiguration implementation for DeploymentConfiguration.
func (dc DeploymentConfiguration) AsBasicSAPConfiguration() (BasicSAPConfiguration, bool) {
	return &dc, true
}

// UnmarshalJSON is the custom unmarshaler for DeploymentConfiguration struct.
func (dc *DeploymentConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "appLocation":
			if v != nil {
				var appLocation string
				err = json.Unmarshal(*v, &appLocation)
				if err != nil {
					return err
				}
				dc.AppLocation = &appLocation
			}
		case "infrastructureConfiguration":
			if v != nil {
				infrastructureConfiguration, err := unmarshalBasicInfrastructureConfiguration(*v)
				if err != nil {
					return err
				}
				dc.InfrastructureConfiguration = infrastructureConfiguration
			}
		case "softwareConfiguration":
			if v != nil {
				softwareConfiguration, err := unmarshalBasicSoftwareConfiguration(*v)
				if err != nil {
					return err
				}
				dc.SoftwareConfiguration = softwareConfiguration
			}
		case "configurationType":
			if v != nil {
				var configurationType ConfigurationType
				err = json.Unmarshal(*v, &configurationType)
				if err != nil {
					return err
				}
				dc.ConfigurationType = configurationType
			}
		}
	}

	return nil
}

// DeploymentWithOSConfiguration deployment along with OS Configuration.
type DeploymentWithOSConfiguration struct {
	// AppLocation - The geo-location where the SAP system is to be created.
	AppLocation *string `json:"appLocation,omitempty"`
	// InfrastructureConfiguration - The infrastructure configuration.
	InfrastructureConfiguration BasicInfrastructureConfiguration `json:"infrastructureConfiguration,omitempty"`
	// SoftwareConfiguration - The software configuration.
	SoftwareConfiguration BasicSoftwareConfiguration `json:"softwareConfiguration,omitempty"`
	// OsSapConfiguration - The OS and SAP configuration.
	OsSapConfiguration *OsSapConfiguration `json:"osSapConfiguration,omitempty"`
	// ConfigurationType - Possible values include: 'ConfigurationTypeSAPConfiguration', 'ConfigurationTypeDiscovery', 'ConfigurationTypeDeployment', 'ConfigurationTypeDeploymentWithOSConfig'
	ConfigurationType ConfigurationType `json:"configurationType,omitempty"`
}

// MarshalJSON is the custom marshaler for DeploymentWithOSConfiguration.
func (dwoc DeploymentWithOSConfiguration) MarshalJSON() ([]byte, error) {
	dwoc.ConfigurationType = ConfigurationTypeDeploymentWithOSConfig
	objectMap := make(map[string]interface{})
	if dwoc.AppLocation != nil {
		objectMap["appLocation"] = dwoc.AppLocation
	}
	objectMap["infrastructureConfiguration"] = dwoc.InfrastructureConfiguration
	objectMap["softwareConfiguration"] = dwoc.SoftwareConfiguration
	if dwoc.OsSapConfiguration != nil {
		objectMap["osSapConfiguration"] = dwoc.OsSapConfiguration
	}
	if dwoc.ConfigurationType != "" {
		objectMap["configurationType"] = dwoc.ConfigurationType
	}
	return json.Marshal(objectMap)
}

// AsDiscoveryConfiguration is the BasicSAPConfiguration implementation for DeploymentWithOSConfiguration.
func (dwoc DeploymentWithOSConfiguration) AsDiscoveryConfiguration() (*DiscoveryConfiguration, bool) {
	return nil, false
}

// AsDeploymentConfiguration is the BasicSAPConfiguration implementation for DeploymentWithOSConfiguration.
func (dwoc DeploymentWithOSConfiguration) AsDeploymentConfiguration() (*DeploymentConfiguration, bool) {
	return nil, false
}

// AsDeploymentWithOSConfiguration is the BasicSAPConfiguration implementation for DeploymentWithOSConfiguration.
func (dwoc DeploymentWithOSConfiguration) AsDeploymentWithOSConfiguration() (*DeploymentWithOSConfiguration, bool) {
	return &dwoc, true
}

// AsSAPConfiguration is the BasicSAPConfiguration implementation for DeploymentWithOSConfiguration.
func (dwoc DeploymentWithOSConfiguration) AsSAPConfiguration() (*SAPConfiguration, bool) {
	return nil, false
}

// AsBasicSAPConfiguration is the BasicSAPConfiguration implementation for DeploymentWithOSConfiguration.
func (dwoc DeploymentWithOSConfiguration) AsBasicSAPConfiguration() (BasicSAPConfiguration, bool) {
	return &dwoc, true
}

// UnmarshalJSON is the custom unmarshaler for DeploymentWithOSConfiguration struct.
func (dwoc *DeploymentWithOSConfiguration) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "appLocation":
			if v != nil {
				var appLocation string
				err = json.Unmarshal(*v, &appLocation)
				if err != nil {
					return err
				}
				dwoc.AppLocation = &appLocation
			}
		case "infrastructureConfiguration":
			if v != nil {
				infrastructureConfiguration, err := unmarshalBasicInfrastructureConfiguration(*v)
				if err != nil {
					return err
				}
				dwoc.InfrastructureConfiguration = infrastructureConfiguration
			}
		case "softwareConfiguration":
			if v != nil {
				softwareConfiguration, err := unmarshalBasicSoftwareConfiguration(*v)
				if err != nil {
					return err
				}
				dwoc.SoftwareConfiguration = softwareConfiguration
			}
		case "osSapConfiguration":
			if v != nil {
				var osSapConfiguration OsSapConfiguration
				err = json.Unmarshal(*v, &osSapConfiguration)
				if err != nil {
					return err
				}
				dwoc.OsSapConfiguration = &osSapConfiguration
			}
		case "configurationType":
			if v != nil {
				var configurationType ConfigurationType
				err = json.Unmarshal(*v, &configurationType)
				if err != nil {
					return err
				}
				dwoc.ConfigurationType = configurationType
			}
		}
	}

	return nil
}

// DiscoveryConfiguration discovery Details.
type DiscoveryConfiguration struct {
	// CentralServerVMID - The virtual machine ID of the Central Server.
	CentralServerVMID *string `json:"centralServerVmId,omitempty"`
	// AppLocation - READ-ONLY; The geo-location where the SAP system exists.
	AppLocation *string `json:"appLocation,omitempty"`
	// ConfigurationType - Possible values include: 'ConfigurationTypeSAPConfiguration', 'ConfigurationTypeDiscovery', 'ConfigurationTypeDeployment', 'ConfigurationTypeDeploymentWithOSConfig'
	ConfigurationType ConfigurationType `json:"configurationType,omitempty"`
}

// MarshalJSON is the custom marshaler for DiscoveryConfiguration.
func (dc DiscoveryConfiguration) MarshalJSON() ([]byte, error) {
	dc.ConfigurationType = ConfigurationTypeDiscovery
	objectMap := make(map[string]interface{})
	if dc.CentralServerVMID != nil {
		objectMap["centralServerVmId"] = dc.CentralServerVMID
	}
	if dc.ConfigurationType != "" {
		objectMap["configurationType"] = dc.ConfigurationType
	}
	return json.Marshal(objectMap)
}

// AsDiscoveryConfiguration is the BasicSAPConfiguration implementation for DiscoveryConfiguration.
func (dc DiscoveryConfiguration) AsDiscoveryConfiguration() (*DiscoveryConfiguration, bool) {
	return &dc, true
}

// AsDeploymentConfiguration is the BasicSAPConfiguration implementation for DiscoveryConfiguration.
func (dc DiscoveryConfiguration) AsDeploymentConfiguration() (*DeploymentConfiguration, bool) {
	return nil, false
}

// AsDeploymentWithOSConfiguration is the BasicSAPConfiguration implementation for DiscoveryConfiguration.
func (dc DiscoveryConfiguration) AsDeploymentWithOSConfiguration() (*DeploymentWithOSConfiguration, bool) {
	return nil, false
}

// AsSAPConfiguration is the BasicSAPConfiguration implementation for DiscoveryConfiguration.
func (dc DiscoveryConfiguration) AsSAPConfiguration() (*SAPConfiguration, bool) {
	return nil, false
}

// AsBasicSAPConfiguration is the BasicSAPConfiguration implementation for DiscoveryConfiguration.
func (dc DiscoveryConfiguration) AsBasicSAPConfiguration() (BasicSAPConfiguration, bool) {
	return &dc, true
}

// DiskInfo disk resource creation details
type DiskInfo struct {
	// StorageType - Storage type. Possible values include: 'PremiumLRS', 'StandardLRS', 'StandardSSDLRS'
	StorageType DiskStorageType `json:"storageType,omitempty"`
	// SizeInGB - Disk size in GB
	SizeInGB *int64 `json:"sizeInGB,omitempty"`
}

// EnqueueReplicationServerProperties defines the SAP ERS Server properties.
type EnqueueReplicationServerProperties struct {
	// ErsVersion - READ-ONLY; Possible values include: 'EnqueueReplicator1', 'EnqueueReplicator2'
	ErsVersion EnqueueReplicationServerType `json:"ersVersion,omitempty"`
	// InstanceNo - READ-ONLY; The ERS server instance id.
	InstanceNo *string `json:"instanceNo,omitempty"`
	// Hostname - READ-ONLY; The ERS server SAP host name.
	Hostname *string `json:"hostname,omitempty"`
	// KernelVersion - READ-ONLY; The ERS server SAP kernel version.
	KernelVersion *string `json:"kernelVersion,omitempty"`
	// KernelPatch - READ-ONLY; The ERS server SAP kernel patch.
	KernelPatch *string `json:"kernelPatch,omitempty"`
	// IPAddress - READ-ONLY; The ERS server SAP IP Address.
	IPAddress *string `json:"ipAddress,omitempty"`
	// Health - READ-ONLY; Possible values include: 'SAPHealthStateUnknown', 'SAPHealthStateHealthy', 'SAPHealthStateUnhealthy', 'SAPHealthStateDegraded'
	Health SAPHealthState `json:"health,omitempty"`
}

// MarshalJSON is the custom marshaler for EnqueueReplicationServerProperties.
func (ersp EnqueueReplicationServerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// EnqueueServerProperties defines the SAP enqueue server properties.
type EnqueueServerProperties struct {
	// Hostname - READ-ONLY; The enqueue server SAP host name.
	Hostname *string `json:"hostname,omitempty"`
	// IPAddress - READ-ONLY; The enqueue server SAP IP Address.
	IPAddress *string `json:"ipAddress,omitempty"`
	// Port - READ-ONLY; The enqueue server Port.
	Port *int64 `json:"port,omitempty"`
	// Health - READ-ONLY; Possible values include: 'SAPHealthStateUnknown', 'SAPHealthStateHealthy', 'SAPHealthStateUnhealthy', 'SAPHealthStateDegraded'
	Health SAPHealthState `json:"health,omitempty"`
}

// MarshalJSON is the custom marshaler for EnqueueServerProperties.
func (esp EnqueueServerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Error standard error object.
type Error struct {
	// Code - READ-ONLY; Server-defined set of error codes.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Human-readable representation of the error.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; Target of the error.
	Target *string `json:"target,omitempty"`
	// Details - READ-ONLY; Array of details about specific errors that led to this reported error.
	Details *[]Error `json:"details,omitempty"`
	// InnerError - READ-ONLY; Object containing more specific information than  the current object about the error.
	InnerError *ErrorInnerError `json:"innerError,omitempty"`
}

// MarshalJSON is the custom marshaler for Error.
func (e Error) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorAdditionalInfo the resource management error additional info.
type ErrorAdditionalInfo struct {
	// Type - READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty"`
	// Info - READ-ONLY; The additional info.
	Info interface{} `json:"info,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorAdditionalInfo.
func (eai ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorDefinition error definition.
type ErrorDefinition struct {
	// Code - READ-ONLY; Service specific error code which serves as the substatus for the HTTP error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Description of the error.
	Message *string `json:"message,omitempty"`
	// Details - READ-ONLY; Internal error details.
	Details *[]ErrorDefinition `json:"details,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorDefinition.
func (ed ErrorDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorDetail the error detail.
type ErrorDetail struct {
	// Code - READ-ONLY; The error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; The error message.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; The error target.
	Target *string `json:"target,omitempty"`
	// Details - READ-ONLY; The error details.
	Details *[]ErrorDetail `json:"details,omitempty"`
	// AdditionalInfo - READ-ONLY; The error additional info.
	AdditionalInfo *[]ErrorAdditionalInfo `json:"additionalInfo,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorDetail.
func (ed ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorInnerError object containing more specific information than  the current object about the error.
type ErrorInnerError struct {
	InnerError *Error `json:"innerError,omitempty"`
}

// ErrorResponse common error response for all Azure Resource Manager APIs to return error details for
// failed operations. (This also follows the OData error response format.).
type ErrorResponse struct {
	// Error - The error object.
	Error *ErrorDetail `json:"error,omitempty"`
}

// FileshareProfile file share profile
type FileshareProfile struct {
	// ShareType - Share type. Possible values include: 'NfsOnController', 'AzureFiles'
	ShareType FileShareType `json:"shareType,omitempty"`
	// StorageType - File share backing storage type. Possible values include: 'FileShareStorageTypeStandardLRS', 'FileShareStorageTypeStandardGRS', 'FileShareStorageTypeStandardZRS', 'FileShareStorageTypePremiumLRS'
	StorageType FileShareStorageType `json:"storageType,omitempty"`
	// ShareSizeInGB - File share size in GB
	ShareSizeInGB *int64 `json:"shareSizeInGB,omitempty"`
	// StorageResourceID - READ-ONLY; File share storage resource id
	StorageResourceID *string `json:"storageResourceId,omitempty"`
	// ShareName - READ-ONLY; File share name
	ShareName *string `json:"shareName,omitempty"`
}

// MarshalJSON is the custom marshaler for FileshareProfile.
func (fp FileshareProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if fp.ShareType != "" {
		objectMap["shareType"] = fp.ShareType
	}
	if fp.StorageType != "" {
		objectMap["storageType"] = fp.StorageType
	}
	if fp.ShareSizeInGB != nil {
		objectMap["shareSizeInGB"] = fp.ShareSizeInGB
	}
	return json.Marshal(objectMap)
}

// GatewayServerProperties defines the SAP Gateway Server properties.
type GatewayServerProperties struct {
	// Port - READ-ONLY; The gateway Port.
	Port *int64 `json:"port,omitempty"`
	// Health - READ-ONLY; Possible values include: 'SAPHealthStateUnknown', 'SAPHealthStateHealthy', 'SAPHealthStateUnhealthy', 'SAPHealthStateDegraded'
	Health SAPHealthState `json:"health,omitempty"`
}

// MarshalJSON is the custom marshaler for GatewayServerProperties.
func (gsp GatewayServerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// HanaDbProviderInstanceProperties gets or sets the provider properties.
type HanaDbProviderInstanceProperties struct {
	// Hostname - Gets or sets the target virtual machine size.
	Hostname *string `json:"hostname,omitempty"`
	// DbName - Gets or sets the hana database name.
	DbName *string `json:"dbName,omitempty"`
	// SQLPort - Gets or sets the database sql port.
	SQLPort *string `json:"sqlPort,omitempty"`
	// InstanceNumber - Gets or sets the database instance number.
	InstanceNumber *string `json:"instanceNumber,omitempty"`
	// DbUsername - Gets or sets the database user name.
	DbUsername *string `json:"dbUsername,omitempty"`
	// DbPassword - Gets or sets the database password.
	DbPassword *string `json:"dbPassword,omitempty"`
	// DbPasswordURI - Gets or sets the key vault URI to secret with the database password.
	DbPasswordURI *string `json:"dbPasswordUri,omitempty"`
	// DbSslCertificateURI - Gets or sets the blob URI to SSL certificate for the DB.
	DbSslCertificateURI *string `json:"dbSslCertificateUri,omitempty"`
	// SslHostNameInCertificate - Gets or sets the hostname(s) in the SSL certificate.
	SslHostNameInCertificate *string `json:"sslHostNameInCertificate,omitempty"`
	// ProviderType - Possible values include: 'ProviderTypeProviderSpecificProperties', 'ProviderTypeSapHana', 'ProviderTypeSapNetWeaver', 'ProviderTypePrometheusOS', 'ProviderTypeDb2', 'ProviderTypePrometheusHaCluster', 'ProviderTypeMsSQLServer'
	ProviderType ProviderType `json:"providerType,omitempty"`
}

// MarshalJSON is the custom marshaler for HanaDbProviderInstanceProperties.
func (hdpip HanaDbProviderInstanceProperties) MarshalJSON() ([]byte, error) {
	hdpip.ProviderType = ProviderTypeSapHana
	objectMap := make(map[string]interface{})
	if hdpip.Hostname != nil {
		objectMap["hostname"] = hdpip.Hostname
	}
	if hdpip.DbName != nil {
		objectMap["dbName"] = hdpip.DbName
	}
	if hdpip.SQLPort != nil {
		objectMap["sqlPort"] = hdpip.SQLPort
	}
	if hdpip.InstanceNumber != nil {
		objectMap["instanceNumber"] = hdpip.InstanceNumber
	}
	if hdpip.DbUsername != nil {
		objectMap["dbUsername"] = hdpip.DbUsername
	}
	if hdpip.DbPassword != nil {
		objectMap["dbPassword"] = hdpip.DbPassword
	}
	if hdpip.DbPasswordURI != nil {
		objectMap["dbPasswordUri"] = hdpip.DbPasswordURI
	}
	if hdpip.DbSslCertificateURI != nil {
		objectMap["dbSslCertificateUri"] = hdpip.DbSslCertificateURI
	}
	if hdpip.SslHostNameInCertificate != nil {
		objectMap["sslHostNameInCertificate"] = hdpip.SslHostNameInCertificate
	}
	if hdpip.ProviderType != "" {
		objectMap["providerType"] = hdpip.ProviderType
	}
	return json.Marshal(objectMap)
}

// AsHanaDbProviderInstanceProperties is the BasicProviderSpecificProperties implementation for HanaDbProviderInstanceProperties.
func (hdpip HanaDbProviderInstanceProperties) AsHanaDbProviderInstanceProperties() (*HanaDbProviderInstanceProperties, bool) {
	return &hdpip, true
}

// AsSapNetWeaverProviderInstanceProperties is the BasicProviderSpecificProperties implementation for HanaDbProviderInstanceProperties.
func (hdpip HanaDbProviderInstanceProperties) AsSapNetWeaverProviderInstanceProperties() (*SapNetWeaverProviderInstanceProperties, bool) {
	return nil, false
}

// AsPrometheusOSProviderInstanceProperties is the BasicProviderSpecificProperties implementation for HanaDbProviderInstanceProperties.
func (hdpip HanaDbProviderInstanceProperties) AsPrometheusOSProviderInstanceProperties() (*PrometheusOSProviderInstanceProperties, bool) {
	return nil, false
}

// AsDB2ProviderInstanceProperties is the BasicProviderSpecificProperties implementation for HanaDbProviderInstanceProperties.
func (hdpip HanaDbProviderInstanceProperties) AsDB2ProviderInstanceProperties() (*DB2ProviderInstanceProperties, bool) {
	return nil, false
}

// AsPrometheusHaClusterProviderInstanceProperties is the BasicProviderSpecificProperties implementation for HanaDbProviderInstanceProperties.
func (hdpip HanaDbProviderInstanceProperties) AsPrometheusHaClusterProviderInstanceProperties() (*PrometheusHaClusterProviderInstanceProperties, bool) {
	return nil, false
}

// AsMsSQLServerProviderInstanceProperties is the BasicProviderSpecificProperties implementation for HanaDbProviderInstanceProperties.
func (hdpip HanaDbProviderInstanceProperties) AsMsSQLServerProviderInstanceProperties() (*MsSQLServerProviderInstanceProperties, bool) {
	return nil, false
}

// AsProviderSpecificProperties is the BasicProviderSpecificProperties implementation for HanaDbProviderInstanceProperties.
func (hdpip HanaDbProviderInstanceProperties) AsProviderSpecificProperties() (*ProviderSpecificProperties, bool) {
	return nil, false
}

// AsBasicProviderSpecificProperties is the BasicProviderSpecificProperties implementation for HanaDbProviderInstanceProperties.
func (hdpip HanaDbProviderInstanceProperties) AsBasicProviderSpecificProperties() (BasicProviderSpecificProperties, bool) {
	return &hdpip, true
}

// HighAvailabilityConfiguration gets or sets the high availability configuration.
type HighAvailabilityConfiguration struct {
	// HighAvailabilityType - The high availability type. Possible values include: 'AvailabilitySet', 'AvailabilityZone'
	HighAvailabilityType SAPHighAvailabilityType `json:"highAvailabilityType,omitempty"`
}

// HighAvailabilitySoftwareConfiguration gets or sets the HA software configuration.
type HighAvailabilitySoftwareConfiguration struct {
	// FencingClientID - The fencing client id.
	FencingClientID *string `json:"fencingClientId,omitempty"`
	// FencingClientPassword - The fencing client id secret/password. The secret should never expire. This will be used pacemaker to start/stop the cluster VMs.
	FencingClientPassword *string `json:"fencingClientPassword,omitempty"`
}

// Identity identity for the resource.
type Identity struct {
	// PrincipalID - READ-ONLY; The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty"`
	// Type - The identity type. Possible values include: 'SystemAssigned'
	Type ResourceIdentityType `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Identity.
func (i Identity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.Type != "" {
		objectMap["type"] = i.Type
	}
	return json.Marshal(objectMap)
}

// ImageReference specifies information about the image to use. You can specify information about platform
// images, marketplace images, or virtual machine images. This element is required when you want to use a
// platform image, marketplace image, or virtual machine image, but is not used in other creation
// operations. NOTE: Image reference publisher and offer can only be set when you create the scale set.
type ImageReference struct {
	// Publisher - The image publisher.
	Publisher *string `json:"publisher,omitempty"`
	// Offer - Specifies the offer of the platform image or marketplace image used to create the virtual machine.
	Offer *string `json:"offer,omitempty"`
	// Sku - The image SKU.
	Sku *string `json:"sku,omitempty"`
	// Version - Specifies the version of the platform image or marketplace image used to create the virtual machine. The allowed formats are Major.Minor.Build or 'latest'. Major, Minor, and Build are decimal numbers. Specify 'latest' to use the latest version of an image available at deploy time. Even if you use 'latest', the VM image will not automatically update after deploy time even if a new version becomes available.
	Version *string `json:"version,omitempty"`
	// ExactVersion - READ-ONLY; Specifies in decimal numbers, the version of platform image or marketplace image used to create the virtual machine. This readonly field differs from 'version', only if the value specified in 'version' field is 'latest'.
	ExactVersion *string `json:"exactVersion,omitempty"`
	// SharedGalleryImageID - Specified the shared gallery image unique id for vm deployment. This can be fetched from shared gallery image GET call.
	SharedGalleryImageID *string `json:"sharedGalleryImageId,omitempty"`
}

// MarshalJSON is the custom marshaler for ImageReference.
func (ir ImageReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if ir.Publisher != nil {
		objectMap["publisher"] = ir.Publisher
	}
	if ir.Offer != nil {
		objectMap["offer"] = ir.Offer
	}
	if ir.Sku != nil {
		objectMap["sku"] = ir.Sku
	}
	if ir.Version != nil {
		objectMap["version"] = ir.Version
	}
	if ir.SharedGalleryImageID != nil {
		objectMap["sharedGalleryImageId"] = ir.SharedGalleryImageID
	}
	return json.Marshal(objectMap)
}

// BasicInfrastructureConfiguration deploy SAP Infrastructure Details.
type BasicInfrastructureConfiguration interface {
	AsSingleServerConfiguration() (*SingleServerConfiguration, bool)
	AsThreeTierConfiguration() (*ThreeTierConfiguration, bool)
	AsInfrastructureConfiguration() (*InfrastructureConfiguration, bool)
}

// InfrastructureConfiguration deploy SAP Infrastructure Details.
type InfrastructureConfiguration struct {
	// AppResourceGroup - The application resource group where SAP system resources will be deployed.
	AppResourceGroup *string `json:"appResourceGroup,omitempty"`
	// DeploymentType - Possible values include: 'DeploymentTypeBasicInfrastructureConfigurationDeploymentTypeInfrastructureConfiguration', 'DeploymentTypeBasicInfrastructureConfigurationDeploymentTypeSingleServer', 'DeploymentTypeBasicInfrastructureConfigurationDeploymentTypeThreeTier'
	DeploymentType DeploymentTypeBasicInfrastructureConfiguration `json:"deploymentType,omitempty"`
}

func unmarshalBasicInfrastructureConfiguration(body []byte) (BasicInfrastructureConfiguration, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["deploymentType"] {
	case string(DeploymentTypeBasicInfrastructureConfigurationDeploymentTypeSingleServer):
		var ssc SingleServerConfiguration
		err := json.Unmarshal(body, &ssc)
		return ssc, err
	case string(DeploymentTypeBasicInfrastructureConfigurationDeploymentTypeThreeTier):
		var ttc ThreeTierConfiguration
		err := json.Unmarshal(body, &ttc)
		return ttc, err
	default:
		var ic InfrastructureConfiguration
		err := json.Unmarshal(body, &ic)
		return ic, err
	}
}
func unmarshalBasicInfrastructureConfigurationArray(body []byte) ([]BasicInfrastructureConfiguration, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	icArray := make([]BasicInfrastructureConfiguration, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ic, err := unmarshalBasicInfrastructureConfiguration(*rawMessage)
		if err != nil {
			return nil, err
		}
		icArray[index] = ic
	}
	return icArray, nil
}

// MarshalJSON is the custom marshaler for InfrastructureConfiguration.
func (ic InfrastructureConfiguration) MarshalJSON() ([]byte, error) {
	ic.DeploymentType = DeploymentTypeBasicInfrastructureConfigurationDeploymentTypeInfrastructureConfiguration
	objectMap := make(map[string]interface{})
	if ic.AppResourceGroup != nil {
		objectMap["appResourceGroup"] = ic.AppResourceGroup
	}
	if ic.DeploymentType != "" {
		objectMap["deploymentType"] = ic.DeploymentType
	}
	return json.Marshal(objectMap)
}

// AsSingleServerConfiguration is the BasicInfrastructureConfiguration implementation for InfrastructureConfiguration.
func (ic InfrastructureConfiguration) AsSingleServerConfiguration() (*SingleServerConfiguration, bool) {
	return nil, false
}

// AsThreeTierConfiguration is the BasicInfrastructureConfiguration implementation for InfrastructureConfiguration.
func (ic InfrastructureConfiguration) AsThreeTierConfiguration() (*ThreeTierConfiguration, bool) {
	return nil, false
}

// AsInfrastructureConfiguration is the BasicInfrastructureConfiguration implementation for InfrastructureConfiguration.
func (ic InfrastructureConfiguration) AsInfrastructureConfiguration() (*InfrastructureConfiguration, bool) {
	return &ic, true
}

// AsBasicInfrastructureConfiguration is the BasicInfrastructureConfiguration implementation for InfrastructureConfiguration.
func (ic InfrastructureConfiguration) AsBasicInfrastructureConfiguration() (BasicInfrastructureConfiguration, bool) {
	return &ic, true
}

// LinuxConfiguration specifies the Linux operating system settings on the virtual machine. <br><br>For a
// list of supported Linux distributions, see [Linux on Azure-Endorsed
// Distributions](https://docs.microsoft.com/azure/virtual-machines/linux/endorsed-distros).
type LinuxConfiguration struct {
	// DisablePasswordAuthentication - Specifies whether password authentication should be disabled.
	DisablePasswordAuthentication *bool `json:"disablePasswordAuthentication,omitempty"`
	// SSH - Specifies the ssh key configuration for a Linux OS. (This property is deprecated, please use 'sshKeyPair' instead)
	SSH *SSHConfiguration `json:"ssh,omitempty"`
	// SSHKeyPair - The SSH Key-pair used to authenticate with the VM's.
	SSHKeyPair *SSHKeyPair `json:"sshKeyPair,omitempty"`
	// OsType - Possible values include: 'OsTypeOSConfiguration', 'OsTypeWindows', 'OsTypeLinux'
	OsType OsType `json:"osType,omitempty"`
}

// MarshalJSON is the custom marshaler for LinuxConfiguration.
func (lc LinuxConfiguration) MarshalJSON() ([]byte, error) {
	lc.OsType = OsTypeLinux
	objectMap := make(map[string]interface{})
	if lc.DisablePasswordAuthentication != nil {
		objectMap["disablePasswordAuthentication"] = lc.DisablePasswordAuthentication
	}
	if lc.SSH != nil {
		objectMap["ssh"] = lc.SSH
	}
	if lc.SSHKeyPair != nil {
		objectMap["sshKeyPair"] = lc.SSHKeyPair
	}
	if lc.OsType != "" {
		objectMap["osType"] = lc.OsType
	}
	return json.Marshal(objectMap)
}

// AsWindowsConfiguration is the BasicOSConfiguration implementation for LinuxConfiguration.
func (lc LinuxConfiguration) AsWindowsConfiguration() (*WindowsConfiguration, bool) {
	return nil, false
}

// AsLinuxConfiguration is the BasicOSConfiguration implementation for LinuxConfiguration.
func (lc LinuxConfiguration) AsLinuxConfiguration() (*LinuxConfiguration, bool) {
	return &lc, true
}

// AsOSConfiguration is the BasicOSConfiguration implementation for LinuxConfiguration.
func (lc LinuxConfiguration) AsOSConfiguration() (*OSConfiguration, bool) {
	return nil, false
}

// AsBasicOSConfiguration is the BasicOSConfiguration implementation for LinuxConfiguration.
func (lc LinuxConfiguration) AsBasicOSConfiguration() (BasicOSConfiguration, bool) {
	return &lc, true
}

// ManagedRGConfiguration managed resource group configuration
type ManagedRGConfiguration struct {
	// Name - Managed resource group name
	Name *string `json:"name,omitempty"`
}

// MessageServerProperties defines the SAP message server properties.
type MessageServerProperties struct {
	// MsPort - READ-ONLY; The message server port.
	MsPort *int64 `json:"msPort,omitempty"`
	// InternalMsPort - READ-ONLY; The message server internal MS port.
	InternalMsPort *int64 `json:"internalMsPort,omitempty"`
	// HTTPPort - READ-ONLY; The message server http port.
	HTTPPort *int64 `json:"httpPort,omitempty"`
	// HTTPSPort - READ-ONLY; The message server https port.
	HTTPSPort *int64 `json:"httpsPort,omitempty"`
	// Hostname - READ-ONLY; The message server SAP host name.
	Hostname *string `json:"hostname,omitempty"`
	// IPAddress - READ-ONLY; The message server IP Address.
	IPAddress *string `json:"ipAddress,omitempty"`
	// Health - READ-ONLY; Possible values include: 'SAPHealthStateUnknown', 'SAPHealthStateHealthy', 'SAPHealthStateUnhealthy', 'SAPHealthStateDegraded'
	Health SAPHealthState `json:"health,omitempty"`
}

// MarshalJSON is the custom marshaler for MessageServerProperties.
func (msp MessageServerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Monitor SAP monitor info on Azure (ARM properties and SAP monitor properties)
type Monitor struct {
	autorest.Response `json:"-"`
	Identity          *UserAssignedServiceIdentity `json:"identity,omitempty"`
	// MonitorProperties - SAP monitor properties
	*MonitorProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for Monitor.
func (mVar Monitor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mVar.Identity != nil {
		objectMap["identity"] = mVar.Identity
	}
	if mVar.MonitorProperties != nil {
		objectMap["properties"] = mVar.MonitorProperties
	}
	if mVar.Tags != nil {
		objectMap["tags"] = mVar.Tags
	}
	if mVar.Location != nil {
		objectMap["location"] = mVar.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Monitor struct.
func (mVar *Monitor) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "identity":
			if v != nil {
				var identity UserAssignedServiceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				mVar.Identity = &identity
			}
		case "properties":
			if v != nil {
				var monitorProperties MonitorProperties
				err = json.Unmarshal(*v, &monitorProperties)
				if err != nil {
					return err
				}
				mVar.MonitorProperties = &monitorProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				mVar.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				mVar.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				mVar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				mVar.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				mVar.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				mVar.SystemData = &systemData
			}
		}
	}

	return nil
}

// MonitorListResult the response from the List SAP monitors operation.
type MonitorListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of SAP monitors.
	Value *[]Monitor `json:"value,omitempty"`
	// NextLink - The URL to get the next set of SAP monitors.
	NextLink *string `json:"nextLink,omitempty"`
}

// MonitorListResultIterator provides access to a complete listing of Monitor values.
type MonitorListResultIterator struct {
	i    int
	page MonitorListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *MonitorListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/MonitorListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *MonitorListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter MonitorListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter MonitorListResultIterator) Response() MonitorListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter MonitorListResultIterator) Value() Monitor {
	if !iter.page.NotDone() {
		return Monitor{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the MonitorListResultIterator type.
func NewMonitorListResultIterator(page MonitorListResultPage) MonitorListResultIterator {
	return MonitorListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (mlr MonitorListResult) IsEmpty() bool {
	return mlr.Value == nil || len(*mlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (mlr MonitorListResult) hasNextLink() bool {
	return mlr.NextLink != nil && len(*mlr.NextLink) != 0
}

// monitorListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (mlr MonitorListResult) monitorListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !mlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(mlr.NextLink)))
}

// MonitorListResultPage contains a page of Monitor values.
type MonitorListResultPage struct {
	fn  func(context.Context, MonitorListResult) (MonitorListResult, error)
	mlr MonitorListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *MonitorListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/MonitorListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.mlr)
		if err != nil {
			return err
		}
		page.mlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *MonitorListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page MonitorListResultPage) NotDone() bool {
	return !page.mlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page MonitorListResultPage) Response() MonitorListResult {
	return page.mlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page MonitorListResultPage) Values() []Monitor {
	if page.mlr.IsEmpty() {
		return nil
	}
	return *page.mlr.Value
}

// Creates a new instance of the MonitorListResultPage type.
func NewMonitorListResultPage(cur MonitorListResult, getNextPage func(context.Context, MonitorListResult) (MonitorListResult, error)) MonitorListResultPage {
	return MonitorListResultPage{
		fn:  getNextPage,
		mlr: cur,
	}
}

// MonitorProperties describes the properties of a SAP monitor.
type MonitorProperties struct {
	// ProvisioningState - READ-ONLY; State of provisioning of the SAP monitor. Possible values include: 'WorkloadMonitorProvisioningStateAccepted', 'WorkloadMonitorProvisioningStateCreating', 'WorkloadMonitorProvisioningStateUpdating', 'WorkloadMonitorProvisioningStateFailed', 'WorkloadMonitorProvisioningStateSucceeded', 'WorkloadMonitorProvisioningStateDeleting', 'WorkloadMonitorProvisioningStateMigrating'
	ProvisioningState WorkloadMonitorProvisioningState `json:"provisioningState,omitempty"`
	// Errors - READ-ONLY; Defines the SAP monitor errors.
	Errors *MonitorPropertiesErrors `json:"errors,omitempty"`
	// AppLocation - The SAP monitor resources will be deployed in the SAP monitoring region. The subnet region should be same as the SAP monitoring region.
	AppLocation *string `json:"appLocation,omitempty"`
	// RoutingPreference - Sets the routing preference of the SAP monitor. By default only RFC1918 traffic is routed to the customer VNET. Possible values include: 'Default', 'RouteAll'
	RoutingPreference RoutingPreference `json:"routingPreference,omitempty"`
	// ManagedResourceGroupConfiguration - Managed resource group configuration
	ManagedResourceGroupConfiguration *ManagedRGConfiguration `json:"managedResourceGroupConfiguration,omitempty"`
	// LogAnalyticsWorkspaceArmID - The ARM ID of the Log Analytics Workspace that is used for SAP monitoring.
	LogAnalyticsWorkspaceArmID *string `json:"logAnalyticsWorkspaceArmId,omitempty"`
	// MonitorSubnet - The subnet which the SAP monitor will be deployed in
	MonitorSubnet *string `json:"monitorSubnet,omitempty"`
	// MsiArmID - READ-ONLY; The ARM ID of the MSI used for SAP monitoring.
	MsiArmID *string `json:"msiArmId,omitempty"`
}

// MarshalJSON is the custom marshaler for MonitorProperties.
func (mp MonitorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if mp.AppLocation != nil {
		objectMap["appLocation"] = mp.AppLocation
	}
	if mp.RoutingPreference != "" {
		objectMap["routingPreference"] = mp.RoutingPreference
	}
	if mp.ManagedResourceGroupConfiguration != nil {
		objectMap["managedResourceGroupConfiguration"] = mp.ManagedResourceGroupConfiguration
	}
	if mp.LogAnalyticsWorkspaceArmID != nil {
		objectMap["logAnalyticsWorkspaceArmId"] = mp.LogAnalyticsWorkspaceArmID
	}
	if mp.MonitorSubnet != nil {
		objectMap["monitorSubnet"] = mp.MonitorSubnet
	}
	return json.Marshal(objectMap)
}

// MonitorPropertiesErrors defines the SAP monitor errors.
type MonitorPropertiesErrors struct {
	// Code - READ-ONLY; Server-defined set of error codes.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Human-readable representation of the error.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; Target of the error.
	Target *string `json:"target,omitempty"`
	// Details - READ-ONLY; Array of details about specific errors that led to this reported error.
	Details *[]Error `json:"details,omitempty"`
	// InnerError - READ-ONLY; Object containing more specific information than  the current object about the error.
	InnerError *ErrorInnerError `json:"innerError,omitempty"`
}

// MarshalJSON is the custom marshaler for MonitorPropertiesErrors.
func (mp MonitorPropertiesErrors) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// MonitorsCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type MonitorsCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(MonitorsClient) (Monitor, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *MonitorsCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for MonitorsCreateFuture.Result.
func (future *MonitorsCreateFuture) result(client MonitorsClient) (mVar Monitor, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.MonitorsCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		mVar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.MonitorsCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if mVar.Response.Response, err = future.GetResult(sender); err == nil && mVar.Response.Response.StatusCode != http.StatusNoContent {
		mVar, err = client.CreateResponder(mVar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.MonitorsCreateFuture", "Result", mVar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// MonitorsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type MonitorsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(MonitorsClient) (OperationStatusResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *MonitorsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for MonitorsDeleteFuture.Result.
func (future *MonitorsDeleteFuture) result(client MonitorsClient) (osr OperationStatusResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.MonitorsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		osr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.MonitorsDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if osr.Response.Response, err = future.GetResult(sender); err == nil && osr.Response.Response.StatusCode != http.StatusNoContent {
		osr, err = client.DeleteResponder(osr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.MonitorsDeleteFuture", "Result", osr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// MsSQLServerProviderInstanceProperties gets or sets the SQL server provider properties.
type MsSQLServerProviderInstanceProperties struct {
	// Hostname - Gets or sets the SQL server host name.
	Hostname *string `json:"hostname,omitempty"`
	// DbPort - Gets or sets the database sql port.
	DbPort *string `json:"dbPort,omitempty"`
	// DbUsername - Gets or sets the database user name.
	DbUsername *string `json:"dbUsername,omitempty"`
	// DbPassword - Gets or sets the database password.
	DbPassword *string `json:"dbPassword,omitempty"`
	// DbPasswordURI - Gets or sets the key vault URI to secret with the database password.
	DbPasswordURI *string `json:"dbPasswordUri,omitempty"`
	// SapSid - Gets or sets the SAP System Identifier
	SapSid *string `json:"sapSid,omitempty"`
	// ProviderType - Possible values include: 'ProviderTypeProviderSpecificProperties', 'ProviderTypeSapHana', 'ProviderTypeSapNetWeaver', 'ProviderTypePrometheusOS', 'ProviderTypeDb2', 'ProviderTypePrometheusHaCluster', 'ProviderTypeMsSQLServer'
	ProviderType ProviderType `json:"providerType,omitempty"`
}

// MarshalJSON is the custom marshaler for MsSQLServerProviderInstanceProperties.
func (msspip MsSQLServerProviderInstanceProperties) MarshalJSON() ([]byte, error) {
	msspip.ProviderType = ProviderTypeMsSQLServer
	objectMap := make(map[string]interface{})
	if msspip.Hostname != nil {
		objectMap["hostname"] = msspip.Hostname
	}
	if msspip.DbPort != nil {
		objectMap["dbPort"] = msspip.DbPort
	}
	if msspip.DbUsername != nil {
		objectMap["dbUsername"] = msspip.DbUsername
	}
	if msspip.DbPassword != nil {
		objectMap["dbPassword"] = msspip.DbPassword
	}
	if msspip.DbPasswordURI != nil {
		objectMap["dbPasswordUri"] = msspip.DbPasswordURI
	}
	if msspip.SapSid != nil {
		objectMap["sapSid"] = msspip.SapSid
	}
	if msspip.ProviderType != "" {
		objectMap["providerType"] = msspip.ProviderType
	}
	return json.Marshal(objectMap)
}

// AsHanaDbProviderInstanceProperties is the BasicProviderSpecificProperties implementation for MsSQLServerProviderInstanceProperties.
func (msspip MsSQLServerProviderInstanceProperties) AsHanaDbProviderInstanceProperties() (*HanaDbProviderInstanceProperties, bool) {
	return nil, false
}

// AsSapNetWeaverProviderInstanceProperties is the BasicProviderSpecificProperties implementation for MsSQLServerProviderInstanceProperties.
func (msspip MsSQLServerProviderInstanceProperties) AsSapNetWeaverProviderInstanceProperties() (*SapNetWeaverProviderInstanceProperties, bool) {
	return nil, false
}

// AsPrometheusOSProviderInstanceProperties is the BasicProviderSpecificProperties implementation for MsSQLServerProviderInstanceProperties.
func (msspip MsSQLServerProviderInstanceProperties) AsPrometheusOSProviderInstanceProperties() (*PrometheusOSProviderInstanceProperties, bool) {
	return nil, false
}

// AsDB2ProviderInstanceProperties is the BasicProviderSpecificProperties implementation for MsSQLServerProviderInstanceProperties.
func (msspip MsSQLServerProviderInstanceProperties) AsDB2ProviderInstanceProperties() (*DB2ProviderInstanceProperties, bool) {
	return nil, false
}

// AsPrometheusHaClusterProviderInstanceProperties is the BasicProviderSpecificProperties implementation for MsSQLServerProviderInstanceProperties.
func (msspip MsSQLServerProviderInstanceProperties) AsPrometheusHaClusterProviderInstanceProperties() (*PrometheusHaClusterProviderInstanceProperties, bool) {
	return nil, false
}

// AsMsSQLServerProviderInstanceProperties is the BasicProviderSpecificProperties implementation for MsSQLServerProviderInstanceProperties.
func (msspip MsSQLServerProviderInstanceProperties) AsMsSQLServerProviderInstanceProperties() (*MsSQLServerProviderInstanceProperties, bool) {
	return &msspip, true
}

// AsProviderSpecificProperties is the BasicProviderSpecificProperties implementation for MsSQLServerProviderInstanceProperties.
func (msspip MsSQLServerProviderInstanceProperties) AsProviderSpecificProperties() (*ProviderSpecificProperties, bool) {
	return nil, false
}

// AsBasicProviderSpecificProperties is the BasicProviderSpecificProperties implementation for MsSQLServerProviderInstanceProperties.
func (msspip MsSQLServerProviderInstanceProperties) AsBasicProviderSpecificProperties() (BasicProviderSpecificProperties, bool) {
	return &msspip, true
}

// NetworkConfiguration defines the network configuration for SAP infrastructure
type NetworkConfiguration struct {
	// IsSecondaryIPEnabled - Specifies whether a secondary IP address should be added to the network interface on all VMs
	IsSecondaryIPEnabled *bool `json:"isSecondaryIpEnabled,omitempty"`
}

// NetworkProfile network profile
type NetworkProfile struct {
	// LoadBalancerType - Load balancer type. Possible values include: 'ApplicationGateway', 'LoadBalancer'
	LoadBalancerType LoadBalancerType `json:"loadBalancerType,omitempty"`
	// LoadBalancerSku - Load balancer SKU
	LoadBalancerSku *string `json:"loadBalancerSku,omitempty"`
	// LoadBalancerTier - Load balancer tier
	LoadBalancerTier *string `json:"loadBalancerTier,omitempty"`
	// Capacity - Capacity, applicable only for Application Gateway
	Capacity *int32 `json:"capacity,omitempty"`
	// AzureFrontDoorEnabled - Whether to enable Azure front door. Possible values include: 'Enabled', 'Disabled'
	AzureFrontDoorEnabled AzureFrontDoorEnabled `json:"azureFrontDoorEnabled,omitempty"`
	// VNetResourceID - READ-ONLY; Virtual network resource Id
	VNetResourceID *string `json:"vNetResourceId,omitempty"`
	// LoadBalancerResourceID - READ-ONLY; Azure Loadbalancer or ApplicationGateway resource Id
	LoadBalancerResourceID *string `json:"loadBalancerResourceId,omitempty"`
	// AzureFrontDoorResourceID - READ-ONLY; Azure front door resource id
	AzureFrontDoorResourceID *string `json:"azureFrontDoorResourceId,omitempty"`
	// FrontEndPublicIPResourceID - READ-ONLY; Loadbalancer front-end IP address resource Id
	FrontEndPublicIPResourceID *string `json:"frontEndPublicIpResourceId,omitempty"`
	// OutboundPublicIPResourceIds - READ-ONLY; List of outbound public IP resource IDs
	OutboundPublicIPResourceIds *[]string `json:"outboundPublicIpResourceIds,omitempty"`
}

// MarshalJSON is the custom marshaler for NetworkProfile.
func (np NetworkProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if np.LoadBalancerType != "" {
		objectMap["loadBalancerType"] = np.LoadBalancerType
	}
	if np.LoadBalancerSku != nil {
		objectMap["loadBalancerSku"] = np.LoadBalancerSku
	}
	if np.LoadBalancerTier != nil {
		objectMap["loadBalancerTier"] = np.LoadBalancerTier
	}
	if np.Capacity != nil {
		objectMap["capacity"] = np.Capacity
	}
	if np.AzureFrontDoorEnabled != "" {
		objectMap["azureFrontDoorEnabled"] = np.AzureFrontDoorEnabled
	}
	return json.Marshal(objectMap)
}

// NodeProfile VM or VMSS node profile
type NodeProfile struct {
	// Name - VM or VMSS name
	Name *string `json:"name,omitempty"`
	// NodeSku - VM SKU for node(s)
	NodeSku *string `json:"nodeSku,omitempty"`
	// OsImage - OS image used for creating the nodes
	OsImage *OsImageProfile `json:"osImage,omitempty"`
	// OsDisk - OS disk details
	OsDisk *DiskInfo `json:"osDisk,omitempty"`
	// DataDisks - Data disks details. This property is not in use right now
	DataDisks *[]DiskInfo `json:"dataDisks,omitempty"`
	// NodeResourceIds - READ-ONLY; VM/VMSS resource ARM Ids
	NodeResourceIds *[]string `json:"nodeResourceIds,omitempty"`
}

// MarshalJSON is the custom marshaler for NodeProfile.
func (np NodeProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if np.Name != nil {
		objectMap["name"] = np.Name
	}
	if np.NodeSku != nil {
		objectMap["nodeSku"] = np.NodeSku
	}
	if np.OsImage != nil {
		objectMap["osImage"] = np.OsImage
	}
	if np.OsDisk != nil {
		objectMap["osDisk"] = np.OsDisk
	}
	if np.DataDisks != nil {
		objectMap["dataDisks"] = np.DataDisks
	}
	return json.Marshal(objectMap)
}

// Operation details of a REST API operation, returned from the Resource Provider Operations API
type Operation struct {
	// Name - READ-ONLY; The name of the operation, as per Resource-Based Access Control (RBAC). Examples: "Microsoft.Compute/virtualMachines/write", "Microsoft.Compute/virtualMachines/capture/action"
	Name *string `json:"name,omitempty"`
	// IsDataAction - READ-ONLY; Whether the operation applies to data-plane. This is "true" for data-plane operations and "false" for ARM/control-plane operations.
	IsDataAction *bool `json:"isDataAction,omitempty"`
	// Display - Localized display information for this particular operation.
	Display *OperationDisplay `json:"display,omitempty"`
	// Origin - READ-ONLY; The intended executor of the operation; as in Resource Based Access Control (RBAC) and audit logs UX. Default value is "user,system". Possible values include: 'OriginUser', 'OriginSystem', 'OriginUsersystem'
	Origin Origin `json:"origin,omitempty"`
	// ActionType - READ-ONLY; Enum. Indicates the action type. "Internal" refers to actions that are for internal only APIs. Possible values include: 'Internal'
	ActionType ActionType `json:"actionType,omitempty"`
}

// MarshalJSON is the custom marshaler for Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if o.Display != nil {
		objectMap["display"] = o.Display
	}
	return json.Marshal(objectMap)
}

// OperationDisplay localized display information for this particular operation.
type OperationDisplay struct {
	// Provider - READ-ONLY; The localized friendly form of the resource provider name, e.g. "Microsoft Monitoring Insights" or "Microsoft Compute".
	Provider *string `json:"provider,omitempty"`
	// Resource - READ-ONLY; The localized friendly name of the resource type related to this operation. E.g. "Virtual Machines" or "Job Schedule Collections".
	Resource *string `json:"resource,omitempty"`
	// Operation - READ-ONLY; The concise, localized friendly name for the operation; suitable for dropdowns. E.g. "Create or Update Virtual Machine", "Restart Virtual Machine".
	Operation *string `json:"operation,omitempty"`
	// Description - READ-ONLY; The short, localized friendly description of the operation; suitable for tool tips and detailed views.
	Description *string `json:"description,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// OperationListResult a list of REST API operations supported by an Azure Resource Provider. It contains
// an URL link to get the next set of results.
type OperationListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; List of operations supported by the resource provider
	Value *[]Operation `json:"value,omitempty"`
	// NextLink - READ-ONLY; URL to get the next set of operation list results (if there are any).
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationListResult.
func (olr OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// OperationListResultIterator provides access to a complete listing of Operation values.
type OperationListResultIterator struct {
	i    int
	page OperationListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *OperationListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *OperationListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter OperationListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter OperationListResultIterator) Response() OperationListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter OperationListResultIterator) Value() Operation {
	if !iter.page.NotDone() {
		return Operation{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the OperationListResultIterator type.
func NewOperationListResultIterator(page OperationListResultPage) OperationListResultIterator {
	return OperationListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (olr OperationListResult) IsEmpty() bool {
	return olr.Value == nil || len(*olr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (olr OperationListResult) hasNextLink() bool {
	return olr.NextLink != nil && len(*olr.NextLink) != 0
}

// operationListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (olr OperationListResult) operationListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !olr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(olr.NextLink)))
}

// OperationListResultPage contains a page of Operation values.
type OperationListResultPage struct {
	fn  func(context.Context, OperationListResult) (OperationListResult, error)
	olr OperationListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *OperationListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/OperationListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.olr)
		if err != nil {
			return err
		}
		page.olr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *OperationListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page OperationListResultPage) NotDone() bool {
	return !page.olr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page OperationListResultPage) Response() OperationListResult {
	return page.olr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page OperationListResultPage) Values() []Operation {
	if page.olr.IsEmpty() {
		return nil
	}
	return *page.olr.Value
}

// Creates a new instance of the OperationListResultPage type.
func NewOperationListResultPage(cur OperationListResult, getNextPage func(context.Context, OperationListResult) (OperationListResult, error)) OperationListResultPage {
	return OperationListResultPage{
		fn:  getNextPage,
		olr: cur,
	}
}

// OperationsContent defines the workload operation content.
type OperationsContent struct {
	// OperationsDefinition - Operations content.
	*OperationsDefinition `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationsContent.
func (oc OperationsContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if oc.OperationsDefinition != nil {
		objectMap["properties"] = oc.OperationsDefinition
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for OperationsContent struct.
func (oc *OperationsContent) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var operationsDefinition OperationsDefinition
				err = json.Unmarshal(*v, &operationsDefinition)
				if err != nil {
					return err
				}
				oc.OperationsDefinition = &operationsDefinition
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				oc.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				oc.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				oc.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				oc.SystemData = &systemData
			}
		}
	}

	return nil
}

// OperationsDefinition properties of an Operation.
type OperationsDefinition struct {
	// Name - Name of the operation.
	Name *string `json:"name,omitempty"`
	// IsDataAction - Indicates whether the operation applies to data-plane.
	IsDataAction *bool `json:"isDataAction,omitempty"`
	// Origin - Defines the workload operation origin. Possible values include: 'OperationPropertiesNotSpecified', 'OperationPropertiesUser', 'OperationPropertiesSystem'
	Origin OperationProperties `json:"origin,omitempty"`
	// Display - Display information of the operation.
	Display *OperationsDefinitionDisplay `json:"display,omitempty"`
	// ActionType - Defines the action type of workload operation. Possible values include: 'WorkloadMonitorActionTypeNotSpecified', 'WorkloadMonitorActionTypeInternal'
	ActionType WorkloadMonitorActionType `json:"actionType,omitempty"`
	// Properties - Defines the workload operation properties.
	Properties interface{} `json:"properties,omitempty"`
}

// OperationsDefinitionArrayResponseWithContinuation defines the workload operation definition response.
type OperationsDefinitionArrayResponseWithContinuation struct {
	// Value - Defines the workload operation definition response properties.
	Value *[]OperationsDefinition `json:"value,omitempty"`
	// NextLink - The URL to get to the next set of results, if there are any.
	NextLink *string `json:"nextLink,omitempty"`
}

// OperationsDefinitionDisplay display information of the operation.
type OperationsDefinitionDisplay struct {
	// Provider - Defines the workload provider.
	Provider *string `json:"provider,omitempty"`
	// Resource - Defines the workload resource.
	Resource *string `json:"resource,omitempty"`
	// Operation - Defines the workload operation.
	Operation *string `json:"operation,omitempty"`
	// Description - Describes the workload operation.
	Description *string `json:"description,omitempty"`
}

// OperationsDisplayDefinition defines the workload operation.
type OperationsDisplayDefinition struct {
	// Provider - Defines the workload provider.
	Provider *string `json:"provider,omitempty"`
	// Resource - Defines the workload resource.
	Resource *string `json:"resource,omitempty"`
	// Operation - Defines the workload operation.
	Operation *string `json:"operation,omitempty"`
	// Description - Describes the workload operation.
	Description *string `json:"description,omitempty"`
}

// OperationStatusResult the current status of an async operation.
type OperationStatusResult struct {
	autorest.Response `json:"-"`
	// ID - Fully qualified ID for the async operation.
	ID *string `json:"id,omitempty"`
	// Name - Name of the async operation.
	Name *string `json:"name,omitempty"`
	// Status - Operation status.
	Status *string `json:"status,omitempty"`
	// PercentComplete - Percent of the operation that is complete.
	PercentComplete *float64 `json:"percentComplete,omitempty"`
	// StartTime - The start time of the operation.
	StartTime *date.Time `json:"startTime,omitempty"`
	// EndTime - The end time of the operation.
	EndTime *date.Time `json:"endTime,omitempty"`
	// Operations - The operations list.
	Operations *[]OperationStatusResult `json:"operations,omitempty"`
	// Error - If present, details of the operation error.
	Error *ErrorDetail `json:"error,omitempty"`
}

// BasicOSConfiguration defines the OS configuration.
type BasicOSConfiguration interface {
	AsWindowsConfiguration() (*WindowsConfiguration, bool)
	AsLinuxConfiguration() (*LinuxConfiguration, bool)
	AsOSConfiguration() (*OSConfiguration, bool)
}

// OSConfiguration defines the OS configuration.
type OSConfiguration struct {
	// OsType - Possible values include: 'OsTypeOSConfiguration', 'OsTypeWindows', 'OsTypeLinux'
	OsType OsType `json:"osType,omitempty"`
}

func unmarshalBasicOSConfiguration(body []byte) (BasicOSConfiguration, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["osType"] {
	case string(OsTypeWindows):
		var wc WindowsConfiguration
		err := json.Unmarshal(body, &wc)
		return wc, err
	case string(OsTypeLinux):
		var lc LinuxConfiguration
		err := json.Unmarshal(body, &lc)
		return lc, err
	default:
		var oc OSConfiguration
		err := json.Unmarshal(body, &oc)
		return oc, err
	}
}
func unmarshalBasicOSConfigurationArray(body []byte) ([]BasicOSConfiguration, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	ocArray := make([]BasicOSConfiguration, len(rawMessages))

	for index, rawMessage := range rawMessages {
		oc, err := unmarshalBasicOSConfiguration(*rawMessage)
		if err != nil {
			return nil, err
		}
		ocArray[index] = oc
	}
	return ocArray, nil
}

// MarshalJSON is the custom marshaler for OSConfiguration.
func (oc OSConfiguration) MarshalJSON() ([]byte, error) {
	oc.OsType = OsTypeOSConfiguration
	objectMap := make(map[string]interface{})
	if oc.OsType != "" {
		objectMap["osType"] = oc.OsType
	}
	return json.Marshal(objectMap)
}

// AsWindowsConfiguration is the BasicOSConfiguration implementation for OSConfiguration.
func (oc OSConfiguration) AsWindowsConfiguration() (*WindowsConfiguration, bool) {
	return nil, false
}

// AsLinuxConfiguration is the BasicOSConfiguration implementation for OSConfiguration.
func (oc OSConfiguration) AsLinuxConfiguration() (*LinuxConfiguration, bool) {
	return nil, false
}

// AsOSConfiguration is the BasicOSConfiguration implementation for OSConfiguration.
func (oc OSConfiguration) AsOSConfiguration() (*OSConfiguration, bool) {
	return &oc, true
}

// AsBasicOSConfiguration is the BasicOSConfiguration implementation for OSConfiguration.
func (oc OSConfiguration) AsBasicOSConfiguration() (BasicOSConfiguration, bool) {
	return &oc, true
}

// OsImageProfile OS image profile
type OsImageProfile struct {
	// Publisher - OS image publisher. Possible values include: 'Canonical'
	Publisher OSImagePublisher `json:"publisher,omitempty"`
	// Offer - OS image offer. Possible values include: 'UbuntuServer'
	Offer OSImageOffer `json:"offer,omitempty"`
	// Sku - OS image sku. Possible values include: 'OneEightFullStopZeroFourHyphenMinusLTS', 'OneSixFullStopZeroFourHyphenMinusLTS'
	Sku OSImageSku `json:"sku,omitempty"`
	// Version - OS image version. Possible values include: 'Latest'
	Version OSImageVersion `json:"version,omitempty"`
}

// OSProfile specifies the operating system settings for the virtual machine. Some of the settings cannot
// be changed once VM is provisioned.
type OSProfile struct {
	// AdminUsername - Specifies the name of the administrator account. <br><br> This property cannot be updated after the VM is created. <br><br> **Windows-only restriction:** Cannot end in "." <br><br> **Disallowed values:** "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123", "a", "actuser", "adm", "admin2", "aspnet", "backup", "console", "david", "guest", "john", "owner", "root", "server", "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5". <br><br> **Minimum-length (Linux):** 1  character <br><br> **Max-length (Linux):** 64 characters <br><br> **Max-length (Windows):** 20 characters.
	AdminUsername *string `json:"adminUsername,omitempty"`
	// AdminPassword - Specifies the password of the administrator account. <br><br> **Minimum-length (Windows):** 8 characters <br><br> **Minimum-length (Linux):** 6 characters <br><br> **Max-length (Windows):** 123 characters <br><br> **Max-length (Linux):** 72 characters <br><br> **Complexity requirements:** 3 out of 4 conditions below need to be fulfilled <br> Has lower characters <br>Has upper characters <br> Has a digit <br> Has a special character (Regex match [\W_]) <br><br> **Disallowed values:** "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1", "Password22", "iloveyou!" <br><br> For resetting the password, see [How to reset the Remote Desktop service or its login password in a Windows VM](https://docs.microsoft.com/troubleshoot/azure/virtual-machines/reset-rdp) <br><br> For resetting root password, see [Manage users, SSH, and check or repair disks on Azure Linux VMs using the VMAccess Extension](https://docs.microsoft.com/troubleshoot/azure/virtual-machines/troubleshoot-ssh-connection)
	AdminPassword *string `json:"adminPassword,omitempty"`
	// OsConfiguration - Specifies Windows operating system settings on the virtual machine.
	OsConfiguration BasicOSConfiguration `json:"osConfiguration,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for OSProfile struct.
func (op *OSProfile) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "adminUsername":
			if v != nil {
				var adminUsername string
				err = json.Unmarshal(*v, &adminUsername)
				if err != nil {
					return err
				}
				op.AdminUsername = &adminUsername
			}
		case "adminPassword":
			if v != nil {
				var adminPassword string
				err = json.Unmarshal(*v, &adminPassword)
				if err != nil {
					return err
				}
				op.AdminPassword = &adminPassword
			}
		case "osConfiguration":
			if v != nil {
				osConfiguration, err := unmarshalBasicOSConfiguration(*v)
				if err != nil {
					return err
				}
				op.OsConfiguration = osConfiguration
			}
		}
	}

	return nil
}

// OsSapConfiguration defines the OS and SAP Configurations for Deployment
type OsSapConfiguration struct {
	// DeployerVMPackages - The url and storage account ID where deployer VM packages are uploaded
	DeployerVMPackages *DeployerVMPackages `json:"deployerVmPackages,omitempty"`
	// SapFqdn - The FQDN to set for the SAP system
	SapFqdn *string `json:"sapFqdn,omitempty"`
}

// PatchResourceRequestBody resource patch request body
type PatchResourceRequestBody struct {
	// Tags - Resource tags
	Tags     map[string]*string                `json:"tags"`
	Identity *PatchResourceRequestBodyIdentity `json:"identity,omitempty"`
}

// MarshalJSON is the custom marshaler for PatchResourceRequestBody.
func (prrb PatchResourceRequestBody) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if prrb.Tags != nil {
		objectMap["tags"] = prrb.Tags
	}
	if prrb.Identity != nil {
		objectMap["identity"] = prrb.Identity
	}
	return json.Marshal(objectMap)
}

// PatchResourceRequestBodyIdentity ...
type PatchResourceRequestBodyIdentity struct {
	// Type - Type of manage identity. Possible values include: 'None', 'UserAssigned'
	Type ManagedServiceIdentityType `json:"type,omitempty"`
	// UserAssignedIdentities - User assigned identities dictionary
	UserAssignedIdentities map[string]*UserAssignedIdentity `json:"userAssignedIdentities"`
}

// MarshalJSON is the custom marshaler for PatchResourceRequestBodyIdentity.
func (prrb PatchResourceRequestBodyIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if prrb.Type != "" {
		objectMap["type"] = prrb.Type
	}
	if prrb.UserAssignedIdentities != nil {
		objectMap["userAssignedIdentities"] = prrb.UserAssignedIdentities
	}
	return json.Marshal(objectMap)
}

// PhpProfile PHP profile
type PhpProfile struct {
	// Version - PHP version. Possible values include: 'SevenFullStopTwo', 'SevenFullStopThree', 'SevenFullStopFour'
	Version PHPVersion `json:"version,omitempty"`
}

// PhpWorkloadResource php workload resource
type PhpWorkloadResource struct {
	autorest.Response `json:"-"`
	// PhpWorkloadResourceProperties - Resource properties
	*PhpWorkloadResourceProperties `json:"properties,omitempty"`
	// Kind - Indicates which kind of php workload this resource represent e.g WordPress
	Kind *string `json:"kind,omitempty"`
	// Sku - Php workloads SKU
	Sku *Sku `json:"sku,omitempty"`
	// Identity - Identity for the resource. Currently not supported
	Identity *PhpWorkloadResourceIdentity `json:"identity,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for PhpWorkloadResource.
func (pwr PhpWorkloadResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pwr.PhpWorkloadResourceProperties != nil {
		objectMap["properties"] = pwr.PhpWorkloadResourceProperties
	}
	if pwr.Kind != nil {
		objectMap["kind"] = pwr.Kind
	}
	if pwr.Sku != nil {
		objectMap["sku"] = pwr.Sku
	}
	if pwr.Identity != nil {
		objectMap["identity"] = pwr.Identity
	}
	if pwr.Tags != nil {
		objectMap["tags"] = pwr.Tags
	}
	if pwr.Location != nil {
		objectMap["location"] = pwr.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for PhpWorkloadResource struct.
func (pwr *PhpWorkloadResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var phpWorkloadResourceProperties PhpWorkloadResourceProperties
				err = json.Unmarshal(*v, &phpWorkloadResourceProperties)
				if err != nil {
					return err
				}
				pwr.PhpWorkloadResourceProperties = &phpWorkloadResourceProperties
			}
		case "kind":
			if v != nil {
				var kind string
				err = json.Unmarshal(*v, &kind)
				if err != nil {
					return err
				}
				pwr.Kind = &kind
			}
		case "sku":
			if v != nil {
				var sku Sku
				err = json.Unmarshal(*v, &sku)
				if err != nil {
					return err
				}
				pwr.Sku = &sku
			}
		case "identity":
			if v != nil {
				var identity PhpWorkloadResourceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				pwr.Identity = &identity
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				pwr.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				pwr.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pwr.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pwr.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pwr.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				pwr.SystemData = &systemData
			}
		}
	}

	return nil
}

// PhpWorkloadResourceIdentity identity for the resource. Currently not supported
type PhpWorkloadResourceIdentity struct {
	// Type - Type of manage identity. Possible values include: 'None', 'UserAssigned'
	Type ManagedServiceIdentityType `json:"type,omitempty"`
	// UserAssignedIdentities - User assigned identities dictionary
	UserAssignedIdentities map[string]*UserAssignedIdentity `json:"userAssignedIdentities"`
}

// MarshalJSON is the custom marshaler for PhpWorkloadResourceIdentity.
func (pwr PhpWorkloadResourceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pwr.Type != "" {
		objectMap["type"] = pwr.Type
	}
	if pwr.UserAssignedIdentities != nil {
		objectMap["userAssignedIdentities"] = pwr.UserAssignedIdentities
	}
	return json.Marshal(objectMap)
}

// PhpWorkloadResourceList php workload resource list
type PhpWorkloadResourceList struct {
	autorest.Response `json:"-"`
	// Value - List of resources in current page
	Value *[]PhpWorkloadResource `json:"value,omitempty"`
	// NextLink - Link to next page of resources
	NextLink *string `json:"nextLink,omitempty"`
}

// PhpWorkloadResourceListIterator provides access to a complete listing of PhpWorkloadResource values.
type PhpWorkloadResourceListIterator struct {
	i    int
	page PhpWorkloadResourceListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *PhpWorkloadResourceListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PhpWorkloadResourceListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *PhpWorkloadResourceListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter PhpWorkloadResourceListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter PhpWorkloadResourceListIterator) Response() PhpWorkloadResourceList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter PhpWorkloadResourceListIterator) Value() PhpWorkloadResource {
	if !iter.page.NotDone() {
		return PhpWorkloadResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the PhpWorkloadResourceListIterator type.
func NewPhpWorkloadResourceListIterator(page PhpWorkloadResourceListPage) PhpWorkloadResourceListIterator {
	return PhpWorkloadResourceListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pwrl PhpWorkloadResourceList) IsEmpty() bool {
	return pwrl.Value == nil || len(*pwrl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pwrl PhpWorkloadResourceList) hasNextLink() bool {
	return pwrl.NextLink != nil && len(*pwrl.NextLink) != 0
}

// phpWorkloadResourceListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pwrl PhpWorkloadResourceList) phpWorkloadResourceListPreparer(ctx context.Context) (*http.Request, error) {
	if !pwrl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pwrl.NextLink)))
}

// PhpWorkloadResourceListPage contains a page of PhpWorkloadResource values.
type PhpWorkloadResourceListPage struct {
	fn   func(context.Context, PhpWorkloadResourceList) (PhpWorkloadResourceList, error)
	pwrl PhpWorkloadResourceList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *PhpWorkloadResourceListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/PhpWorkloadResourceListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pwrl)
		if err != nil {
			return err
		}
		page.pwrl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *PhpWorkloadResourceListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page PhpWorkloadResourceListPage) NotDone() bool {
	return !page.pwrl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page PhpWorkloadResourceListPage) Response() PhpWorkloadResourceList {
	return page.pwrl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page PhpWorkloadResourceListPage) Values() []PhpWorkloadResource {
	if page.pwrl.IsEmpty() {
		return nil
	}
	return *page.pwrl.Value
}

// Creates a new instance of the PhpWorkloadResourceListPage type.
func NewPhpWorkloadResourceListPage(cur PhpWorkloadResourceList, getNextPage func(context.Context, PhpWorkloadResourceList) (PhpWorkloadResourceList, error)) PhpWorkloadResourceListPage {
	return PhpWorkloadResourceListPage{
		fn:   getNextPage,
		pwrl: cur,
	}
}

// PhpWorkloadResourceProperties PHP workload resource properties
type PhpWorkloadResourceProperties struct {
	// AppLocation - The infra resources for PHP workload will be created in this location
	AppLocation *string `json:"appLocation,omitempty"`
	// ManagedResourceGroupConfiguration - Managed resource group configuration of the workload
	ManagedResourceGroupConfiguration *ManagedRGConfiguration `json:"managedResourceGroupConfiguration,omitempty"`
	// AdminUserProfile - Admin user profile used for VM and VMSS
	AdminUserProfile *UserProfile `json:"adminUserProfile,omitempty"`
	// WebNodesProfile - VMSS web nodes profile
	WebNodesProfile *VmssNodesProfile `json:"webNodesProfile,omitempty"`
	// ControllerProfile - Controller VM profile
	ControllerProfile *NodeProfile `json:"controllerProfile,omitempty"`
	// NetworkProfile - Network profile
	NetworkProfile *NetworkProfile `json:"networkProfile,omitempty"`
	// DatabaseProfile - Database profile
	DatabaseProfile *DatabaseProfile `json:"databaseProfile,omitempty"`
	// SiteProfile - Site profile
	SiteProfile *SiteProfile `json:"siteProfile,omitempty"`
	// FileshareProfile - File share profile
	FileshareProfile *FileshareProfile `json:"fileshareProfile,omitempty"`
	// PhpProfile - PHP profile
	PhpProfile *PhpProfile `json:"phpProfile,omitempty"`
	// SearchProfile - Search profile
	SearchProfile *SearchProfile `json:"searchProfile,omitempty"`
	// CacheProfile - Cache profile
	CacheProfile *CacheProfile `json:"cacheProfile,omitempty"`
	// BackupProfile - Backup profile
	BackupProfile *BackupProfile `json:"backupProfile,omitempty"`
	// ProvisioningState - READ-ONLY; Php workload resource provisioning state. Possible values include: 'PhpWorkloadProvisioningStateNotSpecified', 'PhpWorkloadProvisioningStateAccepted', 'PhpWorkloadProvisioningStateCreated', 'PhpWorkloadProvisioningStateSucceeded', 'PhpWorkloadProvisioningStateFailed', 'PhpWorkloadProvisioningStateCanceled', 'PhpWorkloadProvisioningStateProvisioning', 'PhpWorkloadProvisioningStateDeleting'
	ProvisioningState PhpWorkloadProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for PhpWorkloadResourceProperties.
func (pwrp PhpWorkloadResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pwrp.AppLocation != nil {
		objectMap["appLocation"] = pwrp.AppLocation
	}
	if pwrp.ManagedResourceGroupConfiguration != nil {
		objectMap["managedResourceGroupConfiguration"] = pwrp.ManagedResourceGroupConfiguration
	}
	if pwrp.AdminUserProfile != nil {
		objectMap["adminUserProfile"] = pwrp.AdminUserProfile
	}
	if pwrp.WebNodesProfile != nil {
		objectMap["webNodesProfile"] = pwrp.WebNodesProfile
	}
	if pwrp.ControllerProfile != nil {
		objectMap["controllerProfile"] = pwrp.ControllerProfile
	}
	if pwrp.NetworkProfile != nil {
		objectMap["networkProfile"] = pwrp.NetworkProfile
	}
	if pwrp.DatabaseProfile != nil {
		objectMap["databaseProfile"] = pwrp.DatabaseProfile
	}
	if pwrp.SiteProfile != nil {
		objectMap["siteProfile"] = pwrp.SiteProfile
	}
	if pwrp.FileshareProfile != nil {
		objectMap["fileshareProfile"] = pwrp.FileshareProfile
	}
	if pwrp.PhpProfile != nil {
		objectMap["phpProfile"] = pwrp.PhpProfile
	}
	if pwrp.SearchProfile != nil {
		objectMap["searchProfile"] = pwrp.SearchProfile
	}
	if pwrp.CacheProfile != nil {
		objectMap["cacheProfile"] = pwrp.CacheProfile
	}
	if pwrp.BackupProfile != nil {
		objectMap["backupProfile"] = pwrp.BackupProfile
	}
	return json.Marshal(objectMap)
}

// PhpWorkloadsCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type PhpWorkloadsCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PhpWorkloadsClient) (PhpWorkloadResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PhpWorkloadsCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PhpWorkloadsCreateOrUpdateFuture.Result.
func (future *PhpWorkloadsCreateOrUpdateFuture) result(client PhpWorkloadsClient) (pwr PhpWorkloadResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.PhpWorkloadsCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pwr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.PhpWorkloadsCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pwr.Response.Response, err = future.GetResult(sender); err == nil && pwr.Response.Response.StatusCode != http.StatusNoContent {
		pwr, err = client.CreateOrUpdateResponder(pwr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.PhpWorkloadsCreateOrUpdateFuture", "Result", pwr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// PhpWorkloadsDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type PhpWorkloadsDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(PhpWorkloadsClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *PhpWorkloadsDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for PhpWorkloadsDeleteFuture.Result.
func (future *PhpWorkloadsDeleteFuture) result(client PhpWorkloadsClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.PhpWorkloadsDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.PhpWorkloadsDeleteFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// Plan plan for the resource.
type Plan struct {
	// Name - A user defined name of the 3rd Party Artifact that is being procured.
	Name *string `json:"name,omitempty"`
	// Publisher - The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
	Publisher *string `json:"publisher,omitempty"`
	// Product - The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding.
	Product *string `json:"product,omitempty"`
	// PromotionCode - A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
	PromotionCode *string `json:"promotionCode,omitempty"`
	// Version - The version of the desired product/artifact.
	Version *string `json:"version,omitempty"`
}

// PrometheusHaClusterProviderInstanceProperties gets or sets the PrometheusHaCluster provider properties.
type PrometheusHaClusterProviderInstanceProperties struct {
	// PrometheusURL - URL of the Node Exporter endpoint.
	PrometheusURL *string `json:"prometheusUrl,omitempty"`
	// Hostname - Gets or sets the target machine name.
	Hostname *string `json:"hostname,omitempty"`
	// Sid - Gets or sets the cluster sid.
	Sid *string `json:"sid,omitempty"`
	// ClusterName - Gets or sets the clusterName.
	ClusterName *string `json:"clusterName,omitempty"`
	// ProviderType - Possible values include: 'ProviderTypeProviderSpecificProperties', 'ProviderTypeSapHana', 'ProviderTypeSapNetWeaver', 'ProviderTypePrometheusOS', 'ProviderTypeDb2', 'ProviderTypePrometheusHaCluster', 'ProviderTypeMsSQLServer'
	ProviderType ProviderType `json:"providerType,omitempty"`
}

// MarshalJSON is the custom marshaler for PrometheusHaClusterProviderInstanceProperties.
func (phcpip PrometheusHaClusterProviderInstanceProperties) MarshalJSON() ([]byte, error) {
	phcpip.ProviderType = ProviderTypePrometheusHaCluster
	objectMap := make(map[string]interface{})
	if phcpip.PrometheusURL != nil {
		objectMap["prometheusUrl"] = phcpip.PrometheusURL
	}
	if phcpip.Hostname != nil {
		objectMap["hostname"] = phcpip.Hostname
	}
	if phcpip.Sid != nil {
		objectMap["sid"] = phcpip.Sid
	}
	if phcpip.ClusterName != nil {
		objectMap["clusterName"] = phcpip.ClusterName
	}
	if phcpip.ProviderType != "" {
		objectMap["providerType"] = phcpip.ProviderType
	}
	return json.Marshal(objectMap)
}

// AsHanaDbProviderInstanceProperties is the BasicProviderSpecificProperties implementation for PrometheusHaClusterProviderInstanceProperties.
func (phcpip PrometheusHaClusterProviderInstanceProperties) AsHanaDbProviderInstanceProperties() (*HanaDbProviderInstanceProperties, bool) {
	return nil, false
}

// AsSapNetWeaverProviderInstanceProperties is the BasicProviderSpecificProperties implementation for PrometheusHaClusterProviderInstanceProperties.
func (phcpip PrometheusHaClusterProviderInstanceProperties) AsSapNetWeaverProviderInstanceProperties() (*SapNetWeaverProviderInstanceProperties, bool) {
	return nil, false
}

// AsPrometheusOSProviderInstanceProperties is the BasicProviderSpecificProperties implementation for PrometheusHaClusterProviderInstanceProperties.
func (phcpip PrometheusHaClusterProviderInstanceProperties) AsPrometheusOSProviderInstanceProperties() (*PrometheusOSProviderInstanceProperties, bool) {
	return nil, false
}

// AsDB2ProviderInstanceProperties is the BasicProviderSpecificProperties implementation for PrometheusHaClusterProviderInstanceProperties.
func (phcpip PrometheusHaClusterProviderInstanceProperties) AsDB2ProviderInstanceProperties() (*DB2ProviderInstanceProperties, bool) {
	return nil, false
}

// AsPrometheusHaClusterProviderInstanceProperties is the BasicProviderSpecificProperties implementation for PrometheusHaClusterProviderInstanceProperties.
func (phcpip PrometheusHaClusterProviderInstanceProperties) AsPrometheusHaClusterProviderInstanceProperties() (*PrometheusHaClusterProviderInstanceProperties, bool) {
	return &phcpip, true
}

// AsMsSQLServerProviderInstanceProperties is the BasicProviderSpecificProperties implementation for PrometheusHaClusterProviderInstanceProperties.
func (phcpip PrometheusHaClusterProviderInstanceProperties) AsMsSQLServerProviderInstanceProperties() (*MsSQLServerProviderInstanceProperties, bool) {
	return nil, false
}

// AsProviderSpecificProperties is the BasicProviderSpecificProperties implementation for PrometheusHaClusterProviderInstanceProperties.
func (phcpip PrometheusHaClusterProviderInstanceProperties) AsProviderSpecificProperties() (*ProviderSpecificProperties, bool) {
	return nil, false
}

// AsBasicProviderSpecificProperties is the BasicProviderSpecificProperties implementation for PrometheusHaClusterProviderInstanceProperties.
func (phcpip PrometheusHaClusterProviderInstanceProperties) AsBasicProviderSpecificProperties() (BasicProviderSpecificProperties, bool) {
	return &phcpip, true
}

// PrometheusOSProviderInstanceProperties gets or sets the PrometheusOS provider properties.
type PrometheusOSProviderInstanceProperties struct {
	// PrometheusURL - URL of the Node Exporter endpoint
	PrometheusURL *string `json:"prometheusUrl,omitempty"`
	// ProviderType - Possible values include: 'ProviderTypeProviderSpecificProperties', 'ProviderTypeSapHana', 'ProviderTypeSapNetWeaver', 'ProviderTypePrometheusOS', 'ProviderTypeDb2', 'ProviderTypePrometheusHaCluster', 'ProviderTypeMsSQLServer'
	ProviderType ProviderType `json:"providerType,omitempty"`
}

// MarshalJSON is the custom marshaler for PrometheusOSProviderInstanceProperties.
func (popip PrometheusOSProviderInstanceProperties) MarshalJSON() ([]byte, error) {
	popip.ProviderType = ProviderTypePrometheusOS
	objectMap := make(map[string]interface{})
	if popip.PrometheusURL != nil {
		objectMap["prometheusUrl"] = popip.PrometheusURL
	}
	if popip.ProviderType != "" {
		objectMap["providerType"] = popip.ProviderType
	}
	return json.Marshal(objectMap)
}

// AsHanaDbProviderInstanceProperties is the BasicProviderSpecificProperties implementation for PrometheusOSProviderInstanceProperties.
func (popip PrometheusOSProviderInstanceProperties) AsHanaDbProviderInstanceProperties() (*HanaDbProviderInstanceProperties, bool) {
	return nil, false
}

// AsSapNetWeaverProviderInstanceProperties is the BasicProviderSpecificProperties implementation for PrometheusOSProviderInstanceProperties.
func (popip PrometheusOSProviderInstanceProperties) AsSapNetWeaverProviderInstanceProperties() (*SapNetWeaverProviderInstanceProperties, bool) {
	return nil, false
}

// AsPrometheusOSProviderInstanceProperties is the BasicProviderSpecificProperties implementation for PrometheusOSProviderInstanceProperties.
func (popip PrometheusOSProviderInstanceProperties) AsPrometheusOSProviderInstanceProperties() (*PrometheusOSProviderInstanceProperties, bool) {
	return &popip, true
}

// AsDB2ProviderInstanceProperties is the BasicProviderSpecificProperties implementation for PrometheusOSProviderInstanceProperties.
func (popip PrometheusOSProviderInstanceProperties) AsDB2ProviderInstanceProperties() (*DB2ProviderInstanceProperties, bool) {
	return nil, false
}

// AsPrometheusHaClusterProviderInstanceProperties is the BasicProviderSpecificProperties implementation for PrometheusOSProviderInstanceProperties.
func (popip PrometheusOSProviderInstanceProperties) AsPrometheusHaClusterProviderInstanceProperties() (*PrometheusHaClusterProviderInstanceProperties, bool) {
	return nil, false
}

// AsMsSQLServerProviderInstanceProperties is the BasicProviderSpecificProperties implementation for PrometheusOSProviderInstanceProperties.
func (popip PrometheusOSProviderInstanceProperties) AsMsSQLServerProviderInstanceProperties() (*MsSQLServerProviderInstanceProperties, bool) {
	return nil, false
}

// AsProviderSpecificProperties is the BasicProviderSpecificProperties implementation for PrometheusOSProviderInstanceProperties.
func (popip PrometheusOSProviderInstanceProperties) AsProviderSpecificProperties() (*ProviderSpecificProperties, bool) {
	return nil, false
}

// AsBasicProviderSpecificProperties is the BasicProviderSpecificProperties implementation for PrometheusOSProviderInstanceProperties.
func (popip PrometheusOSProviderInstanceProperties) AsBasicProviderSpecificProperties() (BasicProviderSpecificProperties, bool) {
	return &popip, true
}

// ProviderInstance a provider instance associated with SAP monitor.
type ProviderInstance struct {
	autorest.Response `json:"-"`
	Identity          *UserAssignedServiceIdentity `json:"identity,omitempty"`
	// ProviderInstanceProperties - Provider Instance properties
	*ProviderInstanceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for ProviderInstance.
func (pi ProviderInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if pi.Identity != nil {
		objectMap["identity"] = pi.Identity
	}
	if pi.ProviderInstanceProperties != nil {
		objectMap["properties"] = pi.ProviderInstanceProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ProviderInstance struct.
func (pi *ProviderInstance) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "identity":
			if v != nil {
				var identity UserAssignedServiceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				pi.Identity = &identity
			}
		case "properties":
			if v != nil {
				var providerInstanceProperties ProviderInstanceProperties
				err = json.Unmarshal(*v, &providerInstanceProperties)
				if err != nil {
					return err
				}
				pi.ProviderInstanceProperties = &providerInstanceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				pi.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				pi.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				pi.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				pi.SystemData = &systemData
			}
		}
	}

	return nil
}

// ProviderInstanceListResult the response from the List provider instances operation.
type ProviderInstanceListResult struct {
	autorest.Response `json:"-"`
	// Value - The list of provider instances.
	Value *[]ProviderInstance `json:"value,omitempty"`
	// NextLink - The URL to get the next set of provider instances.
	NextLink *string `json:"nextLink,omitempty"`
}

// ProviderInstanceListResultIterator provides access to a complete listing of ProviderInstance values.
type ProviderInstanceListResultIterator struct {
	i    int
	page ProviderInstanceListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *ProviderInstanceListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProviderInstanceListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *ProviderInstanceListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter ProviderInstanceListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter ProviderInstanceListResultIterator) Response() ProviderInstanceListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter ProviderInstanceListResultIterator) Value() ProviderInstance {
	if !iter.page.NotDone() {
		return ProviderInstance{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the ProviderInstanceListResultIterator type.
func NewProviderInstanceListResultIterator(page ProviderInstanceListResultPage) ProviderInstanceListResultIterator {
	return ProviderInstanceListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (pilr ProviderInstanceListResult) IsEmpty() bool {
	return pilr.Value == nil || len(*pilr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (pilr ProviderInstanceListResult) hasNextLink() bool {
	return pilr.NextLink != nil && len(*pilr.NextLink) != 0
}

// providerInstanceListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (pilr ProviderInstanceListResult) providerInstanceListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !pilr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(pilr.NextLink)))
}

// ProviderInstanceListResultPage contains a page of ProviderInstance values.
type ProviderInstanceListResultPage struct {
	fn   func(context.Context, ProviderInstanceListResult) (ProviderInstanceListResult, error)
	pilr ProviderInstanceListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *ProviderInstanceListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProviderInstanceListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.pilr)
		if err != nil {
			return err
		}
		page.pilr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *ProviderInstanceListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page ProviderInstanceListResultPage) NotDone() bool {
	return !page.pilr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page ProviderInstanceListResultPage) Response() ProviderInstanceListResult {
	return page.pilr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page ProviderInstanceListResultPage) Values() []ProviderInstance {
	if page.pilr.IsEmpty() {
		return nil
	}
	return *page.pilr.Value
}

// Creates a new instance of the ProviderInstanceListResultPage type.
func NewProviderInstanceListResultPage(cur ProviderInstanceListResult, getNextPage func(context.Context, ProviderInstanceListResult) (ProviderInstanceListResult, error)) ProviderInstanceListResultPage {
	return ProviderInstanceListResultPage{
		fn:   getNextPage,
		pilr: cur,
	}
}

// ProviderInstanceProperties describes the properties of a provider instance.
type ProviderInstanceProperties struct {
	// ProvisioningState - READ-ONLY; State of provisioning of the provider instance. Possible values include: 'WorkloadMonitorProvisioningStateAccepted', 'WorkloadMonitorProvisioningStateCreating', 'WorkloadMonitorProvisioningStateUpdating', 'WorkloadMonitorProvisioningStateFailed', 'WorkloadMonitorProvisioningStateSucceeded', 'WorkloadMonitorProvisioningStateDeleting', 'WorkloadMonitorProvisioningStateMigrating'
	ProvisioningState WorkloadMonitorProvisioningState `json:"provisioningState,omitempty"`
	// Errors - READ-ONLY; Defines the provider instance errors.
	Errors *ProviderInstancePropertiesErrors `json:"errors,omitempty"`
	// ProviderSettings - Defines the provider instance errors.
	ProviderSettings BasicProviderSpecificProperties `json:"providerSettings,omitempty"`
}

// MarshalJSON is the custom marshaler for ProviderInstanceProperties.
func (pip ProviderInstanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["providerSettings"] = pip.ProviderSettings
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for ProviderInstanceProperties struct.
func (pip *ProviderInstanceProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "provisioningState":
			if v != nil {
				var provisioningState WorkloadMonitorProvisioningState
				err = json.Unmarshal(*v, &provisioningState)
				if err != nil {
					return err
				}
				pip.ProvisioningState = provisioningState
			}
		case "errors":
			if v != nil {
				var errorsVar ProviderInstancePropertiesErrors
				err = json.Unmarshal(*v, &errorsVar)
				if err != nil {
					return err
				}
				pip.Errors = &errorsVar
			}
		case "providerSettings":
			if v != nil {
				providerSettings, err := unmarshalBasicProviderSpecificProperties(*v)
				if err != nil {
					return err
				}
				pip.ProviderSettings = providerSettings
			}
		}
	}

	return nil
}

// ProviderInstancePropertiesErrors defines the provider instance errors.
type ProviderInstancePropertiesErrors struct {
	// Code - READ-ONLY; Server-defined set of error codes.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; Human-readable representation of the error.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; Target of the error.
	Target *string `json:"target,omitempty"`
	// Details - READ-ONLY; Array of details about specific errors that led to this reported error.
	Details *[]Error `json:"details,omitempty"`
	// InnerError - READ-ONLY; Object containing more specific information than  the current object about the error.
	InnerError *ErrorInnerError `json:"innerError,omitempty"`
}

// MarshalJSON is the custom marshaler for ProviderInstancePropertiesErrors.
func (pip ProviderInstancePropertiesErrors) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ProviderInstancesCreateFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ProviderInstancesCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ProviderInstancesClient) (ProviderInstance, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ProviderInstancesCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ProviderInstancesCreateFuture.Result.
func (future *ProviderInstancesCreateFuture) result(client ProviderInstancesClient) (pi ProviderInstance, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.ProviderInstancesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		pi.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.ProviderInstancesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if pi.Response.Response, err = future.GetResult(sender); err == nil && pi.Response.Response.StatusCode != http.StatusNoContent {
		pi, err = client.CreateResponder(pi.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.ProviderInstancesCreateFuture", "Result", pi.Response.Response, "Failure responding to request")
		}
	}
	return
}

// ProviderInstancesDeleteFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type ProviderInstancesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(ProviderInstancesClient) (OperationStatusResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *ProviderInstancesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for ProviderInstancesDeleteFuture.Result.
func (future *ProviderInstancesDeleteFuture) result(client ProviderInstancesClient) (osr OperationStatusResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.ProviderInstancesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		osr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.ProviderInstancesDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if osr.Response.Response, err = future.GetResult(sender); err == nil && osr.Response.Response.StatusCode != http.StatusNoContent {
		osr, err = client.DeleteResponder(osr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.ProviderInstancesDeleteFuture", "Result", osr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// BasicProviderSpecificProperties gets or sets the provider specific properties.
type BasicProviderSpecificProperties interface {
	AsHanaDbProviderInstanceProperties() (*HanaDbProviderInstanceProperties, bool)
	AsSapNetWeaverProviderInstanceProperties() (*SapNetWeaverProviderInstanceProperties, bool)
	AsPrometheusOSProviderInstanceProperties() (*PrometheusOSProviderInstanceProperties, bool)
	AsDB2ProviderInstanceProperties() (*DB2ProviderInstanceProperties, bool)
	AsPrometheusHaClusterProviderInstanceProperties() (*PrometheusHaClusterProviderInstanceProperties, bool)
	AsMsSQLServerProviderInstanceProperties() (*MsSQLServerProviderInstanceProperties, bool)
	AsProviderSpecificProperties() (*ProviderSpecificProperties, bool)
}

// ProviderSpecificProperties gets or sets the provider specific properties.
type ProviderSpecificProperties struct {
	// ProviderType - Possible values include: 'ProviderTypeProviderSpecificProperties', 'ProviderTypeSapHana', 'ProviderTypeSapNetWeaver', 'ProviderTypePrometheusOS', 'ProviderTypeDb2', 'ProviderTypePrometheusHaCluster', 'ProviderTypeMsSQLServer'
	ProviderType ProviderType `json:"providerType,omitempty"`
}

func unmarshalBasicProviderSpecificProperties(body []byte) (BasicProviderSpecificProperties, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["providerType"] {
	case string(ProviderTypeSapHana):
		var hdpip HanaDbProviderInstanceProperties
		err := json.Unmarshal(body, &hdpip)
		return hdpip, err
	case string(ProviderTypeSapNetWeaver):
		var snwpip SapNetWeaverProviderInstanceProperties
		err := json.Unmarshal(body, &snwpip)
		return snwpip, err
	case string(ProviderTypePrometheusOS):
		var popip PrometheusOSProviderInstanceProperties
		err := json.Unmarshal(body, &popip)
		return popip, err
	case string(ProviderTypeDb2):
		var dpip DB2ProviderInstanceProperties
		err := json.Unmarshal(body, &dpip)
		return dpip, err
	case string(ProviderTypePrometheusHaCluster):
		var phcpip PrometheusHaClusterProviderInstanceProperties
		err := json.Unmarshal(body, &phcpip)
		return phcpip, err
	case string(ProviderTypeMsSQLServer):
		var msspip MsSQLServerProviderInstanceProperties
		err := json.Unmarshal(body, &msspip)
		return msspip, err
	default:
		var psp ProviderSpecificProperties
		err := json.Unmarshal(body, &psp)
		return psp, err
	}
}
func unmarshalBasicProviderSpecificPropertiesArray(body []byte) ([]BasicProviderSpecificProperties, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	pspArray := make([]BasicProviderSpecificProperties, len(rawMessages))

	for index, rawMessage := range rawMessages {
		psp, err := unmarshalBasicProviderSpecificProperties(*rawMessage)
		if err != nil {
			return nil, err
		}
		pspArray[index] = psp
	}
	return pspArray, nil
}

// MarshalJSON is the custom marshaler for ProviderSpecificProperties.
func (psp ProviderSpecificProperties) MarshalJSON() ([]byte, error) {
	psp.ProviderType = ProviderTypeProviderSpecificProperties
	objectMap := make(map[string]interface{})
	if psp.ProviderType != "" {
		objectMap["providerType"] = psp.ProviderType
	}
	return json.Marshal(objectMap)
}

// AsHanaDbProviderInstanceProperties is the BasicProviderSpecificProperties implementation for ProviderSpecificProperties.
func (psp ProviderSpecificProperties) AsHanaDbProviderInstanceProperties() (*HanaDbProviderInstanceProperties, bool) {
	return nil, false
}

// AsSapNetWeaverProviderInstanceProperties is the BasicProviderSpecificProperties implementation for ProviderSpecificProperties.
func (psp ProviderSpecificProperties) AsSapNetWeaverProviderInstanceProperties() (*SapNetWeaverProviderInstanceProperties, bool) {
	return nil, false
}

// AsPrometheusOSProviderInstanceProperties is the BasicProviderSpecificProperties implementation for ProviderSpecificProperties.
func (psp ProviderSpecificProperties) AsPrometheusOSProviderInstanceProperties() (*PrometheusOSProviderInstanceProperties, bool) {
	return nil, false
}

// AsDB2ProviderInstanceProperties is the BasicProviderSpecificProperties implementation for ProviderSpecificProperties.
func (psp ProviderSpecificProperties) AsDB2ProviderInstanceProperties() (*DB2ProviderInstanceProperties, bool) {
	return nil, false
}

// AsPrometheusHaClusterProviderInstanceProperties is the BasicProviderSpecificProperties implementation for ProviderSpecificProperties.
func (psp ProviderSpecificProperties) AsPrometheusHaClusterProviderInstanceProperties() (*PrometheusHaClusterProviderInstanceProperties, bool) {
	return nil, false
}

// AsMsSQLServerProviderInstanceProperties is the BasicProviderSpecificProperties implementation for ProviderSpecificProperties.
func (psp ProviderSpecificProperties) AsMsSQLServerProviderInstanceProperties() (*MsSQLServerProviderInstanceProperties, bool) {
	return nil, false
}

// AsProviderSpecificProperties is the BasicProviderSpecificProperties implementation for ProviderSpecificProperties.
func (psp ProviderSpecificProperties) AsProviderSpecificProperties() (*ProviderSpecificProperties, bool) {
	return &psp, true
}

// AsBasicProviderSpecificProperties is the BasicProviderSpecificProperties implementation for ProviderSpecificProperties.
func (psp ProviderSpecificProperties) AsBasicProviderSpecificProperties() (BasicProviderSpecificProperties, bool) {
	return &psp, true
}

// ProxyResource the resource model definition for a Azure Resource Manager proxy resource. It will not
// have tags and a location
type ProxyResource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for ProxyResource.
func (pr ProxyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Resource common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ResourceModelWithAllowedPropertySet the resource model definition containing the full set of allowed
// properties for a resource. Except properties bag, there cannot be a top level property outside of this
// set.
type ResourceModelWithAllowedPropertySet struct {
	// ManagedBy - The fully qualified resource ID of the resource that manages this resource. Indicates if this resource is managed by another Azure resource. If this is present, complete mode deployment will not delete the resource if it is removed from the template since it is managed by another resource.
	ManagedBy *string `json:"managedBy,omitempty"`
	// Kind - Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are a kind of Microsoft.Web/sites type.  If supported, the resource provider must validate and persist this value.
	Kind *string `json:"kind,omitempty"`
	// Etag - READ-ONLY; The etag field is *not* required. If it is provided in the response body, it must also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.
	Etag     *string                                      `json:"etag,omitempty"`
	Identity *ResourceModelWithAllowedPropertySetIdentity `json:"identity,omitempty"`
	Sku      *ResourceModelWithAllowedPropertySetSku      `json:"sku,omitempty"`
	Plan     *ResourceModelWithAllowedPropertySetPlan     `json:"plan,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceModelWithAllowedPropertySet.
func (rmwaps ResourceModelWithAllowedPropertySet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rmwaps.ManagedBy != nil {
		objectMap["managedBy"] = rmwaps.ManagedBy
	}
	if rmwaps.Kind != nil {
		objectMap["kind"] = rmwaps.Kind
	}
	if rmwaps.Identity != nil {
		objectMap["identity"] = rmwaps.Identity
	}
	if rmwaps.Sku != nil {
		objectMap["sku"] = rmwaps.Sku
	}
	if rmwaps.Plan != nil {
		objectMap["plan"] = rmwaps.Plan
	}
	if rmwaps.Tags != nil {
		objectMap["tags"] = rmwaps.Tags
	}
	if rmwaps.Location != nil {
		objectMap["location"] = rmwaps.Location
	}
	return json.Marshal(objectMap)
}

// ResourceModelWithAllowedPropertySetIdentity ...
type ResourceModelWithAllowedPropertySetIdentity struct {
	// PrincipalID - READ-ONLY; The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty"`
	// Type - The identity type. Possible values include: 'SystemAssigned'
	Type ResourceIdentityType `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceModelWithAllowedPropertySetIdentity.
func (rmwaps ResourceModelWithAllowedPropertySetIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rmwaps.Type != "" {
		objectMap["type"] = rmwaps.Type
	}
	return json.Marshal(objectMap)
}

// ResourceModelWithAllowedPropertySetPlan ...
type ResourceModelWithAllowedPropertySetPlan struct {
	// Name - A user defined name of the 3rd Party Artifact that is being procured.
	Name *string `json:"name,omitempty"`
	// Publisher - The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
	Publisher *string `json:"publisher,omitempty"`
	// Product - The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding.
	Product *string `json:"product,omitempty"`
	// PromotionCode - A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
	PromotionCode *string `json:"promotionCode,omitempty"`
	// Version - The version of the desired product/artifact.
	Version *string `json:"version,omitempty"`
}

// ResourceModelWithAllowedPropertySetSku ...
type ResourceModelWithAllowedPropertySetSku struct {
	// Name - The name of the SKU. Ex - P3. It is typically a letter+number code
	Name *string `json:"name,omitempty"`
	// Tier - Possible values include: 'Free', 'Basic', 'Standard', 'Premium'
	Tier SkuTier `json:"tier,omitempty"`
	// Size - The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`
	// Family - If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`
	// Capacity - If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`
}

// RestrictionInfo the SKU restriction information.
type RestrictionInfo struct {
	// Locations - The restriction locations.
	Locations *[]string `json:"locations,omitempty"`
	// Zones - The restriction zones.
	Zones *[]string `json:"zones,omitempty"`
}

// SAPApplicationServerInstance define the SAP Application Server Instance.
type SAPApplicationServerInstance struct {
	autorest.Response               `json:"-"`
	*SAPApplicationServerProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for SAPApplicationServerInstance.
func (sasi SAPApplicationServerInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sasi.SAPApplicationServerProperties != nil {
		objectMap["properties"] = sasi.SAPApplicationServerProperties
	}
	if sasi.Tags != nil {
		objectMap["tags"] = sasi.Tags
	}
	if sasi.Location != nil {
		objectMap["location"] = sasi.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SAPApplicationServerInstance struct.
func (sasi *SAPApplicationServerInstance) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var sAPApplicationServerProperties SAPApplicationServerProperties
				err = json.Unmarshal(*v, &sAPApplicationServerProperties)
				if err != nil {
					return err
				}
				sasi.SAPApplicationServerProperties = &sAPApplicationServerProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				sasi.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				sasi.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sasi.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sasi.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sasi.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				sasi.SystemData = &systemData
			}
		}
	}

	return nil
}

// SAPApplicationServerInstanceList defines the collection of SAP Application Server Instances.
type SAPApplicationServerInstanceList struct {
	autorest.Response `json:"-"`
	// Value - Gets the list of SAP Application Server instances.
	Value *[]SAPApplicationServerInstance `json:"value,omitempty"`
	// NextLink - Gets the value of next link.
	NextLink *string `json:"nextLink,omitempty"`
}

// SAPApplicationServerInstanceListIterator provides access to a complete listing of
// SAPApplicationServerInstance values.
type SAPApplicationServerInstanceListIterator struct {
	i    int
	page SAPApplicationServerInstanceListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SAPApplicationServerInstanceListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SAPApplicationServerInstanceListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SAPApplicationServerInstanceListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SAPApplicationServerInstanceListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SAPApplicationServerInstanceListIterator) Response() SAPApplicationServerInstanceList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SAPApplicationServerInstanceListIterator) Value() SAPApplicationServerInstance {
	if !iter.page.NotDone() {
		return SAPApplicationServerInstance{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SAPApplicationServerInstanceListIterator type.
func NewSAPApplicationServerInstanceListIterator(page SAPApplicationServerInstanceListPage) SAPApplicationServerInstanceListIterator {
	return SAPApplicationServerInstanceListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sasil SAPApplicationServerInstanceList) IsEmpty() bool {
	return sasil.Value == nil || len(*sasil.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (sasil SAPApplicationServerInstanceList) hasNextLink() bool {
	return sasil.NextLink != nil && len(*sasil.NextLink) != 0
}

// sAPApplicationServerInstanceListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sasil SAPApplicationServerInstanceList) sAPApplicationServerInstanceListPreparer(ctx context.Context) (*http.Request, error) {
	if !sasil.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sasil.NextLink)))
}

// SAPApplicationServerInstanceListPage contains a page of SAPApplicationServerInstance values.
type SAPApplicationServerInstanceListPage struct {
	fn    func(context.Context, SAPApplicationServerInstanceList) (SAPApplicationServerInstanceList, error)
	sasil SAPApplicationServerInstanceList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SAPApplicationServerInstanceListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SAPApplicationServerInstanceListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.sasil)
		if err != nil {
			return err
		}
		page.sasil = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SAPApplicationServerInstanceListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SAPApplicationServerInstanceListPage) NotDone() bool {
	return !page.sasil.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SAPApplicationServerInstanceListPage) Response() SAPApplicationServerInstanceList {
	return page.sasil
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SAPApplicationServerInstanceListPage) Values() []SAPApplicationServerInstance {
	if page.sasil.IsEmpty() {
		return nil
	}
	return *page.sasil.Value
}

// Creates a new instance of the SAPApplicationServerInstanceListPage type.
func NewSAPApplicationServerInstanceListPage(cur SAPApplicationServerInstanceList, getNextPage func(context.Context, SAPApplicationServerInstanceList) (SAPApplicationServerInstanceList, error)) SAPApplicationServerInstanceListPage {
	return SAPApplicationServerInstanceListPage{
		fn:    getNextPage,
		sasil: cur,
	}
}

// SAPApplicationServerInstancesCreateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SAPApplicationServerInstancesCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SAPApplicationServerInstancesClient) (SAPApplicationServerInstance, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SAPApplicationServerInstancesCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SAPApplicationServerInstancesCreateFuture.Result.
func (future *SAPApplicationServerInstancesCreateFuture) result(client SAPApplicationServerInstancesClient) (sasi SAPApplicationServerInstance, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.SAPApplicationServerInstancesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sasi.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.SAPApplicationServerInstancesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sasi.Response.Response, err = future.GetResult(sender); err == nil && sasi.Response.Response.StatusCode != http.StatusNoContent {
		sasi, err = client.CreateResponder(sasi.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.SAPApplicationServerInstancesCreateFuture", "Result", sasi.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SAPApplicationServerInstancesDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SAPApplicationServerInstancesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SAPApplicationServerInstancesClient) (OperationStatusResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SAPApplicationServerInstancesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SAPApplicationServerInstancesDeleteFuture.Result.
func (future *SAPApplicationServerInstancesDeleteFuture) result(client SAPApplicationServerInstancesClient) (osr OperationStatusResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.SAPApplicationServerInstancesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		osr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.SAPApplicationServerInstancesDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if osr.Response.Response, err = future.GetResult(sender); err == nil && osr.Response.Response.StatusCode != http.StatusNoContent {
		osr, err = client.DeleteResponder(osr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.SAPApplicationServerInstancesDeleteFuture", "Result", osr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SAPApplicationServerInstancesUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SAPApplicationServerInstancesUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SAPApplicationServerInstancesClient) (SAPApplicationServerInstance, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SAPApplicationServerInstancesUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SAPApplicationServerInstancesUpdateFuture.Result.
func (future *SAPApplicationServerInstancesUpdateFuture) result(client SAPApplicationServerInstancesClient) (sasi SAPApplicationServerInstance, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.SAPApplicationServerInstancesUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sasi.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.SAPApplicationServerInstancesUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sasi.Response.Response, err = future.GetResult(sender); err == nil && sasi.Response.Response.StatusCode != http.StatusNoContent {
		sasi, err = client.UpdateResponder(sasi.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.SAPApplicationServerInstancesUpdateFuture", "Result", sasi.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SAPApplicationServerProperties defines the SAP Application Server properties.
type SAPApplicationServerProperties struct {
	// InstanceNo - READ-ONLY; The application server instance id.
	InstanceNo *string `json:"instanceNo,omitempty"`
	// Subnet - READ-ONLY; The application server subnet.
	Subnet *string `json:"subnet,omitempty"`
	// Hostname - READ-ONLY; The application server SAP host name.
	Hostname *string `json:"hostname,omitempty"`
	// KernelVersion - READ-ONLY; The application server SAP kernel version.
	KernelVersion *string `json:"kernelVersion,omitempty"`
	// KernelPatch - READ-ONLY; The application server SAP kernel patch.
	KernelPatch *string `json:"kernelPatch,omitempty"`
	// IPAddress - READ-ONLY; The application server SAP IP Address.
	IPAddress *string `json:"ipAddress,omitempty"`
	// GatewayPort - READ-ONLY; The application server gateway Port.
	GatewayPort *int64 `json:"gatewayPort,omitempty"`
	// IcmHTTPPort - READ-ONLY; The application server ICM HTTP Port.
	IcmHTTPPort *int64 `json:"icmHttpPort,omitempty"`
	// IcmHTTPSPort - READ-ONLY; The application server ICM HTTPS Port.
	IcmHTTPSPort *int64 `json:"icmHttpsPort,omitempty"`
	// VirtualMachineID - READ-ONLY; The virtual machine.
	VirtualMachineID *string `json:"virtualMachineId,omitempty"`
	// Status - READ-ONLY; Possible values include: 'Starting', 'Running', 'Stopping', 'Offline', 'PartiallyRunning', 'Unavailable'
	Status SAPVirtualInstanceStatus `json:"status,omitempty"`
	// Health - READ-ONLY; Possible values include: 'SAPHealthStateUnknown', 'SAPHealthStateHealthy', 'SAPHealthStateUnhealthy', 'SAPHealthStateDegraded'
	Health SAPHealthState `json:"health,omitempty"`
	// ProvisioningState - READ-ONLY; Possible values include: 'SapVirtualInstanceProvisioningStateSucceeded', 'SapVirtualInstanceProvisioningStateUpdating', 'SapVirtualInstanceProvisioningStateCreating', 'SapVirtualInstanceProvisioningStateFailed', 'SapVirtualInstanceProvisioningStateDeleting'
	ProvisioningState SapVirtualInstanceProvisioningState `json:"provisioningState,omitempty"`
	// Errors - READ-ONLY; Defines the Application Instance errors.
	Errors *SAPVirtualInstanceError `json:"errors,omitempty"`
}

// MarshalJSON is the custom marshaler for SAPApplicationServerProperties.
func (sasp SAPApplicationServerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SAPAvailabilityZoneDetailsRequest the SAP request to get list of availability zones.
type SAPAvailabilityZoneDetailsRequest struct {
	// AppLocation - The geo-location where the SAP resources will be created.
	AppLocation *string `json:"appLocation,omitempty"`
	// SapProduct - Possible values include: 'ECC', 'S4HANA', 'Other'
	SapProduct SAPProductType `json:"sapProduct,omitempty"`
	// DatabaseType - The database type. Eg: HANA, DB2, etc. Possible values include: 'HANA', 'DB2'
	DatabaseType SAPDatabaseType `json:"databaseType,omitempty"`
}

// SAPAvailabilityZoneDetailsResult the list of supported availability zone pairs which are part of SAP HA
// deployment.
type SAPAvailabilityZoneDetailsResult struct {
	autorest.Response `json:"-"`
	// AvailabilityZonePairs - Gets the list of availability zone pairs.
	AvailabilityZonePairs *[]SAPAvailabilityZonePair `json:"availabilityZonePairs,omitempty"`
}

// SAPAvailabilityZonePair the SAP Availability Zone Pair.
type SAPAvailabilityZonePair struct {
	// ZoneA - The zone A.
	ZoneA *int64 `json:"zoneA,omitempty"`
	// ZoneB - The zone B.
	ZoneB *int64 `json:"zoneB,omitempty"`
}

// SAPCentralInstanceList defines the collection of SAP Central Instances.
type SAPCentralInstanceList struct {
	autorest.Response `json:"-"`
	// Value - Gets the list of SAP central instances.
	Value *[]SAPCentralServerInstance `json:"value,omitempty"`
	// NextLink - Gets the value of next link.
	NextLink *string `json:"nextLink,omitempty"`
}

// SAPCentralInstanceListIterator provides access to a complete listing of SAPCentralServerInstance values.
type SAPCentralInstanceListIterator struct {
	i    int
	page SAPCentralInstanceListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SAPCentralInstanceListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SAPCentralInstanceListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SAPCentralInstanceListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SAPCentralInstanceListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SAPCentralInstanceListIterator) Response() SAPCentralInstanceList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SAPCentralInstanceListIterator) Value() SAPCentralServerInstance {
	if !iter.page.NotDone() {
		return SAPCentralServerInstance{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SAPCentralInstanceListIterator type.
func NewSAPCentralInstanceListIterator(page SAPCentralInstanceListPage) SAPCentralInstanceListIterator {
	return SAPCentralInstanceListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (scil SAPCentralInstanceList) IsEmpty() bool {
	return scil.Value == nil || len(*scil.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (scil SAPCentralInstanceList) hasNextLink() bool {
	return scil.NextLink != nil && len(*scil.NextLink) != 0
}

// sAPCentralInstanceListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (scil SAPCentralInstanceList) sAPCentralInstanceListPreparer(ctx context.Context) (*http.Request, error) {
	if !scil.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(scil.NextLink)))
}

// SAPCentralInstanceListPage contains a page of SAPCentralServerInstance values.
type SAPCentralInstanceListPage struct {
	fn   func(context.Context, SAPCentralInstanceList) (SAPCentralInstanceList, error)
	scil SAPCentralInstanceList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SAPCentralInstanceListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SAPCentralInstanceListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.scil)
		if err != nil {
			return err
		}
		page.scil = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SAPCentralInstanceListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SAPCentralInstanceListPage) NotDone() bool {
	return !page.scil.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SAPCentralInstanceListPage) Response() SAPCentralInstanceList {
	return page.scil
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SAPCentralInstanceListPage) Values() []SAPCentralServerInstance {
	if page.scil.IsEmpty() {
		return nil
	}
	return *page.scil.Value
}

// Creates a new instance of the SAPCentralInstanceListPage type.
func NewSAPCentralInstanceListPage(cur SAPCentralInstanceList, getNextPage func(context.Context, SAPCentralInstanceList) (SAPCentralInstanceList, error)) SAPCentralInstanceListPage {
	return SAPCentralInstanceListPage{
		fn:   getNextPage,
		scil: cur,
	}
}

// SAPCentralInstancesCreateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SAPCentralInstancesCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SAPCentralInstancesClient) (SAPCentralServerInstance, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SAPCentralInstancesCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SAPCentralInstancesCreateFuture.Result.
func (future *SAPCentralInstancesCreateFuture) result(client SAPCentralInstancesClient) (scsi SAPCentralServerInstance, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.SAPCentralInstancesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		scsi.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.SAPCentralInstancesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if scsi.Response.Response, err = future.GetResult(sender); err == nil && scsi.Response.Response.StatusCode != http.StatusNoContent {
		scsi, err = client.CreateResponder(scsi.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.SAPCentralInstancesCreateFuture", "Result", scsi.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SAPCentralInstancesDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SAPCentralInstancesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SAPCentralInstancesClient) (OperationStatusResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SAPCentralInstancesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SAPCentralInstancesDeleteFuture.Result.
func (future *SAPCentralInstancesDeleteFuture) result(client SAPCentralInstancesClient) (osr OperationStatusResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.SAPCentralInstancesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		osr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.SAPCentralInstancesDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if osr.Response.Response, err = future.GetResult(sender); err == nil && osr.Response.Response.StatusCode != http.StatusNoContent {
		osr, err = client.DeleteResponder(osr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.SAPCentralInstancesDeleteFuture", "Result", osr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SAPCentralInstancesUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SAPCentralInstancesUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SAPCentralInstancesClient) (SAPCentralServerInstance, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SAPCentralInstancesUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SAPCentralInstancesUpdateFuture.Result.
func (future *SAPCentralInstancesUpdateFuture) result(client SAPCentralInstancesClient) (scsi SAPCentralServerInstance, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.SAPCentralInstancesUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		scsi.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.SAPCentralInstancesUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if scsi.Response.Response, err = future.GetResult(sender); err == nil && scsi.Response.Response.StatusCode != http.StatusNoContent {
		scsi, err = client.UpdateResponder(scsi.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.SAPCentralInstancesUpdateFuture", "Result", scsi.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SAPCentralServerInstance define the SAP Central Server Instance.
type SAPCentralServerInstance struct {
	autorest.Response           `json:"-"`
	*SAPCentralServerProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for SAPCentralServerInstance.
func (scsi SAPCentralServerInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if scsi.SAPCentralServerProperties != nil {
		objectMap["properties"] = scsi.SAPCentralServerProperties
	}
	if scsi.Tags != nil {
		objectMap["tags"] = scsi.Tags
	}
	if scsi.Location != nil {
		objectMap["location"] = scsi.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SAPCentralServerInstance struct.
func (scsi *SAPCentralServerInstance) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var sAPCentralServerProperties SAPCentralServerProperties
				err = json.Unmarshal(*v, &sAPCentralServerProperties)
				if err != nil {
					return err
				}
				scsi.SAPCentralServerProperties = &sAPCentralServerProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				scsi.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				scsi.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				scsi.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				scsi.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				scsi.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				scsi.SystemData = &systemData
			}
		}
	}

	return nil
}

// SAPCentralServerProperties defines the SAP Central Server properties.
type SAPCentralServerProperties struct {
	// InstanceNo - READ-ONLY; The central server instance id.
	InstanceNo *string `json:"instanceNo,omitempty"`
	// Subnet - READ-ONLY; The central server subnet.
	Subnet                             *string                             `json:"subnet,omitempty"`
	MessageServerProperties            *MessageServerProperties            `json:"messageServerProperties,omitempty"`
	EnqueueServerProperties            *EnqueueServerProperties            `json:"enqueueServerProperties,omitempty"`
	GatewayServerProperties            *GatewayServerProperties            `json:"gatewayServerProperties,omitempty"`
	EnqueueReplicationServerProperties *EnqueueReplicationServerProperties `json:"enqueueReplicationServerProperties,omitempty"`
	// KernelVersion - READ-ONLY; The central server kernel version.
	KernelVersion *string `json:"kernelVersion,omitempty"`
	// KernelPatch - READ-ONLY; The central server kernel patch.
	KernelPatch *string `json:"kernelPatch,omitempty"`
	// VMDetails - READ-ONLY; The list of virtual machines.
	VMDetails *[]CentralServerVMDetails `json:"vmDetails,omitempty"`
	// Status - READ-ONLY; Possible values include: 'Starting', 'Running', 'Stopping', 'Offline', 'PartiallyRunning', 'Unavailable'
	Status SAPVirtualInstanceStatus `json:"status,omitempty"`
	// Health - READ-ONLY; Possible values include: 'SAPHealthStateUnknown', 'SAPHealthStateHealthy', 'SAPHealthStateUnhealthy', 'SAPHealthStateDegraded'
	Health SAPHealthState `json:"health,omitempty"`
	// ProvisioningState - READ-ONLY; Possible values include: 'SapVirtualInstanceProvisioningStateSucceeded', 'SapVirtualInstanceProvisioningStateUpdating', 'SapVirtualInstanceProvisioningStateCreating', 'SapVirtualInstanceProvisioningStateFailed', 'SapVirtualInstanceProvisioningStateDeleting'
	ProvisioningState SapVirtualInstanceProvisioningState `json:"provisioningState,omitempty"`
	// Errors - READ-ONLY; Defines the Central Instance errors.
	Errors *SAPVirtualInstanceError `json:"errors,omitempty"`
}

// MarshalJSON is the custom marshaler for SAPCentralServerProperties.
func (scsp SAPCentralServerProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if scsp.MessageServerProperties != nil {
		objectMap["messageServerProperties"] = scsp.MessageServerProperties
	}
	if scsp.EnqueueServerProperties != nil {
		objectMap["enqueueServerProperties"] = scsp.EnqueueServerProperties
	}
	if scsp.GatewayServerProperties != nil {
		objectMap["gatewayServerProperties"] = scsp.GatewayServerProperties
	}
	if scsp.EnqueueReplicationServerProperties != nil {
		objectMap["enqueueReplicationServerProperties"] = scsp.EnqueueReplicationServerProperties
	}
	return json.Marshal(objectMap)
}

// BasicSAPConfiguration the SAP Configuration.
type BasicSAPConfiguration interface {
	AsDiscoveryConfiguration() (*DiscoveryConfiguration, bool)
	AsDeploymentConfiguration() (*DeploymentConfiguration, bool)
	AsDeploymentWithOSConfiguration() (*DeploymentWithOSConfiguration, bool)
	AsSAPConfiguration() (*SAPConfiguration, bool)
}

// SAPConfiguration the SAP Configuration.
type SAPConfiguration struct {
	// ConfigurationType - Possible values include: 'ConfigurationTypeSAPConfiguration', 'ConfigurationTypeDiscovery', 'ConfigurationTypeDeployment', 'ConfigurationTypeDeploymentWithOSConfig'
	ConfigurationType ConfigurationType `json:"configurationType,omitempty"`
}

func unmarshalBasicSAPConfiguration(body []byte) (BasicSAPConfiguration, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["configurationType"] {
	case string(ConfigurationTypeDiscovery):
		var dc DiscoveryConfiguration
		err := json.Unmarshal(body, &dc)
		return dc, err
	case string(ConfigurationTypeDeployment):
		var dc DeploymentConfiguration
		err := json.Unmarshal(body, &dc)
		return dc, err
	case string(ConfigurationTypeDeploymentWithOSConfig):
		var dwoc DeploymentWithOSConfiguration
		err := json.Unmarshal(body, &dwoc)
		return dwoc, err
	default:
		var sc SAPConfiguration
		err := json.Unmarshal(body, &sc)
		return sc, err
	}
}
func unmarshalBasicSAPConfigurationArray(body []byte) ([]BasicSAPConfiguration, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	scArray := make([]BasicSAPConfiguration, len(rawMessages))

	for index, rawMessage := range rawMessages {
		sc, err := unmarshalBasicSAPConfiguration(*rawMessage)
		if err != nil {
			return nil, err
		}
		scArray[index] = sc
	}
	return scArray, nil
}

// MarshalJSON is the custom marshaler for SAPConfiguration.
func (sc SAPConfiguration) MarshalJSON() ([]byte, error) {
	sc.ConfigurationType = ConfigurationTypeSAPConfiguration
	objectMap := make(map[string]interface{})
	if sc.ConfigurationType != "" {
		objectMap["configurationType"] = sc.ConfigurationType
	}
	return json.Marshal(objectMap)
}

// AsDiscoveryConfiguration is the BasicSAPConfiguration implementation for SAPConfiguration.
func (sc SAPConfiguration) AsDiscoveryConfiguration() (*DiscoveryConfiguration, bool) {
	return nil, false
}

// AsDeploymentConfiguration is the BasicSAPConfiguration implementation for SAPConfiguration.
func (sc SAPConfiguration) AsDeploymentConfiguration() (*DeploymentConfiguration, bool) {
	return nil, false
}

// AsDeploymentWithOSConfiguration is the BasicSAPConfiguration implementation for SAPConfiguration.
func (sc SAPConfiguration) AsDeploymentWithOSConfiguration() (*DeploymentWithOSConfiguration, bool) {
	return nil, false
}

// AsSAPConfiguration is the BasicSAPConfiguration implementation for SAPConfiguration.
func (sc SAPConfiguration) AsSAPConfiguration() (*SAPConfiguration, bool) {
	return &sc, true
}

// AsBasicSAPConfiguration is the BasicSAPConfiguration implementation for SAPConfiguration.
func (sc SAPConfiguration) AsBasicSAPConfiguration() (BasicSAPConfiguration, bool) {
	return &sc, true
}

// SAPDatabaseInstance define the SAP Database Instance.
type SAPDatabaseInstance struct {
	autorest.Response      `json:"-"`
	*SAPDatabaseProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for SAPDatabaseInstance.
func (sdi SAPDatabaseInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sdi.SAPDatabaseProperties != nil {
		objectMap["properties"] = sdi.SAPDatabaseProperties
	}
	if sdi.Tags != nil {
		objectMap["tags"] = sdi.Tags
	}
	if sdi.Location != nil {
		objectMap["location"] = sdi.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SAPDatabaseInstance struct.
func (sdi *SAPDatabaseInstance) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var sAPDatabaseProperties SAPDatabaseProperties
				err = json.Unmarshal(*v, &sAPDatabaseProperties)
				if err != nil {
					return err
				}
				sdi.SAPDatabaseProperties = &sAPDatabaseProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				sdi.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				sdi.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				sdi.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				sdi.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				sdi.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				sdi.SystemData = &systemData
			}
		}
	}

	return nil
}

// SAPDatabaseInstanceList defines the collection of SAP Database Instances.
type SAPDatabaseInstanceList struct {
	autorest.Response `json:"-"`
	// Value - Gets the list of SAP Database instances.
	Value *[]SAPDatabaseInstance `json:"value,omitempty"`
	// NextLink - Gets the value of next link.
	NextLink *string `json:"nextLink,omitempty"`
}

// SAPDatabaseInstanceListIterator provides access to a complete listing of SAPDatabaseInstance values.
type SAPDatabaseInstanceListIterator struct {
	i    int
	page SAPDatabaseInstanceListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SAPDatabaseInstanceListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SAPDatabaseInstanceListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SAPDatabaseInstanceListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SAPDatabaseInstanceListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SAPDatabaseInstanceListIterator) Response() SAPDatabaseInstanceList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SAPDatabaseInstanceListIterator) Value() SAPDatabaseInstance {
	if !iter.page.NotDone() {
		return SAPDatabaseInstance{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SAPDatabaseInstanceListIterator type.
func NewSAPDatabaseInstanceListIterator(page SAPDatabaseInstanceListPage) SAPDatabaseInstanceListIterator {
	return SAPDatabaseInstanceListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (sdil SAPDatabaseInstanceList) IsEmpty() bool {
	return sdil.Value == nil || len(*sdil.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (sdil SAPDatabaseInstanceList) hasNextLink() bool {
	return sdil.NextLink != nil && len(*sdil.NextLink) != 0
}

// sAPDatabaseInstanceListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (sdil SAPDatabaseInstanceList) sAPDatabaseInstanceListPreparer(ctx context.Context) (*http.Request, error) {
	if !sdil.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(sdil.NextLink)))
}

// SAPDatabaseInstanceListPage contains a page of SAPDatabaseInstance values.
type SAPDatabaseInstanceListPage struct {
	fn   func(context.Context, SAPDatabaseInstanceList) (SAPDatabaseInstanceList, error)
	sdil SAPDatabaseInstanceList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SAPDatabaseInstanceListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SAPDatabaseInstanceListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.sdil)
		if err != nil {
			return err
		}
		page.sdil = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SAPDatabaseInstanceListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SAPDatabaseInstanceListPage) NotDone() bool {
	return !page.sdil.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SAPDatabaseInstanceListPage) Response() SAPDatabaseInstanceList {
	return page.sdil
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SAPDatabaseInstanceListPage) Values() []SAPDatabaseInstance {
	if page.sdil.IsEmpty() {
		return nil
	}
	return *page.sdil.Value
}

// Creates a new instance of the SAPDatabaseInstanceListPage type.
func NewSAPDatabaseInstanceListPage(cur SAPDatabaseInstanceList, getNextPage func(context.Context, SAPDatabaseInstanceList) (SAPDatabaseInstanceList, error)) SAPDatabaseInstanceListPage {
	return SAPDatabaseInstanceListPage{
		fn:   getNextPage,
		sdil: cur,
	}
}

// SAPDatabaseInstancesCreateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SAPDatabaseInstancesCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SAPDatabaseInstancesClient) (SAPDatabaseInstance, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SAPDatabaseInstancesCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SAPDatabaseInstancesCreateFuture.Result.
func (future *SAPDatabaseInstancesCreateFuture) result(client SAPDatabaseInstancesClient) (sdi SAPDatabaseInstance, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.SAPDatabaseInstancesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sdi.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.SAPDatabaseInstancesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sdi.Response.Response, err = future.GetResult(sender); err == nil && sdi.Response.Response.StatusCode != http.StatusNoContent {
		sdi, err = client.CreateResponder(sdi.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.SAPDatabaseInstancesCreateFuture", "Result", sdi.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SAPDatabaseInstancesDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SAPDatabaseInstancesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SAPDatabaseInstancesClient) (OperationStatusResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SAPDatabaseInstancesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SAPDatabaseInstancesDeleteFuture.Result.
func (future *SAPDatabaseInstancesDeleteFuture) result(client SAPDatabaseInstancesClient) (osr OperationStatusResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.SAPDatabaseInstancesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		osr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.SAPDatabaseInstancesDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if osr.Response.Response, err = future.GetResult(sender); err == nil && osr.Response.Response.StatusCode != http.StatusNoContent {
		osr, err = client.DeleteResponder(osr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.SAPDatabaseInstancesDeleteFuture", "Result", osr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SAPDatabaseInstancesUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SAPDatabaseInstancesUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SAPDatabaseInstancesClient) (SAPDatabaseInstance, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SAPDatabaseInstancesUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SAPDatabaseInstancesUpdateFuture.Result.
func (future *SAPDatabaseInstancesUpdateFuture) result(client SAPDatabaseInstancesClient) (sdi SAPDatabaseInstance, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.SAPDatabaseInstancesUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		sdi.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.SAPDatabaseInstancesUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if sdi.Response.Response, err = future.GetResult(sender); err == nil && sdi.Response.Response.StatusCode != http.StatusNoContent {
		sdi, err = client.UpdateResponder(sdi.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.SAPDatabaseInstancesUpdateFuture", "Result", sdi.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SAPDatabaseProperties defines the SAP Database properties.
type SAPDatabaseProperties struct {
	// Subnet - READ-ONLY; The database subnet.
	Subnet *string `json:"subnet,omitempty"`
	// DatabaseSid - READ-ONLY; The database SID.
	DatabaseSid *string `json:"databaseSid,omitempty"`
	// DatabaseType - READ-ONLY; The SAP database type.
	DatabaseType *string `json:"databaseType,omitempty"`
	// IPAddress - READ-ONLY; The database IP Address.
	IPAddress *string `json:"ipAddress,omitempty"`
	// VMDetails - READ-ONLY; The list of virtual machines.
	VMDetails *[]DatabaseVMDetails `json:"vmDetails,omitempty"`
	// Status - READ-ONLY; Possible values include: 'Starting', 'Running', 'Stopping', 'Offline', 'PartiallyRunning', 'Unavailable'
	Status SAPVirtualInstanceStatus `json:"status,omitempty"`
	// ProvisioningState - READ-ONLY; Possible values include: 'SapVirtualInstanceProvisioningStateSucceeded', 'SapVirtualInstanceProvisioningStateUpdating', 'SapVirtualInstanceProvisioningStateCreating', 'SapVirtualInstanceProvisioningStateFailed', 'SapVirtualInstanceProvisioningStateDeleting'
	ProvisioningState SapVirtualInstanceProvisioningState `json:"provisioningState,omitempty"`
	// Errors - READ-ONLY; Defines the Database Instance errors.
	Errors *SAPVirtualInstanceError `json:"errors,omitempty"`
}

// MarshalJSON is the custom marshaler for SAPDatabaseProperties.
func (sdp SAPDatabaseProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SAPDiskConfiguration the SAP Disk Configuration.
type SAPDiskConfiguration struct {
	// Volume - The volume name.
	Volume *string `json:"volume,omitempty"`
	// DiskType - The disk type.
	DiskType *string `json:"diskType,omitempty"`
	// DiskCount - The disk count.
	DiskCount *int64 `json:"diskCount,omitempty"`
	// DiskSizeGB - The disk size in GB.
	DiskSizeGB *int64 `json:"diskSizeGB,omitempty"`
	// DiskIopsReadWrite - The disk Iops.
	DiskIopsReadWrite *int64 `json:"diskIopsReadWrite,omitempty"`
	// DiskMBpsReadWrite - The disk provisioned throughput in MBps.
	DiskMBpsReadWrite *int64 `json:"diskMBpsReadWrite,omitempty"`
	// DiskStorageType - The disk storage type
	DiskStorageType *string `json:"diskStorageType,omitempty"`
}

// SAPDiskConfigurationsRequest the SAP request to get list of disk configurations.
type SAPDiskConfigurationsRequest struct {
	// AppLocation - The geo-location where the SAP resources will be created.
	AppLocation *string `json:"appLocation,omitempty"`
	// Environment - Possible values include: 'NonProd', 'Prod'
	Environment SAPEnvironmentType `json:"environment,omitempty"`
	// SapProduct - Possible values include: 'ECC', 'S4HANA', 'Other'
	SapProduct SAPProductType `json:"sapProduct,omitempty"`
	// DatabaseType - The database type. Eg: HANA, DB2, etc. Possible values include: 'HANA', 'DB2'
	DatabaseType SAPDatabaseType `json:"databaseType,omitempty"`
	// DeploymentType - The deployment type. Eg: SingleServer/ThreeTier. Possible values include: 'SingleServer', 'ThreeTier'
	DeploymentType SAPDeploymentType `json:"deploymentType,omitempty"`
	// DbVMSku - The VM SKU for database instance.
	DbVMSku *string `json:"dbVmSku,omitempty"`
}

// SAPDiskConfigurationsResult the list of disk configuration for vmSku which are part of SAP deployment.
type SAPDiskConfigurationsResult struct {
	autorest.Response `json:"-"`
	// DiskConfigurations - Gets the list of Disk Configurations.
	DiskConfigurations *[]SAPDiskConfiguration `json:"diskConfigurations,omitempty"`
}

// SAPInstallWithoutOSConfigSoftwareConfiguration the SAP Software configuration Input when the software is
// to be installed by service without OS Configurations
type SAPInstallWithoutOSConfigSoftwareConfiguration struct {
	// BomURL - The URL to the SAP Build of Materials(BOM) file.
	BomURL *string `json:"bomUrl,omitempty"`
	// SapBitsStorageAccountID - The SAP bits storage account id.
	SapBitsStorageAccountID *string `json:"sapBitsStorageAccountId,omitempty"`
	// SoftwareVersion - The software version to install.
	SoftwareVersion                       *string                                `json:"softwareVersion,omitempty"`
	HighAvailabilitySoftwareConfiguration *HighAvailabilitySoftwareConfiguration `json:"highAvailabilitySoftwareConfiguration,omitempty"`
	// SoftwareInstallationType - Possible values include: 'SoftwareInstallationTypeSoftwareConfiguration', 'SoftwareInstallationTypeServiceInitiated', 'SoftwareInstallationTypeSAPInstallWithoutOSConfig'
	SoftwareInstallationType SoftwareInstallationType `json:"softwareInstallationType,omitempty"`
}

// MarshalJSON is the custom marshaler for SAPInstallWithoutOSConfigSoftwareConfiguration.
func (siwocsc SAPInstallWithoutOSConfigSoftwareConfiguration) MarshalJSON() ([]byte, error) {
	siwocsc.SoftwareInstallationType = SoftwareInstallationTypeSAPInstallWithoutOSConfig
	objectMap := make(map[string]interface{})
	if siwocsc.BomURL != nil {
		objectMap["bomUrl"] = siwocsc.BomURL
	}
	if siwocsc.SapBitsStorageAccountID != nil {
		objectMap["sapBitsStorageAccountId"] = siwocsc.SapBitsStorageAccountID
	}
	if siwocsc.SoftwareVersion != nil {
		objectMap["softwareVersion"] = siwocsc.SoftwareVersion
	}
	if siwocsc.HighAvailabilitySoftwareConfiguration != nil {
		objectMap["highAvailabilitySoftwareConfiguration"] = siwocsc.HighAvailabilitySoftwareConfiguration
	}
	if siwocsc.SoftwareInstallationType != "" {
		objectMap["softwareInstallationType"] = siwocsc.SoftwareInstallationType
	}
	return json.Marshal(objectMap)
}

// AsServiceInitiatedSoftwareConfiguration is the BasicSoftwareConfiguration implementation for SAPInstallWithoutOSConfigSoftwareConfiguration.
func (siwocsc SAPInstallWithoutOSConfigSoftwareConfiguration) AsServiceInitiatedSoftwareConfiguration() (*ServiceInitiatedSoftwareConfiguration, bool) {
	return nil, false
}

// AsSAPInstallWithoutOSConfigSoftwareConfiguration is the BasicSoftwareConfiguration implementation for SAPInstallWithoutOSConfigSoftwareConfiguration.
func (siwocsc SAPInstallWithoutOSConfigSoftwareConfiguration) AsSAPInstallWithoutOSConfigSoftwareConfiguration() (*SAPInstallWithoutOSConfigSoftwareConfiguration, bool) {
	return &siwocsc, true
}

// AsSoftwareConfiguration is the BasicSoftwareConfiguration implementation for SAPInstallWithoutOSConfigSoftwareConfiguration.
func (siwocsc SAPInstallWithoutOSConfigSoftwareConfiguration) AsSoftwareConfiguration() (*SoftwareConfiguration, bool) {
	return nil, false
}

// AsBasicSoftwareConfiguration is the BasicSoftwareConfiguration implementation for SAPInstallWithoutOSConfigSoftwareConfiguration.
func (siwocsc SAPInstallWithoutOSConfigSoftwareConfiguration) AsBasicSoftwareConfiguration() (BasicSoftwareConfiguration, bool) {
	return &siwocsc, true
}

// SapNetWeaverProviderInstanceProperties gets or sets the provider properties.
type SapNetWeaverProviderInstanceProperties struct {
	// SapSid - Gets or sets the SAP System Identifier
	SapSid *string `json:"sapSid,omitempty"`
	// SapHostname - Gets or sets the target virtual machine IP Address/FQDN.
	SapHostname *string `json:"sapHostname,omitempty"`
	// SapInstanceNr - Gets or sets the instance number of SAP NetWeaver.
	SapInstanceNr *string `json:"sapInstanceNr,omitempty"`
	// SapHostFileEntries - Gets or sets the list of HostFile Entries
	SapHostFileEntries *[]string `json:"sapHostFileEntries,omitempty"`
	// SapUsername - Gets or sets the SAP user name.
	SapUsername *string `json:"sapUsername,omitempty"`
	// SapPassword - Sets the SAP password.
	SapPassword *string `json:"sapPassword,omitempty"`
	// SapPasswordURI - Gets or sets the key vault URI to secret with the SAP password.
	SapPasswordURI *string `json:"sapPasswordUri,omitempty"`
	// SapClientID - Gets or sets the SAP Client ID.
	SapClientID *string `json:"sapClientId,omitempty"`
	// SapPortNumber - Gets or sets the SAP HTTP port number.
	SapPortNumber *string `json:"sapPortNumber,omitempty"`
	// SapSslCertificateURI - Gets or sets the blob URI to SSL certificate for the SAP system.
	SapSslCertificateURI *string `json:"sapSslCertificateUri,omitempty"`
	// ProviderType - Possible values include: 'ProviderTypeProviderSpecificProperties', 'ProviderTypeSapHana', 'ProviderTypeSapNetWeaver', 'ProviderTypePrometheusOS', 'ProviderTypeDb2', 'ProviderTypePrometheusHaCluster', 'ProviderTypeMsSQLServer'
	ProviderType ProviderType `json:"providerType,omitempty"`
}

// MarshalJSON is the custom marshaler for SapNetWeaverProviderInstanceProperties.
func (snwpip SapNetWeaverProviderInstanceProperties) MarshalJSON() ([]byte, error) {
	snwpip.ProviderType = ProviderTypeSapNetWeaver
	objectMap := make(map[string]interface{})
	if snwpip.SapSid != nil {
		objectMap["sapSid"] = snwpip.SapSid
	}
	if snwpip.SapHostname != nil {
		objectMap["sapHostname"] = snwpip.SapHostname
	}
	if snwpip.SapInstanceNr != nil {
		objectMap["sapInstanceNr"] = snwpip.SapInstanceNr
	}
	if snwpip.SapHostFileEntries != nil {
		objectMap["sapHostFileEntries"] = snwpip.SapHostFileEntries
	}
	if snwpip.SapUsername != nil {
		objectMap["sapUsername"] = snwpip.SapUsername
	}
	if snwpip.SapPassword != nil {
		objectMap["sapPassword"] = snwpip.SapPassword
	}
	if snwpip.SapPasswordURI != nil {
		objectMap["sapPasswordUri"] = snwpip.SapPasswordURI
	}
	if snwpip.SapClientID != nil {
		objectMap["sapClientId"] = snwpip.SapClientID
	}
	if snwpip.SapPortNumber != nil {
		objectMap["sapPortNumber"] = snwpip.SapPortNumber
	}
	if snwpip.SapSslCertificateURI != nil {
		objectMap["sapSslCertificateUri"] = snwpip.SapSslCertificateURI
	}
	if snwpip.ProviderType != "" {
		objectMap["providerType"] = snwpip.ProviderType
	}
	return json.Marshal(objectMap)
}

// AsHanaDbProviderInstanceProperties is the BasicProviderSpecificProperties implementation for SapNetWeaverProviderInstanceProperties.
func (snwpip SapNetWeaverProviderInstanceProperties) AsHanaDbProviderInstanceProperties() (*HanaDbProviderInstanceProperties, bool) {
	return nil, false
}

// AsSapNetWeaverProviderInstanceProperties is the BasicProviderSpecificProperties implementation for SapNetWeaverProviderInstanceProperties.
func (snwpip SapNetWeaverProviderInstanceProperties) AsSapNetWeaverProviderInstanceProperties() (*SapNetWeaverProviderInstanceProperties, bool) {
	return &snwpip, true
}

// AsPrometheusOSProviderInstanceProperties is the BasicProviderSpecificProperties implementation for SapNetWeaverProviderInstanceProperties.
func (snwpip SapNetWeaverProviderInstanceProperties) AsPrometheusOSProviderInstanceProperties() (*PrometheusOSProviderInstanceProperties, bool) {
	return nil, false
}

// AsDB2ProviderInstanceProperties is the BasicProviderSpecificProperties implementation for SapNetWeaverProviderInstanceProperties.
func (snwpip SapNetWeaverProviderInstanceProperties) AsDB2ProviderInstanceProperties() (*DB2ProviderInstanceProperties, bool) {
	return nil, false
}

// AsPrometheusHaClusterProviderInstanceProperties is the BasicProviderSpecificProperties implementation for SapNetWeaverProviderInstanceProperties.
func (snwpip SapNetWeaverProviderInstanceProperties) AsPrometheusHaClusterProviderInstanceProperties() (*PrometheusHaClusterProviderInstanceProperties, bool) {
	return nil, false
}

// AsMsSQLServerProviderInstanceProperties is the BasicProviderSpecificProperties implementation for SapNetWeaverProviderInstanceProperties.
func (snwpip SapNetWeaverProviderInstanceProperties) AsMsSQLServerProviderInstanceProperties() (*MsSQLServerProviderInstanceProperties, bool) {
	return nil, false
}

// AsProviderSpecificProperties is the BasicProviderSpecificProperties implementation for SapNetWeaverProviderInstanceProperties.
func (snwpip SapNetWeaverProviderInstanceProperties) AsProviderSpecificProperties() (*ProviderSpecificProperties, bool) {
	return nil, false
}

// AsBasicProviderSpecificProperties is the BasicProviderSpecificProperties implementation for SapNetWeaverProviderInstanceProperties.
func (snwpip SapNetWeaverProviderInstanceProperties) AsBasicProviderSpecificProperties() (BasicProviderSpecificProperties, bool) {
	return &snwpip, true
}

// SAPSizingRecommendationRequest the SAP Sizing Recommendation request.
type SAPSizingRecommendationRequest struct {
	// AppLocation - The geo-location where the resource is to be created.
	AppLocation *string `json:"appLocation,omitempty"`
	// Environment - Possible values include: 'NonProd', 'Prod'
	Environment SAPEnvironmentType `json:"environment,omitempty"`
	// SapProduct - Possible values include: 'ECC', 'S4HANA', 'Other'
	SapProduct SAPProductType `json:"sapProduct,omitempty"`
	// DeploymentType - The deployment type. Eg: SingleServer/ThreeTier. Possible values include: 'SingleServer', 'ThreeTier'
	DeploymentType SAPDeploymentType `json:"deploymentType,omitempty"`
	// Saps - The SAP Application Performance Standard measurement.
	Saps *int64 `json:"saps,omitempty"`
	// DbMemory - The database memory configuration.
	DbMemory *int64 `json:"dbMemory,omitempty"`
	// DatabaseType - The database type. Possible values include: 'HANA', 'DB2'
	DatabaseType SAPDatabaseType `json:"databaseType,omitempty"`
	// DbScaleMethod - The DB scale method. Possible values include: 'ScaleUp'
	DbScaleMethod SAPDatabaseScaleMethod `json:"dbScaleMethod,omitempty"`
	// HighAvailabilityType - The high availability type. Possible values include: 'AvailabilitySet', 'AvailabilityZone'
	HighAvailabilityType SAPHighAvailabilityType `json:"highAvailabilityType,omitempty"`
}

// BasicSAPSizingRecommendationResult the SAP sizing recommendation result.
type BasicSAPSizingRecommendationResult interface {
	AsSingleServerRecommendationResult() (*SingleServerRecommendationResult, bool)
	AsThreeTierRecommendationResult() (*ThreeTierRecommendationResult, bool)
	AsSAPSizingRecommendationResult() (*SAPSizingRecommendationResult, bool)
}

// SAPSizingRecommendationResult the SAP sizing recommendation result.
type SAPSizingRecommendationResult struct {
	autorest.Response `json:"-"`
	// DeploymentType - Possible values include: 'DeploymentTypeSAPSizingRecommendationResult', 'DeploymentTypeSingleServer', 'DeploymentTypeThreeTier'
	DeploymentType DeploymentType `json:"deploymentType,omitempty"`
}

func unmarshalBasicSAPSizingRecommendationResult(body []byte) (BasicSAPSizingRecommendationResult, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["deploymentType"] {
	case string(DeploymentTypeSingleServer):
		var ssrr SingleServerRecommendationResult
		err := json.Unmarshal(body, &ssrr)
		return ssrr, err
	case string(DeploymentTypeThreeTier):
		var ttrr ThreeTierRecommendationResult
		err := json.Unmarshal(body, &ttrr)
		return ttrr, err
	default:
		var ssrr SAPSizingRecommendationResult
		err := json.Unmarshal(body, &ssrr)
		return ssrr, err
	}
}
func unmarshalBasicSAPSizingRecommendationResultArray(body []byte) ([]BasicSAPSizingRecommendationResult, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	ssrrArray := make([]BasicSAPSizingRecommendationResult, len(rawMessages))

	for index, rawMessage := range rawMessages {
		ssrr, err := unmarshalBasicSAPSizingRecommendationResult(*rawMessage)
		if err != nil {
			return nil, err
		}
		ssrrArray[index] = ssrr
	}
	return ssrrArray, nil
}

// MarshalJSON is the custom marshaler for SAPSizingRecommendationResult.
func (ssrr SAPSizingRecommendationResult) MarshalJSON() ([]byte, error) {
	ssrr.DeploymentType = DeploymentTypeSAPSizingRecommendationResult
	objectMap := make(map[string]interface{})
	if ssrr.DeploymentType != "" {
		objectMap["deploymentType"] = ssrr.DeploymentType
	}
	return json.Marshal(objectMap)
}

// AsSingleServerRecommendationResult is the BasicSAPSizingRecommendationResult implementation for SAPSizingRecommendationResult.
func (ssrr SAPSizingRecommendationResult) AsSingleServerRecommendationResult() (*SingleServerRecommendationResult, bool) {
	return nil, false
}

// AsThreeTierRecommendationResult is the BasicSAPSizingRecommendationResult implementation for SAPSizingRecommendationResult.
func (ssrr SAPSizingRecommendationResult) AsThreeTierRecommendationResult() (*ThreeTierRecommendationResult, bool) {
	return nil, false
}

// AsSAPSizingRecommendationResult is the BasicSAPSizingRecommendationResult implementation for SAPSizingRecommendationResult.
func (ssrr SAPSizingRecommendationResult) AsSAPSizingRecommendationResult() (*SAPSizingRecommendationResult, bool) {
	return &ssrr, true
}

// AsBasicSAPSizingRecommendationResult is the BasicSAPSizingRecommendationResult implementation for SAPSizingRecommendationResult.
func (ssrr SAPSizingRecommendationResult) AsBasicSAPSizingRecommendationResult() (BasicSAPSizingRecommendationResult, bool) {
	return &ssrr, true
}

// SAPSizingRecommendationResultModel ...
type SAPSizingRecommendationResultModel struct {
	autorest.Response `json:"-"`
	Value             BasicSAPSizingRecommendationResult `json:"value,omitempty"`
}

// UnmarshalJSON is the custom unmarshaler for SAPSizingRecommendationResultModel struct.
func (ssrrm *SAPSizingRecommendationResultModel) UnmarshalJSON(body []byte) error {
	ssrr, err := unmarshalBasicSAPSizingRecommendationResult(body)
	if err != nil {
		return err
	}
	ssrrm.Value = ssrr

	return nil
}

// SAPSupportedResourceSkusResult the list of supported SKUs for different resources which are part of SAP
// deployment.
type SAPSupportedResourceSkusResult struct {
	autorest.Response `json:"-"`
	// SupportedSkus - Gets the list of SAP supported SKUs.
	SupportedSkus *[]SAPSupportedSku `json:"supportedSkus,omitempty"`
}

// SAPSupportedSku the SAP supported SKU.
type SAPSupportedSku struct {
	// VMSku - The VM Sku.
	VMSku *string `json:"vmSku,omitempty"`
	// IsAppServerCertified - True if the Sku is certified for App server in the SAP system.
	IsAppServerCertified *bool `json:"isAppServerCertified,omitempty"`
	// IsDatabaseCertified - True if the Sku is certified for Database server in the SAP system.
	IsDatabaseCertified *bool `json:"isDatabaseCertified,omitempty"`
}

// SAPSupportedSkusRequest the SAP request to get list of supported SKUs.
type SAPSupportedSkusRequest struct {
	// AppLocation - The geo-location where the resource is to be created.
	AppLocation *string `json:"appLocation,omitempty"`
	// Environment - Possible values include: 'NonProd', 'Prod'
	Environment SAPEnvironmentType `json:"environment,omitempty"`
	// SapProduct - Possible values include: 'ECC', 'S4HANA', 'Other'
	SapProduct SAPProductType `json:"sapProduct,omitempty"`
	// DeploymentType - The deployment type. Eg: SingleServer/ThreeTier. Possible values include: 'SingleServer', 'ThreeTier'
	DeploymentType SAPDeploymentType `json:"deploymentType,omitempty"`
	// DatabaseType - The database type. Eg: HANA, DB2, etc. Possible values include: 'HANA', 'DB2'
	DatabaseType SAPDatabaseType `json:"databaseType,omitempty"`
	// HighAvailabilityType - The high availability type. Possible values include: 'AvailabilitySet', 'AvailabilityZone'
	HighAvailabilityType SAPHighAvailabilityType `json:"highAvailabilityType,omitempty"`
}

// SAPVirtualInstance define the Virtual Instance for SAP.
type SAPVirtualInstance struct {
	autorest.Response             `json:"-"`
	Identity                      *UserAssignedServiceIdentity `json:"identity,omitempty"`
	*SAPVirtualInstanceProperties `json:"properties,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for SAPVirtualInstance.
func (svi SAPVirtualInstance) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if svi.Identity != nil {
		objectMap["identity"] = svi.Identity
	}
	if svi.SAPVirtualInstanceProperties != nil {
		objectMap["properties"] = svi.SAPVirtualInstanceProperties
	}
	if svi.Tags != nil {
		objectMap["tags"] = svi.Tags
	}
	if svi.Location != nil {
		objectMap["location"] = svi.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SAPVirtualInstance struct.
func (svi *SAPVirtualInstance) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "identity":
			if v != nil {
				var identity UserAssignedServiceIdentity
				err = json.Unmarshal(*v, &identity)
				if err != nil {
					return err
				}
				svi.Identity = &identity
			}
		case "properties":
			if v != nil {
				var sAPVirtualInstanceProperties SAPVirtualInstanceProperties
				err = json.Unmarshal(*v, &sAPVirtualInstanceProperties)
				if err != nil {
					return err
				}
				svi.SAPVirtualInstanceProperties = &sAPVirtualInstanceProperties
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				svi.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				svi.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				svi.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				svi.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				svi.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				svi.SystemData = &systemData
			}
		}
	}

	return nil
}

// SAPVirtualInstanceError an error response from the Virtual Instance for SAP Workload service.
type SAPVirtualInstanceError struct {
	// Properties - The Virtual Instance for SAP error body.
	Properties *ErrorDefinition `json:"properties,omitempty"`
}

// SAPVirtualInstanceList defines the collection of Virtual Instance for SAP.
type SAPVirtualInstanceList struct {
	autorest.Response `json:"-"`
	// Value - Gets the list of Virtual Instances for SAP.
	Value *[]SAPVirtualInstance `json:"value,omitempty"`
	// NextLink - Gets the value of next link.
	NextLink *string `json:"nextLink,omitempty"`
}

// SAPVirtualInstanceListIterator provides access to a complete listing of SAPVirtualInstance values.
type SAPVirtualInstanceListIterator struct {
	i    int
	page SAPVirtualInstanceListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SAPVirtualInstanceListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SAPVirtualInstanceListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SAPVirtualInstanceListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SAPVirtualInstanceListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SAPVirtualInstanceListIterator) Response() SAPVirtualInstanceList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SAPVirtualInstanceListIterator) Value() SAPVirtualInstance {
	if !iter.page.NotDone() {
		return SAPVirtualInstance{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SAPVirtualInstanceListIterator type.
func NewSAPVirtualInstanceListIterator(page SAPVirtualInstanceListPage) SAPVirtualInstanceListIterator {
	return SAPVirtualInstanceListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (svil SAPVirtualInstanceList) IsEmpty() bool {
	return svil.Value == nil || len(*svil.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (svil SAPVirtualInstanceList) hasNextLink() bool {
	return svil.NextLink != nil && len(*svil.NextLink) != 0
}

// sAPVirtualInstanceListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (svil SAPVirtualInstanceList) sAPVirtualInstanceListPreparer(ctx context.Context) (*http.Request, error) {
	if !svil.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(svil.NextLink)))
}

// SAPVirtualInstanceListPage contains a page of SAPVirtualInstance values.
type SAPVirtualInstanceListPage struct {
	fn   func(context.Context, SAPVirtualInstanceList) (SAPVirtualInstanceList, error)
	svil SAPVirtualInstanceList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SAPVirtualInstanceListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SAPVirtualInstanceListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.svil)
		if err != nil {
			return err
		}
		page.svil = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SAPVirtualInstanceListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SAPVirtualInstanceListPage) NotDone() bool {
	return !page.svil.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SAPVirtualInstanceListPage) Response() SAPVirtualInstanceList {
	return page.svil
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SAPVirtualInstanceListPage) Values() []SAPVirtualInstance {
	if page.svil.IsEmpty() {
		return nil
	}
	return *page.svil.Value
}

// Creates a new instance of the SAPVirtualInstanceListPage type.
func NewSAPVirtualInstanceListPage(cur SAPVirtualInstanceList, getNextPage func(context.Context, SAPVirtualInstanceList) (SAPVirtualInstanceList, error)) SAPVirtualInstanceListPage {
	return SAPVirtualInstanceListPage{
		fn:   getNextPage,
		svil: cur,
	}
}

// SAPVirtualInstanceProperties defines the Virtual Instance for SAP properties.
type SAPVirtualInstanceProperties struct {
	// Environment - Possible values include: 'NonProd', 'Prod'
	Environment SAPEnvironmentType `json:"environment,omitempty"`
	// SapProduct - Possible values include: 'ECC', 'S4HANA', 'Other'
	SapProduct SAPProductType `json:"sapProduct,omitempty"`
	// Configuration - Defines if an existing SAP system is being registered or a new SAP system is being created
	Configuration BasicSAPConfiguration `json:"configuration,omitempty"`
	// ManagedResourceGroupConfiguration - Managed resource group configuration
	ManagedResourceGroupConfiguration *ManagedRGConfiguration `json:"managedResourceGroupConfiguration,omitempty"`
	// Status - READ-ONLY; Possible values include: 'Starting', 'Running', 'Stopping', 'Offline', 'PartiallyRunning', 'Unavailable'
	Status SAPVirtualInstanceStatus `json:"status,omitempty"`
	// Health - READ-ONLY; Possible values include: 'SAPHealthStateUnknown', 'SAPHealthStateHealthy', 'SAPHealthStateUnhealthy', 'SAPHealthStateDegraded'
	Health SAPHealthState `json:"health,omitempty"`
	// State - READ-ONLY; Possible values include: 'InfrastructureDeploymentPending', 'InfrastructureDeploymentInProgress', 'InfrastructureDeploymentFailed', 'SoftwareInstallationPending', 'SoftwareInstallationInProgress', 'SoftwareInstallationFailed', 'DiscoveryPending', 'DiscoveryInProgress', 'DiscoveryFailed', 'RegistrationComplete'
	State SAPVirtualInstanceState `json:"state,omitempty"`
	// ProvisioningState - READ-ONLY; Possible values include: 'SapVirtualInstanceProvisioningStateSucceeded', 'SapVirtualInstanceProvisioningStateUpdating', 'SapVirtualInstanceProvisioningStateCreating', 'SapVirtualInstanceProvisioningStateFailed', 'SapVirtualInstanceProvisioningStateDeleting'
	ProvisioningState SapVirtualInstanceProvisioningState `json:"provisioningState,omitempty"`
	// Errors - READ-ONLY; Defines the Virtual Instance for SAP errors.
	Errors *SAPVirtualInstanceError `json:"errors,omitempty"`
}

// MarshalJSON is the custom marshaler for SAPVirtualInstanceProperties.
func (svip SAPVirtualInstanceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if svip.Environment != "" {
		objectMap["environment"] = svip.Environment
	}
	if svip.SapProduct != "" {
		objectMap["sapProduct"] = svip.SapProduct
	}
	objectMap["configuration"] = svip.Configuration
	if svip.ManagedResourceGroupConfiguration != nil {
		objectMap["managedResourceGroupConfiguration"] = svip.ManagedResourceGroupConfiguration
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for SAPVirtualInstanceProperties struct.
func (svip *SAPVirtualInstanceProperties) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "environment":
			if v != nil {
				var environment SAPEnvironmentType
				err = json.Unmarshal(*v, &environment)
				if err != nil {
					return err
				}
				svip.Environment = environment
			}
		case "sapProduct":
			if v != nil {
				var sapProduct SAPProductType
				err = json.Unmarshal(*v, &sapProduct)
				if err != nil {
					return err
				}
				svip.SapProduct = sapProduct
			}
		case "configuration":
			if v != nil {
				configuration, err := unmarshalBasicSAPConfiguration(*v)
				if err != nil {
					return err
				}
				svip.Configuration = configuration
			}
		case "managedResourceGroupConfiguration":
			if v != nil {
				var managedResourceGroupConfiguration ManagedRGConfiguration
				err = json.Unmarshal(*v, &managedResourceGroupConfiguration)
				if err != nil {
					return err
				}
				svip.ManagedResourceGroupConfiguration = &managedResourceGroupConfiguration
			}
		case "status":
			if v != nil {
				var status SAPVirtualInstanceStatus
				err = json.Unmarshal(*v, &status)
				if err != nil {
					return err
				}
				svip.Status = status
			}
		case "health":
			if v != nil {
				var health SAPHealthState
				err = json.Unmarshal(*v, &health)
				if err != nil {
					return err
				}
				svip.Health = health
			}
		case "state":
			if v != nil {
				var state SAPVirtualInstanceState
				err = json.Unmarshal(*v, &state)
				if err != nil {
					return err
				}
				svip.State = state
			}
		case "provisioningState":
			if v != nil {
				var provisioningState SapVirtualInstanceProvisioningState
				err = json.Unmarshal(*v, &provisioningState)
				if err != nil {
					return err
				}
				svip.ProvisioningState = provisioningState
			}
		case "errors":
			if v != nil {
				var errorsVar SAPVirtualInstanceError
				err = json.Unmarshal(*v, &errorsVar)
				if err != nil {
					return err
				}
				svip.Errors = &errorsVar
			}
		}
	}

	return nil
}

// SAPVirtualInstancesCreateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SAPVirtualInstancesCreateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SAPVirtualInstancesClient) (SAPVirtualInstance, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SAPVirtualInstancesCreateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SAPVirtualInstancesCreateFuture.Result.
func (future *SAPVirtualInstancesCreateFuture) result(client SAPVirtualInstancesClient) (svi SAPVirtualInstance, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.SAPVirtualInstancesCreateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		svi.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.SAPVirtualInstancesCreateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if svi.Response.Response, err = future.GetResult(sender); err == nil && svi.Response.Response.StatusCode != http.StatusNoContent {
		svi, err = client.CreateResponder(svi.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.SAPVirtualInstancesCreateFuture", "Result", svi.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SAPVirtualInstancesDeleteFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SAPVirtualInstancesDeleteFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SAPVirtualInstancesClient) (OperationStatusResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SAPVirtualInstancesDeleteFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SAPVirtualInstancesDeleteFuture.Result.
func (future *SAPVirtualInstancesDeleteFuture) result(client SAPVirtualInstancesClient) (osr OperationStatusResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.SAPVirtualInstancesDeleteFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		osr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.SAPVirtualInstancesDeleteFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if osr.Response.Response, err = future.GetResult(sender); err == nil && osr.Response.Response.StatusCode != http.StatusNoContent {
		osr, err = client.DeleteResponder(osr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.SAPVirtualInstancesDeleteFuture", "Result", osr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SAPVirtualInstancesStartFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type SAPVirtualInstancesStartFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SAPVirtualInstancesClient) (OperationStatusResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SAPVirtualInstancesStartFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SAPVirtualInstancesStartFuture.Result.
func (future *SAPVirtualInstancesStartFuture) result(client SAPVirtualInstancesClient) (osr OperationStatusResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.SAPVirtualInstancesStartFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		osr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.SAPVirtualInstancesStartFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if osr.Response.Response, err = future.GetResult(sender); err == nil && osr.Response.Response.StatusCode != http.StatusNoContent {
		osr, err = client.StartResponder(osr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.SAPVirtualInstancesStartFuture", "Result", osr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SAPVirtualInstancesStopFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type SAPVirtualInstancesStopFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(SAPVirtualInstancesClient) (OperationStatusResult, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *SAPVirtualInstancesStopFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for SAPVirtualInstancesStopFuture.Result.
func (future *SAPVirtualInstancesStopFuture) result(client SAPVirtualInstancesClient) (osr OperationStatusResult, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.SAPVirtualInstancesStopFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		osr.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.SAPVirtualInstancesStopFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if osr.Response.Response, err = future.GetResult(sender); err == nil && osr.Response.Response.StatusCode != http.StatusNoContent {
		osr, err = client.StopResponder(osr.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.SAPVirtualInstancesStopFuture", "Result", osr.Response.Response, "Failure responding to request")
		}
	}
	return
}

// SearchProfile search profile
type SearchProfile struct {
	// SearchType - Search type
	SearchType *string `json:"searchType,omitempty"`
	// Name - VM or VMSS name
	Name *string `json:"name,omitempty"`
	// NodeSku - VM SKU for node(s)
	NodeSku *string `json:"nodeSku,omitempty"`
	// OsImage - OS image used for creating the nodes
	OsImage *OsImageProfile `json:"osImage,omitempty"`
	// OsDisk - OS disk details
	OsDisk *DiskInfo `json:"osDisk,omitempty"`
	// DataDisks - Data disks details. This property is not in use right now
	DataDisks *[]DiskInfo `json:"dataDisks,omitempty"`
	// NodeResourceIds - READ-ONLY; VM/VMSS resource ARM Ids
	NodeResourceIds *[]string `json:"nodeResourceIds,omitempty"`
}

// MarshalJSON is the custom marshaler for SearchProfile.
func (sp SearchProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if sp.SearchType != nil {
		objectMap["searchType"] = sp.SearchType
	}
	if sp.Name != nil {
		objectMap["name"] = sp.Name
	}
	if sp.NodeSku != nil {
		objectMap["nodeSku"] = sp.NodeSku
	}
	if sp.OsImage != nil {
		objectMap["osImage"] = sp.OsImage
	}
	if sp.OsDisk != nil {
		objectMap["osDisk"] = sp.OsDisk
	}
	if sp.DataDisks != nil {
		objectMap["dataDisks"] = sp.DataDisks
	}
	return json.Marshal(objectMap)
}

// ServiceInitiatedSoftwareConfiguration the SAP Software configuration Input when the software is to be
// installed by service.
type ServiceInitiatedSoftwareConfiguration struct {
	// BomURL - The URL to the SAP Build of Materials(BOM) file.
	BomURL *string `json:"bomUrl,omitempty"`
	// SoftwareVersion - The software version to install.
	SoftwareVersion *string `json:"softwareVersion,omitempty"`
	// SapBitsStorageAccountID - The SAP bits storage account id.
	SapBitsStorageAccountID *string `json:"sapBitsStorageAccountId,omitempty"`
	// SapFqdn - The FQDN to set for the SAP system during install.
	SapFqdn *string `json:"sapFqdn,omitempty"`
	// SSHPrivateKey - The SSH private key.
	SSHPrivateKey                         *string                                `json:"sshPrivateKey,omitempty"`
	HighAvailabilitySoftwareConfiguration *HighAvailabilitySoftwareConfiguration `json:"highAvailabilitySoftwareConfiguration,omitempty"`
	// SoftwareInstallationType - Possible values include: 'SoftwareInstallationTypeSoftwareConfiguration', 'SoftwareInstallationTypeServiceInitiated', 'SoftwareInstallationTypeSAPInstallWithoutOSConfig'
	SoftwareInstallationType SoftwareInstallationType `json:"softwareInstallationType,omitempty"`
}

// MarshalJSON is the custom marshaler for ServiceInitiatedSoftwareConfiguration.
func (sisc ServiceInitiatedSoftwareConfiguration) MarshalJSON() ([]byte, error) {
	sisc.SoftwareInstallationType = SoftwareInstallationTypeServiceInitiated
	objectMap := make(map[string]interface{})
	if sisc.BomURL != nil {
		objectMap["bomUrl"] = sisc.BomURL
	}
	if sisc.SoftwareVersion != nil {
		objectMap["softwareVersion"] = sisc.SoftwareVersion
	}
	if sisc.SapBitsStorageAccountID != nil {
		objectMap["sapBitsStorageAccountId"] = sisc.SapBitsStorageAccountID
	}
	if sisc.SapFqdn != nil {
		objectMap["sapFqdn"] = sisc.SapFqdn
	}
	if sisc.SSHPrivateKey != nil {
		objectMap["sshPrivateKey"] = sisc.SSHPrivateKey
	}
	if sisc.HighAvailabilitySoftwareConfiguration != nil {
		objectMap["highAvailabilitySoftwareConfiguration"] = sisc.HighAvailabilitySoftwareConfiguration
	}
	if sisc.SoftwareInstallationType != "" {
		objectMap["softwareInstallationType"] = sisc.SoftwareInstallationType
	}
	return json.Marshal(objectMap)
}

// AsServiceInitiatedSoftwareConfiguration is the BasicSoftwareConfiguration implementation for ServiceInitiatedSoftwareConfiguration.
func (sisc ServiceInitiatedSoftwareConfiguration) AsServiceInitiatedSoftwareConfiguration() (*ServiceInitiatedSoftwareConfiguration, bool) {
	return &sisc, true
}

// AsSAPInstallWithoutOSConfigSoftwareConfiguration is the BasicSoftwareConfiguration implementation for ServiceInitiatedSoftwareConfiguration.
func (sisc ServiceInitiatedSoftwareConfiguration) AsSAPInstallWithoutOSConfigSoftwareConfiguration() (*SAPInstallWithoutOSConfigSoftwareConfiguration, bool) {
	return nil, false
}

// AsSoftwareConfiguration is the BasicSoftwareConfiguration implementation for ServiceInitiatedSoftwareConfiguration.
func (sisc ServiceInitiatedSoftwareConfiguration) AsSoftwareConfiguration() (*SoftwareConfiguration, bool) {
	return nil, false
}

// AsBasicSoftwareConfiguration is the BasicSoftwareConfiguration implementation for ServiceInitiatedSoftwareConfiguration.
func (sisc ServiceInitiatedSoftwareConfiguration) AsBasicSoftwareConfiguration() (BasicSoftwareConfiguration, bool) {
	return &sisc, true
}

// SingleServerConfiguration gets or sets the single server configuration.
type SingleServerConfiguration struct {
	// NetworkConfiguration - Network configuration for the server
	NetworkConfiguration *NetworkConfiguration `json:"networkConfiguration,omitempty"`
	// DatabaseType - The database type. Possible values include: 'HANA', 'DB2'
	DatabaseType SAPDatabaseType `json:"databaseType,omitempty"`
	// SubnetID - The subnet id.
	SubnetID *string `json:"subnetId,omitempty"`
	// VirtualMachineConfiguration - Gets or sets the virtual machine configuration.
	VirtualMachineConfiguration *VirtualMachineConfiguration `json:"virtualMachineConfiguration,omitempty"`
	// AppResourceGroup - The application resource group where SAP system resources will be deployed.
	AppResourceGroup *string `json:"appResourceGroup,omitempty"`
	// DeploymentType - Possible values include: 'DeploymentTypeBasicInfrastructureConfigurationDeploymentTypeInfrastructureConfiguration', 'DeploymentTypeBasicInfrastructureConfigurationDeploymentTypeSingleServer', 'DeploymentTypeBasicInfrastructureConfigurationDeploymentTypeThreeTier'
	DeploymentType DeploymentTypeBasicInfrastructureConfiguration `json:"deploymentType,omitempty"`
}

// MarshalJSON is the custom marshaler for SingleServerConfiguration.
func (ssc SingleServerConfiguration) MarshalJSON() ([]byte, error) {
	ssc.DeploymentType = DeploymentTypeBasicInfrastructureConfigurationDeploymentTypeSingleServer
	objectMap := make(map[string]interface{})
	if ssc.NetworkConfiguration != nil {
		objectMap["networkConfiguration"] = ssc.NetworkConfiguration
	}
	if ssc.DatabaseType != "" {
		objectMap["databaseType"] = ssc.DatabaseType
	}
	if ssc.SubnetID != nil {
		objectMap["subnetId"] = ssc.SubnetID
	}
	if ssc.VirtualMachineConfiguration != nil {
		objectMap["virtualMachineConfiguration"] = ssc.VirtualMachineConfiguration
	}
	if ssc.AppResourceGroup != nil {
		objectMap["appResourceGroup"] = ssc.AppResourceGroup
	}
	if ssc.DeploymentType != "" {
		objectMap["deploymentType"] = ssc.DeploymentType
	}
	return json.Marshal(objectMap)
}

// AsSingleServerConfiguration is the BasicInfrastructureConfiguration implementation for SingleServerConfiguration.
func (ssc SingleServerConfiguration) AsSingleServerConfiguration() (*SingleServerConfiguration, bool) {
	return &ssc, true
}

// AsThreeTierConfiguration is the BasicInfrastructureConfiguration implementation for SingleServerConfiguration.
func (ssc SingleServerConfiguration) AsThreeTierConfiguration() (*ThreeTierConfiguration, bool) {
	return nil, false
}

// AsInfrastructureConfiguration is the BasicInfrastructureConfiguration implementation for SingleServerConfiguration.
func (ssc SingleServerConfiguration) AsInfrastructureConfiguration() (*InfrastructureConfiguration, bool) {
	return nil, false
}

// AsBasicInfrastructureConfiguration is the BasicInfrastructureConfiguration implementation for SingleServerConfiguration.
func (ssc SingleServerConfiguration) AsBasicInfrastructureConfiguration() (BasicInfrastructureConfiguration, bool) {
	return &ssc, true
}

// SingleServerRecommendationResult the recommended configuration for a single server SAP system.
type SingleServerRecommendationResult struct {
	// VMSku - The recommended VM SKU for single server.
	VMSku *string `json:"vmSku,omitempty"`
	// DeploymentType - Possible values include: 'DeploymentTypeSAPSizingRecommendationResult', 'DeploymentTypeSingleServer', 'DeploymentTypeThreeTier'
	DeploymentType DeploymentType `json:"deploymentType,omitempty"`
}

// MarshalJSON is the custom marshaler for SingleServerRecommendationResult.
func (ssrr SingleServerRecommendationResult) MarshalJSON() ([]byte, error) {
	ssrr.DeploymentType = DeploymentTypeSingleServer
	objectMap := make(map[string]interface{})
	if ssrr.VMSku != nil {
		objectMap["vmSku"] = ssrr.VMSku
	}
	if ssrr.DeploymentType != "" {
		objectMap["deploymentType"] = ssrr.DeploymentType
	}
	return json.Marshal(objectMap)
}

// AsSingleServerRecommendationResult is the BasicSAPSizingRecommendationResult implementation for SingleServerRecommendationResult.
func (ssrr SingleServerRecommendationResult) AsSingleServerRecommendationResult() (*SingleServerRecommendationResult, bool) {
	return &ssrr, true
}

// AsThreeTierRecommendationResult is the BasicSAPSizingRecommendationResult implementation for SingleServerRecommendationResult.
func (ssrr SingleServerRecommendationResult) AsThreeTierRecommendationResult() (*ThreeTierRecommendationResult, bool) {
	return nil, false
}

// AsSAPSizingRecommendationResult is the BasicSAPSizingRecommendationResult implementation for SingleServerRecommendationResult.
func (ssrr SingleServerRecommendationResult) AsSAPSizingRecommendationResult() (*SAPSizingRecommendationResult, bool) {
	return nil, false
}

// AsBasicSAPSizingRecommendationResult is the BasicSAPSizingRecommendationResult implementation for SingleServerRecommendationResult.
func (ssrr SingleServerRecommendationResult) AsBasicSAPSizingRecommendationResult() (BasicSAPSizingRecommendationResult, bool) {
	return &ssrr, true
}

// SiteProfile workload website profile
type SiteProfile struct {
	// DomainName - Domain name for the application site URL
	DomainName *string `json:"domainName,omitempty"`
}

// Sku the resource model definition representing SKU
type Sku struct {
	// Name - The name of the SKU. Ex - P3. It is typically a letter+number code
	Name *string `json:"name,omitempty"`
	// Tier - Possible values include: 'Free', 'Basic', 'Standard', 'Premium'
	Tier SkuTier `json:"tier,omitempty"`
	// Size - The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`
	// Family - If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`
	// Capacity - If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`
}

// SkuCapability the SKU capability definition.
type SkuCapability struct {
	// Name - The capability name.
	Name *string `json:"name,omitempty"`
	// Value - The capability value.
	Value *string `json:"value,omitempty"`
}

// SkuCapacity the SKU capacity.
type SkuCapacity struct {
	// Minimum - Minimum capacity value.
	Minimum *int32 `json:"minimum,omitempty"`
	// Maximum - Maximum capacity value.
	Maximum *int32 `json:"maximum,omitempty"`
	// Default - Default capacity value.
	Default *int32 `json:"default,omitempty"`
	// ScaleType - Scale type of the SKU capacity. Possible values include: 'SkuScaleTypeNone', 'SkuScaleTypeManual', 'SkuScaleTypeAutomatic'
	ScaleType SkuScaleType `json:"scaleType,omitempty"`
}

// SkuCost the SKU cost definition.
type SkuCost struct {
	// MeterID - Billing meter id.
	MeterID *string `json:"meterId,omitempty"`
	// Quantity - The quantity.
	Quantity *int32 `json:"quantity,omitempty"`
	// ExtendedUnit - The extended unit.
	ExtendedUnit *string `json:"extendedUnit,omitempty"`
}

// SkuDefinition the SKU definition.
type SkuDefinition struct {
	// Name - The name of the SKU.
	Name *string `json:"name,omitempty"`
	// ResourceType - Resource type the SKU applicable for.
	ResourceType *string `json:"resourceType,omitempty"`
	// Tier - This field is required to be implemented by the Resource Provider if the service has more than one tier, but is not required on a PUT.
	Tier *string `json:"tier,omitempty"`
	// Size - The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`
	// Family - If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`
	// Kind - If the service has different kinds of hardware, for the same SKU, then that can be captured here.
	Kind *string `json:"kind,omitempty"`
	// Locations - List of locations where this SKU is available.
	Locations *[]string `json:"locations,omitempty"`
	// LocationInfo - List of locations where this SKU is available.
	LocationInfo *[]SkuLocationAndZones `json:"locationInfo,omitempty"`
	// Capacity - If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity interface{} `json:"capacity,omitempty"`
	// Costs - The SKU costs.
	Costs *[]SkuCost `json:"costs,omitempty"`
	// Capabilities - The SKU capabilities.
	Capabilities *[]SkuCapability `json:"capabilities,omitempty"`
	// Restrictions - The SKU restrictions.
	Restrictions *[]SkuRestriction `json:"restrictions,omitempty"`
}

// SkuLocationAndZones the SKU location and zone.
type SkuLocationAndZones struct {
	// Location - The location of the SKU.
	Location *string `json:"location,omitempty"`
	// Zones - The availability zones of SKU location.
	Zones *[]string `json:"zones,omitempty"`
	// ZoneDetails - The availability zone details of the SKU location.
	ZoneDetails *[]SkuZoneDetail `json:"zoneDetails,omitempty"`
	// ExtendedLocations - The extended locations of SKU.
	ExtendedLocations *[]string `json:"extendedLocations,omitempty"`
	// Type - Type of the extended location. Possible values include: 'Region', 'EdgeZone'
	Type LocationType `json:"type,omitempty"`
}

// SkuRestriction the SKU restriction definition.
type SkuRestriction struct {
	// Type - The SKU restriction type. Possible values include: 'SkuRestrictionTypeNotSpecified', 'SkuRestrictionTypeLocation', 'SkuRestrictionTypeZone'
	Type SkuRestrictionType `json:"type,omitempty"`
	// Values - Restriction values.
	Values *[]string `json:"values,omitempty"`
	// RestrictionInfo - The restriction information.
	RestrictionInfo interface{} `json:"restrictionInfo,omitempty"`
	// ReasonCode - The SKU restriction reason code. Possible values include: 'SkuRestrictionReasonCodeNotSpecified', 'SkuRestrictionReasonCodeQuotaID', 'SkuRestrictionReasonCodeNotAvailableForSubscription'
	ReasonCode SkuRestrictionReasonCode `json:"reasonCode,omitempty"`
}

// SkusListResult a list of SKUs supported by an Azure Resource Provider.
type SkusListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; List of SKUs supported by the resource provider
	Value *[]SkuDefinition `json:"value,omitempty"`
	// NextLink - READ-ONLY; URL to get the next set of SKU list results (if there are any).
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for SkusListResult.
func (slr SkusListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// SkusListResultIterator provides access to a complete listing of SkuDefinition values.
type SkusListResultIterator struct {
	i    int
	page SkusListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *SkusListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SkusListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *SkusListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter SkusListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter SkusListResultIterator) Response() SkusListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter SkusListResultIterator) Value() SkuDefinition {
	if !iter.page.NotDone() {
		return SkuDefinition{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the SkusListResultIterator type.
func NewSkusListResultIterator(page SkusListResultPage) SkusListResultIterator {
	return SkusListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (slr SkusListResult) IsEmpty() bool {
	return slr.Value == nil || len(*slr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (slr SkusListResult) hasNextLink() bool {
	return slr.NextLink != nil && len(*slr.NextLink) != 0
}

// skusListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (slr SkusListResult) skusListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !slr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(slr.NextLink)))
}

// SkusListResultPage contains a page of SkuDefinition values.
type SkusListResultPage struct {
	fn  func(context.Context, SkusListResult) (SkusListResult, error)
	slr SkusListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *SkusListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/SkusListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.slr)
		if err != nil {
			return err
		}
		page.slr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *SkusListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page SkusListResultPage) NotDone() bool {
	return !page.slr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page SkusListResultPage) Response() SkusListResult {
	return page.slr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page SkusListResultPage) Values() []SkuDefinition {
	if page.slr.IsEmpty() {
		return nil
	}
	return *page.slr.Value
}

// Creates a new instance of the SkusListResultPage type.
func NewSkusListResultPage(cur SkusListResult, getNextPage func(context.Context, SkusListResult) (SkusListResult, error)) SkusListResultPage {
	return SkusListResultPage{
		fn:  getNextPage,
		slr: cur,
	}
}

// SkuZoneDetail the SKU zone details.
type SkuZoneDetail struct {
	// Zones - The physical zones.
	Zones *[]string `json:"zones,omitempty"`
	// Capabilities - The capabilities.
	Capabilities *[]SkuCapability `json:"capabilities,omitempty"`
}

// BasicSoftwareConfiguration the SAP Software configuration Input.
type BasicSoftwareConfiguration interface {
	AsServiceInitiatedSoftwareConfiguration() (*ServiceInitiatedSoftwareConfiguration, bool)
	AsSAPInstallWithoutOSConfigSoftwareConfiguration() (*SAPInstallWithoutOSConfigSoftwareConfiguration, bool)
	AsSoftwareConfiguration() (*SoftwareConfiguration, bool)
}

// SoftwareConfiguration the SAP Software configuration Input.
type SoftwareConfiguration struct {
	// SoftwareInstallationType - Possible values include: 'SoftwareInstallationTypeSoftwareConfiguration', 'SoftwareInstallationTypeServiceInitiated', 'SoftwareInstallationTypeSAPInstallWithoutOSConfig'
	SoftwareInstallationType SoftwareInstallationType `json:"softwareInstallationType,omitempty"`
}

func unmarshalBasicSoftwareConfiguration(body []byte) (BasicSoftwareConfiguration, error) {
	var m map[string]interface{}
	err := json.Unmarshal(body, &m)
	if err != nil {
		return nil, err
	}

	switch m["softwareInstallationType"] {
	case string(SoftwareInstallationTypeServiceInitiated):
		var sisc ServiceInitiatedSoftwareConfiguration
		err := json.Unmarshal(body, &sisc)
		return sisc, err
	case string(SoftwareInstallationTypeSAPInstallWithoutOSConfig):
		var siwocsc SAPInstallWithoutOSConfigSoftwareConfiguration
		err := json.Unmarshal(body, &siwocsc)
		return siwocsc, err
	default:
		var sc SoftwareConfiguration
		err := json.Unmarshal(body, &sc)
		return sc, err
	}
}
func unmarshalBasicSoftwareConfigurationArray(body []byte) ([]BasicSoftwareConfiguration, error) {
	var rawMessages []*json.RawMessage
	err := json.Unmarshal(body, &rawMessages)
	if err != nil {
		return nil, err
	}

	scArray := make([]BasicSoftwareConfiguration, len(rawMessages))

	for index, rawMessage := range rawMessages {
		sc, err := unmarshalBasicSoftwareConfiguration(*rawMessage)
		if err != nil {
			return nil, err
		}
		scArray[index] = sc
	}
	return scArray, nil
}

// MarshalJSON is the custom marshaler for SoftwareConfiguration.
func (sc SoftwareConfiguration) MarshalJSON() ([]byte, error) {
	sc.SoftwareInstallationType = SoftwareInstallationTypeSoftwareConfiguration
	objectMap := make(map[string]interface{})
	if sc.SoftwareInstallationType != "" {
		objectMap["softwareInstallationType"] = sc.SoftwareInstallationType
	}
	return json.Marshal(objectMap)
}

// AsServiceInitiatedSoftwareConfiguration is the BasicSoftwareConfiguration implementation for SoftwareConfiguration.
func (sc SoftwareConfiguration) AsServiceInitiatedSoftwareConfiguration() (*ServiceInitiatedSoftwareConfiguration, bool) {
	return nil, false
}

// AsSAPInstallWithoutOSConfigSoftwareConfiguration is the BasicSoftwareConfiguration implementation for SoftwareConfiguration.
func (sc SoftwareConfiguration) AsSAPInstallWithoutOSConfigSoftwareConfiguration() (*SAPInstallWithoutOSConfigSoftwareConfiguration, bool) {
	return nil, false
}

// AsSoftwareConfiguration is the BasicSoftwareConfiguration implementation for SoftwareConfiguration.
func (sc SoftwareConfiguration) AsSoftwareConfiguration() (*SoftwareConfiguration, bool) {
	return &sc, true
}

// AsBasicSoftwareConfiguration is the BasicSoftwareConfiguration implementation for SoftwareConfiguration.
func (sc SoftwareConfiguration) AsBasicSoftwareConfiguration() (BasicSoftwareConfiguration, bool) {
	return &sc, true
}

// SSHConfiguration SSH configuration for Linux based VMs running on Azure
type SSHConfiguration struct {
	// PublicKeys - The list of SSH public keys used to authenticate with linux based VMs.
	PublicKeys *[]SSHPublicKey `json:"publicKeys,omitempty"`
}

// SSHKeyPair the SSH Key-pair used to authenticate with the VM. The key needs to be at least 2048-bit and
// in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs
// in Azure](https://docs.microsoft.com/azure/virtual-machines/linux/create-ssh-keys-detailed).
type SSHKeyPair struct {
	// PublicKey - SSH public key
	PublicKey *string `json:"publicKey,omitempty"`
	// PrivateKey - SSH private key.
	PrivateKey *string `json:"privateKey,omitempty"`
}

// SSHPublicKey contains information about SSH certificate public key and the path on the Linux VM where
// the public key is placed.
type SSHPublicKey struct {
	// KeyData - SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/linux/create-ssh-keys-detailed).
	KeyData *string `json:"keyData,omitempty"`
}

// StopRequest stop SAP Request.
type StopRequest struct {
	// HardStop - A boolean to specify if the SAP system should be hard-stopped.
	HardStop *bool `json:"hardStop,omitempty"`
}

// SystemData metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// CreatedBy - The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByType - The type of identity that created the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	CreatedByType CreatedByType `json:"createdByType,omitempty"`
	// CreatedAt - The timestamp of resource creation (UTC).
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// LastModifiedBy - The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByType - The type of identity that last modified the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	LastModifiedByType CreatedByType `json:"lastModifiedByType,omitempty"`
	// LastModifiedAt - The timestamp of resource last modification (UTC)
	LastModifiedAt *date.Time `json:"lastModifiedAt,omitempty"`
}

// Tags tags field of the resource.
type Tags struct {
	// Tags - Tags field of the resource.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for Tags.
func (t Tags) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if t.Tags != nil {
		objectMap["tags"] = t.Tags
	}
	return json.Marshal(objectMap)
}

// ThreeTierConfiguration gets or sets the three tier SAP configuration.
type ThreeTierConfiguration struct {
	// NetworkConfiguration - Network configuration common to all servers
	NetworkConfiguration *NetworkConfiguration `json:"networkConfiguration,omitempty"`
	// CentralServer - The central server configuration.
	CentralServer *CentralServerConfiguration `json:"centralServer,omitempty"`
	// ApplicationServer - The application server configuration.
	ApplicationServer *ApplicationServerConfiguration `json:"applicationServer,omitempty"`
	// DatabaseServer - The database configuration.
	DatabaseServer *DatabaseConfiguration `json:"databaseServer,omitempty"`
	// HighAvailabilityConfig - The high availability configuration.
	HighAvailabilityConfig *HighAvailabilityConfiguration `json:"highAvailabilityConfig,omitempty"`
	// AppResourceGroup - The application resource group where SAP system resources will be deployed.
	AppResourceGroup *string `json:"appResourceGroup,omitempty"`
	// DeploymentType - Possible values include: 'DeploymentTypeBasicInfrastructureConfigurationDeploymentTypeInfrastructureConfiguration', 'DeploymentTypeBasicInfrastructureConfigurationDeploymentTypeSingleServer', 'DeploymentTypeBasicInfrastructureConfigurationDeploymentTypeThreeTier'
	DeploymentType DeploymentTypeBasicInfrastructureConfiguration `json:"deploymentType,omitempty"`
}

// MarshalJSON is the custom marshaler for ThreeTierConfiguration.
func (ttc ThreeTierConfiguration) MarshalJSON() ([]byte, error) {
	ttc.DeploymentType = DeploymentTypeBasicInfrastructureConfigurationDeploymentTypeThreeTier
	objectMap := make(map[string]interface{})
	if ttc.NetworkConfiguration != nil {
		objectMap["networkConfiguration"] = ttc.NetworkConfiguration
	}
	if ttc.CentralServer != nil {
		objectMap["centralServer"] = ttc.CentralServer
	}
	if ttc.ApplicationServer != nil {
		objectMap["applicationServer"] = ttc.ApplicationServer
	}
	if ttc.DatabaseServer != nil {
		objectMap["databaseServer"] = ttc.DatabaseServer
	}
	if ttc.HighAvailabilityConfig != nil {
		objectMap["highAvailabilityConfig"] = ttc.HighAvailabilityConfig
	}
	if ttc.AppResourceGroup != nil {
		objectMap["appResourceGroup"] = ttc.AppResourceGroup
	}
	if ttc.DeploymentType != "" {
		objectMap["deploymentType"] = ttc.DeploymentType
	}
	return json.Marshal(objectMap)
}

// AsSingleServerConfiguration is the BasicInfrastructureConfiguration implementation for ThreeTierConfiguration.
func (ttc ThreeTierConfiguration) AsSingleServerConfiguration() (*SingleServerConfiguration, bool) {
	return nil, false
}

// AsThreeTierConfiguration is the BasicInfrastructureConfiguration implementation for ThreeTierConfiguration.
func (ttc ThreeTierConfiguration) AsThreeTierConfiguration() (*ThreeTierConfiguration, bool) {
	return &ttc, true
}

// AsInfrastructureConfiguration is the BasicInfrastructureConfiguration implementation for ThreeTierConfiguration.
func (ttc ThreeTierConfiguration) AsInfrastructureConfiguration() (*InfrastructureConfiguration, bool) {
	return nil, false
}

// AsBasicInfrastructureConfiguration is the BasicInfrastructureConfiguration implementation for ThreeTierConfiguration.
func (ttc ThreeTierConfiguration) AsBasicInfrastructureConfiguration() (BasicInfrastructureConfiguration, bool) {
	return &ttc, true
}

// ThreeTierRecommendationResult the recommended configuration for a three tier SAP system.
type ThreeTierRecommendationResult struct {
	// DbVMSku - The database VM SKU.
	DbVMSku *string `json:"dbVmSku,omitempty"`
	// DatabaseInstanceCount - The database server instance count.
	DatabaseInstanceCount *int64 `json:"databaseInstanceCount,omitempty"`
	// CentralServerVMSku - The central server VM SKU.
	CentralServerVMSku *string `json:"centralServerVmSku,omitempty"`
	// CentralServerInstanceCount - The central server instance count.
	CentralServerInstanceCount *int64 `json:"centralServerInstanceCount,omitempty"`
	// ApplicationServerVMSku - The application server VM SKU.
	ApplicationServerVMSku *string `json:"applicationServerVmSku,omitempty"`
	// ApplicationServerInstanceCount - The application server instance count.
	ApplicationServerInstanceCount *int64 `json:"applicationServerInstanceCount,omitempty"`
	// DeploymentType - Possible values include: 'DeploymentTypeSAPSizingRecommendationResult', 'DeploymentTypeSingleServer', 'DeploymentTypeThreeTier'
	DeploymentType DeploymentType `json:"deploymentType,omitempty"`
}

// MarshalJSON is the custom marshaler for ThreeTierRecommendationResult.
func (ttrr ThreeTierRecommendationResult) MarshalJSON() ([]byte, error) {
	ttrr.DeploymentType = DeploymentTypeThreeTier
	objectMap := make(map[string]interface{})
	if ttrr.DbVMSku != nil {
		objectMap["dbVmSku"] = ttrr.DbVMSku
	}
	if ttrr.DatabaseInstanceCount != nil {
		objectMap["databaseInstanceCount"] = ttrr.DatabaseInstanceCount
	}
	if ttrr.CentralServerVMSku != nil {
		objectMap["centralServerVmSku"] = ttrr.CentralServerVMSku
	}
	if ttrr.CentralServerInstanceCount != nil {
		objectMap["centralServerInstanceCount"] = ttrr.CentralServerInstanceCount
	}
	if ttrr.ApplicationServerVMSku != nil {
		objectMap["applicationServerVmSku"] = ttrr.ApplicationServerVMSku
	}
	if ttrr.ApplicationServerInstanceCount != nil {
		objectMap["applicationServerInstanceCount"] = ttrr.ApplicationServerInstanceCount
	}
	if ttrr.DeploymentType != "" {
		objectMap["deploymentType"] = ttrr.DeploymentType
	}
	return json.Marshal(objectMap)
}

// AsSingleServerRecommendationResult is the BasicSAPSizingRecommendationResult implementation for ThreeTierRecommendationResult.
func (ttrr ThreeTierRecommendationResult) AsSingleServerRecommendationResult() (*SingleServerRecommendationResult, bool) {
	return nil, false
}

// AsThreeTierRecommendationResult is the BasicSAPSizingRecommendationResult implementation for ThreeTierRecommendationResult.
func (ttrr ThreeTierRecommendationResult) AsThreeTierRecommendationResult() (*ThreeTierRecommendationResult, bool) {
	return &ttrr, true
}

// AsSAPSizingRecommendationResult is the BasicSAPSizingRecommendationResult implementation for ThreeTierRecommendationResult.
func (ttrr ThreeTierRecommendationResult) AsSAPSizingRecommendationResult() (*SAPSizingRecommendationResult, bool) {
	return nil, false
}

// AsBasicSAPSizingRecommendationResult is the BasicSAPSizingRecommendationResult implementation for ThreeTierRecommendationResult.
func (ttrr ThreeTierRecommendationResult) AsBasicSAPSizingRecommendationResult() (BasicSAPSizingRecommendationResult, bool) {
	return &ttrr, true
}

// TrackedResource the resource model definition for an Azure Resource Manager tracked top level resource
// which has 'tags' and a 'location'
type TrackedResource struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for TrackedResource.
func (tr TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.Tags != nil {
		objectMap["tags"] = tr.Tags
	}
	if tr.Location != nil {
		objectMap["location"] = tr.Location
	}
	return json.Marshal(objectMap)
}

// UpdateMonitorRequest defines the request body for updating SAP monitor resource.
type UpdateMonitorRequest struct {
	// Tags - Gets or sets the Resource tags.
	Tags     map[string]*string           `json:"tags"`
	Identity *UserAssignedServiceIdentity `json:"identity,omitempty"`
}

// MarshalJSON is the custom marshaler for UpdateMonitorRequest.
func (umr UpdateMonitorRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if umr.Tags != nil {
		objectMap["tags"] = umr.Tags
	}
	if umr.Identity != nil {
		objectMap["identity"] = umr.Identity
	}
	return json.Marshal(objectMap)
}

// UpdateSAPApplicationInstanceRequest defines the request body for updating SAP Application Instance.
type UpdateSAPApplicationInstanceRequest struct {
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for UpdateSAPApplicationInstanceRequest.
func (usair UpdateSAPApplicationInstanceRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if usair.Tags != nil {
		objectMap["tags"] = usair.Tags
	}
	return json.Marshal(objectMap)
}

// UpdateSAPCentralInstanceRequest defines the request body for updating SAP Central Instance.
type UpdateSAPCentralInstanceRequest struct {
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for UpdateSAPCentralInstanceRequest.
func (uscir UpdateSAPCentralInstanceRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if uscir.Tags != nil {
		objectMap["tags"] = uscir.Tags
	}
	return json.Marshal(objectMap)
}

// UpdateSAPDatabaseInstanceRequest defines the request body for updating SAP Database Instance.
type UpdateSAPDatabaseInstanceRequest struct {
	// Tags - Gets or sets the Resource tags.
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for UpdateSAPDatabaseInstanceRequest.
func (usdir UpdateSAPDatabaseInstanceRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if usdir.Tags != nil {
		objectMap["tags"] = usdir.Tags
	}
	return json.Marshal(objectMap)
}

// UpdateSAPVirtualInstanceRequest defines the request body for updating Virtual Instance for SAP.
type UpdateSAPVirtualInstanceRequest struct {
	// Tags - Gets or sets the Resource tags.
	Tags     map[string]*string           `json:"tags"`
	Identity *UserAssignedServiceIdentity `json:"identity,omitempty"`
}

// MarshalJSON is the custom marshaler for UpdateSAPVirtualInstanceRequest.
func (usvir UpdateSAPVirtualInstanceRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if usvir.Tags != nil {
		objectMap["tags"] = usvir.Tags
	}
	if usvir.Identity != nil {
		objectMap["identity"] = usvir.Identity
	}
	return json.Marshal(objectMap)
}

// UserAssignedIdentity user assigned identity properties
type UserAssignedIdentity struct {
	// PrincipalID - READ-ONLY; The principal ID of the assigned identity.
	PrincipalID *uuid.UUID `json:"principalId,omitempty"`
	// ClientID - READ-ONLY; The client ID of the assigned identity.
	ClientID *uuid.UUID `json:"clientId,omitempty"`
}

// MarshalJSON is the custom marshaler for UserAssignedIdentity.
func (uai UserAssignedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// UserAssignedServiceIdentity managed service identity (user assigned identities)
type UserAssignedServiceIdentity struct {
	// Type - Type of manage identity. Possible values include: 'None', 'UserAssigned'
	Type ManagedServiceIdentityType `json:"type,omitempty"`
	// UserAssignedIdentities - User assigned identities dictionary
	UserAssignedIdentities map[string]*UserAssignedIdentity `json:"userAssignedIdentities"`
}

// MarshalJSON is the custom marshaler for UserAssignedServiceIdentity.
func (uasi UserAssignedServiceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if uasi.Type != "" {
		objectMap["type"] = uasi.Type
	}
	if uasi.UserAssignedIdentities != nil {
		objectMap["userAssignedIdentities"] = uasi.UserAssignedIdentities
	}
	return json.Marshal(objectMap)
}

// UserProfile user profile to configure on a compute resources such as VM, VMSS
type UserProfile struct {
	// UserName - User name
	UserName *string `json:"userName,omitempty"`
	// SSHPublicKey - SSH public key data
	SSHPublicKey *string `json:"sshPublicKey,omitempty"`
}

// VirtualMachineConfiguration defines the virtual machine configuration.
type VirtualMachineConfiguration struct {
	// VMSize - The virtual machine size.
	VMSize *string `json:"vmSize,omitempty"`
	// ImageReference - The image reference.
	ImageReference *ImageReference `json:"imageReference,omitempty"`
	// OsProfile - The OS profile.
	OsProfile *OSProfile `json:"osProfile,omitempty"`
}

// VmssNodesProfile VMSS profile
type VmssNodesProfile struct {
	// AutoScaleMinCount - Minimum number of nodes for autoscale
	AutoScaleMinCount *int32 `json:"autoScaleMinCount,omitempty"`
	// AutoScaleMaxCount - Maximum number of nodes for autoscale
	AutoScaleMaxCount *int32 `json:"autoScaleMaxCount,omitempty"`
	// Name - VM or VMSS name
	Name *string `json:"name,omitempty"`
	// NodeSku - VM SKU for node(s)
	NodeSku *string `json:"nodeSku,omitempty"`
	// OsImage - OS image used for creating the nodes
	OsImage *OsImageProfile `json:"osImage,omitempty"`
	// OsDisk - OS disk details
	OsDisk *DiskInfo `json:"osDisk,omitempty"`
	// DataDisks - Data disks details. This property is not in use right now
	DataDisks *[]DiskInfo `json:"dataDisks,omitempty"`
	// NodeResourceIds - READ-ONLY; VM/VMSS resource ARM Ids
	NodeResourceIds *[]string `json:"nodeResourceIds,omitempty"`
}

// MarshalJSON is the custom marshaler for VmssNodesProfile.
func (vnp VmssNodesProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vnp.AutoScaleMinCount != nil {
		objectMap["autoScaleMinCount"] = vnp.AutoScaleMinCount
	}
	if vnp.AutoScaleMaxCount != nil {
		objectMap["autoScaleMaxCount"] = vnp.AutoScaleMaxCount
	}
	if vnp.Name != nil {
		objectMap["name"] = vnp.Name
	}
	if vnp.NodeSku != nil {
		objectMap["nodeSku"] = vnp.NodeSku
	}
	if vnp.OsImage != nil {
		objectMap["osImage"] = vnp.OsImage
	}
	if vnp.OsDisk != nil {
		objectMap["osDisk"] = vnp.OsDisk
	}
	if vnp.DataDisks != nil {
		objectMap["dataDisks"] = vnp.DataDisks
	}
	return json.Marshal(objectMap)
}

// WindowsConfiguration specifies Windows operating system settings on the virtual machine.
type WindowsConfiguration struct {
	// OsType - Possible values include: 'OsTypeOSConfiguration', 'OsTypeWindows', 'OsTypeLinux'
	OsType OsType `json:"osType,omitempty"`
}

// MarshalJSON is the custom marshaler for WindowsConfiguration.
func (wc WindowsConfiguration) MarshalJSON() ([]byte, error) {
	wc.OsType = OsTypeWindows
	objectMap := make(map[string]interface{})
	if wc.OsType != "" {
		objectMap["osType"] = wc.OsType
	}
	return json.Marshal(objectMap)
}

// AsWindowsConfiguration is the BasicOSConfiguration implementation for WindowsConfiguration.
func (wc WindowsConfiguration) AsWindowsConfiguration() (*WindowsConfiguration, bool) {
	return &wc, true
}

// AsLinuxConfiguration is the BasicOSConfiguration implementation for WindowsConfiguration.
func (wc WindowsConfiguration) AsLinuxConfiguration() (*LinuxConfiguration, bool) {
	return nil, false
}

// AsOSConfiguration is the BasicOSConfiguration implementation for WindowsConfiguration.
func (wc WindowsConfiguration) AsOSConfiguration() (*OSConfiguration, bool) {
	return nil, false
}

// AsBasicOSConfiguration is the BasicOSConfiguration implementation for WindowsConfiguration.
func (wc WindowsConfiguration) AsBasicOSConfiguration() (BasicOSConfiguration, bool) {
	return &wc, true
}

// WordpressInstanceResource wordPress instance resource
type WordpressInstanceResource struct {
	autorest.Response `json:"-"`
	// WordpressInstanceResourceProperties - Resource properties
	*WordpressInstanceResourceProperties `json:"properties,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for WordpressInstanceResource.
func (wir WordpressInstanceResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wir.WordpressInstanceResourceProperties != nil {
		objectMap["properties"] = wir.WordpressInstanceResourceProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for WordpressInstanceResource struct.
func (wir *WordpressInstanceResource) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var wordpressInstanceResourceProperties WordpressInstanceResourceProperties
				err = json.Unmarshal(*v, &wordpressInstanceResourceProperties)
				if err != nil {
					return err
				}
				wir.WordpressInstanceResourceProperties = &wordpressInstanceResourceProperties
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				wir.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				wir.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				wir.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				wir.SystemData = &systemData
			}
		}
	}

	return nil
}

// WordpressInstanceResourceList wordPress instance resource list
type WordpressInstanceResourceList struct {
	autorest.Response `json:"-"`
	// Value - List of resources in current page
	Value *[]WordpressInstanceResource `json:"value,omitempty"`
	// NextLink - Link to next page of resources
	NextLink *string `json:"nextLink,omitempty"`
}

// WordpressInstanceResourceListIterator provides access to a complete listing of WordpressInstanceResource
// values.
type WordpressInstanceResourceListIterator struct {
	i    int
	page WordpressInstanceResourceListPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *WordpressInstanceResourceListIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WordpressInstanceResourceListIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *WordpressInstanceResourceListIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter WordpressInstanceResourceListIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter WordpressInstanceResourceListIterator) Response() WordpressInstanceResourceList {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter WordpressInstanceResourceListIterator) Value() WordpressInstanceResource {
	if !iter.page.NotDone() {
		return WordpressInstanceResource{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the WordpressInstanceResourceListIterator type.
func NewWordpressInstanceResourceListIterator(page WordpressInstanceResourceListPage) WordpressInstanceResourceListIterator {
	return WordpressInstanceResourceListIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (wirl WordpressInstanceResourceList) IsEmpty() bool {
	return wirl.Value == nil || len(*wirl.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (wirl WordpressInstanceResourceList) hasNextLink() bool {
	return wirl.NextLink != nil && len(*wirl.NextLink) != 0
}

// wordpressInstanceResourceListPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (wirl WordpressInstanceResourceList) wordpressInstanceResourceListPreparer(ctx context.Context) (*http.Request, error) {
	if !wirl.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(wirl.NextLink)))
}

// WordpressInstanceResourceListPage contains a page of WordpressInstanceResource values.
type WordpressInstanceResourceListPage struct {
	fn   func(context.Context, WordpressInstanceResourceList) (WordpressInstanceResourceList, error)
	wirl WordpressInstanceResourceList
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *WordpressInstanceResourceListPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/WordpressInstanceResourceListPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.wirl)
		if err != nil {
			return err
		}
		page.wirl = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *WordpressInstanceResourceListPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page WordpressInstanceResourceListPage) NotDone() bool {
	return !page.wirl.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page WordpressInstanceResourceListPage) Response() WordpressInstanceResourceList {
	return page.wirl
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page WordpressInstanceResourceListPage) Values() []WordpressInstanceResource {
	if page.wirl.IsEmpty() {
		return nil
	}
	return *page.wirl.Value
}

// Creates a new instance of the WordpressInstanceResourceListPage type.
func NewWordpressInstanceResourceListPage(cur WordpressInstanceResourceList, getNextPage func(context.Context, WordpressInstanceResourceList) (WordpressInstanceResourceList, error)) WordpressInstanceResourceListPage {
	return WordpressInstanceResourceListPage{
		fn:   getNextPage,
		wirl: cur,
	}
}

// WordpressInstanceResourceProperties wordPress instance properties
type WordpressInstanceResourceProperties struct {
	// Version - Application version. Possible values include: 'FiveFullStopFourFullStopThree', 'FiveFullStopFourFullStopTwo', 'FiveFullStopFourFullStopOne', 'FiveFullStopFour'
	Version WordpressVersions `json:"version,omitempty"`
	// DatabaseName - Database name used by the application
	DatabaseName *string `json:"databaseName,omitempty"`
	// DatabaseUser - User name used by the application to connect to database
	DatabaseUser *string `json:"databaseUser,omitempty"`
	// SiteURL - READ-ONLY; Site Url to access the WordPress application
	SiteURL *string `json:"siteUrl,omitempty"`
	// ProvisioningState - READ-ONLY; WordPress instance provisioning state. Possible values include: 'NotSpecified', 'Accepted', 'Created', 'Succeeded', 'Failed', 'Canceled', 'Installing'
	ProvisioningState ApplicationProvisioningState `json:"provisioningState,omitempty"`
}

// MarshalJSON is the custom marshaler for WordpressInstanceResourceProperties.
func (wirp WordpressInstanceResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if wirp.Version != "" {
		objectMap["version"] = wirp.Version
	}
	if wirp.DatabaseName != nil {
		objectMap["databaseName"] = wirp.DatabaseName
	}
	if wirp.DatabaseUser != nil {
		objectMap["databaseUser"] = wirp.DatabaseUser
	}
	return json.Marshal(objectMap)
}

// WordpressInstancesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type WordpressInstancesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(WordpressInstancesClient) (WordpressInstanceResource, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *WordpressInstancesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for WordpressInstancesCreateOrUpdateFuture.Result.
func (future *WordpressInstancesCreateOrUpdateFuture) result(client WordpressInstancesClient) (wir WordpressInstanceResource, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "workloads.WordpressInstancesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		wir.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("workloads.WordpressInstancesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if wir.Response.Response, err = future.GetResult(sender); err == nil && wir.Response.Response.StatusCode != http.StatusNoContent {
		wir, err = client.CreateOrUpdateResponder(wir.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "workloads.WordpressInstancesCreateOrUpdateFuture", "Result", wir.Response.Response, "Failure responding to request")
		}
	}
	return
}
