package edgeorder

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// ProductsAndConfigurationsClient is the edge Order API's
type ProductsAndConfigurationsClient struct {
	BaseClient
}

// NewProductsAndConfigurationsClient creates an instance of the ProductsAndConfigurationsClient client.
func NewProductsAndConfigurationsClient(subscriptionID string) ProductsAndConfigurationsClient {
	return NewProductsAndConfigurationsClientWithBaseURI(DefaultBaseURI, subscriptionID)
}

// NewProductsAndConfigurationsClientWithBaseURI creates an instance of the ProductsAndConfigurationsClient client
// using a custom endpoint.  Use this when interacting with an Azure cloud that uses a non-standard base URI (sovereign
// clouds, Azure stack).
func NewProductsAndConfigurationsClientWithBaseURI(baseURI string, subscriptionID string) ProductsAndConfigurationsClient {
	return ProductsAndConfigurationsClient{NewWithBaseURI(baseURI, subscriptionID)}
}

// ListConfigurations list configurations for the given product family, product line and product for the given
// subscription.
// Parameters:
// configurationsRequest - filters for showing the configurations.
// skipToken - $skipToken is supported on list of configurations, which provides the next page in the list of
// configurations.
func (client ProductsAndConfigurationsClient) ListConfigurations(ctx context.Context, configurationsRequest ConfigurationsRequest, skipToken string) (result ConfigurationsPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProductsAndConfigurationsClient.ListConfigurations")
		defer func() {
			sc := -1
			if result.c.Response.Response != nil {
				sc = result.c.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: configurationsRequest,
			Constraints: []validation.Constraint{{Target: "configurationsRequest.ConfigurationFilter", Name: validation.Null, Rule: false,
				Chain: []validation.Constraint{{Target: "configurationsRequest.ConfigurationFilter.HierarchyInformation", Name: validation.Null, Rule: true, Chain: nil}}},
				{Target: "configurationsRequest.CustomerSubscriptionDetails", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "configurationsRequest.CustomerSubscriptionDetails.QuotaID", Name: validation.Null, Rule: true, Chain: nil}}}}}}); err != nil {
		return result, validation.NewError("edgeorder.ProductsAndConfigurationsClient", "ListConfigurations", err.Error())
	}

	result.fn = client.listConfigurationsNextResults
	req, err := client.ListConfigurationsPreparer(ctx, configurationsRequest, skipToken)
	if err != nil {
		err = autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "ListConfigurations", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListConfigurationsSender(req)
	if err != nil {
		result.c.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "ListConfigurations", resp, "Failure sending request")
		return
	}

	result.c, err = client.ListConfigurationsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "ListConfigurations", resp, "Failure responding to request")
		return
	}
	if result.c.hasNextLink() && result.c.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// ListConfigurationsPreparer prepares the ListConfigurations request.
func (client ProductsAndConfigurationsClient) ListConfigurationsPreparer(ctx context.Context, configurationsRequest ConfigurationsRequest, skipToken string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"subscriptionId": autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2022-05-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(skipToken) > 0 {
		queryParameters["$skipToken"] = autorest.Encode("query", skipToken)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/providers/Microsoft.EdgeOrder/listConfigurations", pathParameters),
		autorest.WithJSON(configurationsRequest),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListConfigurationsSender sends the ListConfigurations request. The method will close the
// http.Response Body if it receives an error.
func (client ProductsAndConfigurationsClient) ListConfigurationsSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// ListConfigurationsResponder handles the response to the ListConfigurations request. The method always
// closes the http.Response Body.
func (client ProductsAndConfigurationsClient) ListConfigurationsResponder(resp *http.Response) (result Configurations, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listConfigurationsNextResults retrieves the next set of results, if any.
func (client ProductsAndConfigurationsClient) listConfigurationsNextResults(ctx context.Context, lastResults Configurations) (result Configurations, err error) {
	req, err := lastResults.configurationsPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "listConfigurationsNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListConfigurationsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "listConfigurationsNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListConfigurationsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "listConfigurationsNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListConfigurationsComplete enumerates all values, automatically crossing page boundaries as required.
func (client ProductsAndConfigurationsClient) ListConfigurationsComplete(ctx context.Context, configurationsRequest ConfigurationsRequest, skipToken string) (result ConfigurationsIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProductsAndConfigurationsClient.ListConfigurations")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListConfigurations(ctx, configurationsRequest, skipToken)
	return
}

// ListProductFamilies list product families for the given subscription.
// Parameters:
// productFamiliesRequest - filters for showing the product families.
// expand - $expand is supported on configurations parameter for product, which provides details on the
// configurations for the product.
// skipToken - $skipToken is supported on list of product families, which provides the next page in the list of
// product families.
func (client ProductsAndConfigurationsClient) ListProductFamilies(ctx context.Context, productFamiliesRequest ProductFamiliesRequest, expand string, skipToken string) (result ProductFamiliesPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProductsAndConfigurationsClient.ListProductFamilies")
		defer func() {
			sc := -1
			if result.pf.Response.Response != nil {
				sc = result.pf.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}},
		{TargetValue: productFamiliesRequest,
			Constraints: []validation.Constraint{{Target: "productFamiliesRequest.FilterableProperties", Name: validation.Null, Rule: true, Chain: nil},
				{Target: "productFamiliesRequest.CustomerSubscriptionDetails", Name: validation.Null, Rule: false,
					Chain: []validation.Constraint{{Target: "productFamiliesRequest.CustomerSubscriptionDetails.QuotaID", Name: validation.Null, Rule: true, Chain: nil}}}}}}); err != nil {
		return result, validation.NewError("edgeorder.ProductsAndConfigurationsClient", "ListProductFamilies", err.Error())
	}

	result.fn = client.listProductFamiliesNextResults
	req, err := client.ListProductFamiliesPreparer(ctx, productFamiliesRequest, expand, skipToken)
	if err != nil {
		err = autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "ListProductFamilies", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListProductFamiliesSender(req)
	if err != nil {
		result.pf.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "ListProductFamilies", resp, "Failure sending request")
		return
	}

	result.pf, err = client.ListProductFamiliesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "ListProductFamilies", resp, "Failure responding to request")
		return
	}
	if result.pf.hasNextLink() && result.pf.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// ListProductFamiliesPreparer prepares the ListProductFamilies request.
func (client ProductsAndConfigurationsClient) ListProductFamiliesPreparer(ctx context.Context, productFamiliesRequest ProductFamiliesRequest, expand string, skipToken string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"subscriptionId": autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2022-05-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(expand) > 0 {
		queryParameters["$expand"] = autorest.Encode("query", expand)
	}
	if len(skipToken) > 0 {
		queryParameters["$skipToken"] = autorest.Encode("query", skipToken)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsContentType("application/json; charset=utf-8"),
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/providers/Microsoft.EdgeOrder/listProductFamilies", pathParameters),
		autorest.WithJSON(productFamiliesRequest),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListProductFamiliesSender sends the ListProductFamilies request. The method will close the
// http.Response Body if it receives an error.
func (client ProductsAndConfigurationsClient) ListProductFamiliesSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// ListProductFamiliesResponder handles the response to the ListProductFamilies request. The method always
// closes the http.Response Body.
func (client ProductsAndConfigurationsClient) ListProductFamiliesResponder(resp *http.Response) (result ProductFamilies, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listProductFamiliesNextResults retrieves the next set of results, if any.
func (client ProductsAndConfigurationsClient) listProductFamiliesNextResults(ctx context.Context, lastResults ProductFamilies) (result ProductFamilies, err error) {
	req, err := lastResults.productFamiliesPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "listProductFamiliesNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListProductFamiliesSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "listProductFamiliesNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListProductFamiliesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "listProductFamiliesNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListProductFamiliesComplete enumerates all values, automatically crossing page boundaries as required.
func (client ProductsAndConfigurationsClient) ListProductFamiliesComplete(ctx context.Context, productFamiliesRequest ProductFamiliesRequest, expand string, skipToken string) (result ProductFamiliesIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProductsAndConfigurationsClient.ListProductFamilies")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListProductFamilies(ctx, productFamiliesRequest, expand, skipToken)
	return
}

// ListProductFamiliesMetadata list product families metadata for the given subscription.
// Parameters:
// skipToken - $skipToken is supported on list of product families metadata, which provides the next page in
// the list of product families metadata.
func (client ProductsAndConfigurationsClient) ListProductFamiliesMetadata(ctx context.Context, skipToken string) (result ProductFamiliesMetadataPage, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProductsAndConfigurationsClient.ListProductFamiliesMetadata")
		defer func() {
			sc := -1
			if result.pfm.Response.Response != nil {
				sc = result.pfm.Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	if err := validation.Validate([]validation.Validation{
		{TargetValue: client.SubscriptionID,
			Constraints: []validation.Constraint{{Target: "client.SubscriptionID", Name: validation.MinLength, Rule: 1, Chain: nil}}}}); err != nil {
		return result, validation.NewError("edgeorder.ProductsAndConfigurationsClient", "ListProductFamiliesMetadata", err.Error())
	}

	result.fn = client.listProductFamiliesMetadataNextResults
	req, err := client.ListProductFamiliesMetadataPreparer(ctx, skipToken)
	if err != nil {
		err = autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "ListProductFamiliesMetadata", nil, "Failure preparing request")
		return
	}

	resp, err := client.ListProductFamiliesMetadataSender(req)
	if err != nil {
		result.pfm.Response = autorest.Response{Response: resp}
		err = autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "ListProductFamiliesMetadata", resp, "Failure sending request")
		return
	}

	result.pfm, err = client.ListProductFamiliesMetadataResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "ListProductFamiliesMetadata", resp, "Failure responding to request")
		return
	}
	if result.pfm.hasNextLink() && result.pfm.IsEmpty() {
		err = result.NextWithContext(ctx)
		return
	}

	return
}

// ListProductFamiliesMetadataPreparer prepares the ListProductFamiliesMetadata request.
func (client ProductsAndConfigurationsClient) ListProductFamiliesMetadataPreparer(ctx context.Context, skipToken string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"subscriptionId": autorest.Encode("path", client.SubscriptionID),
	}

	const APIVersion = "2022-05-01-preview"
	queryParameters := map[string]interface{}{
		"api-version": APIVersion,
	}
	if len(skipToken) > 0 {
		queryParameters["$skipToken"] = autorest.Encode("query", skipToken)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/subscriptions/{subscriptionId}/providers/Microsoft.EdgeOrder/productFamiliesMetadata", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare((&http.Request{}).WithContext(ctx))
}

// ListProductFamiliesMetadataSender sends the ListProductFamiliesMetadata request. The method will close the
// http.Response Body if it receives an error.
func (client ProductsAndConfigurationsClient) ListProductFamiliesMetadataSender(req *http.Request) (*http.Response, error) {
	return client.Send(req, azure.DoRetryWithRegistration(client.Client))
}

// ListProductFamiliesMetadataResponder handles the response to the ListProductFamiliesMetadata request. The method always
// closes the http.Response Body.
func (client ProductsAndConfigurationsClient) ListProductFamiliesMetadataResponder(resp *http.Response) (result ProductFamiliesMetadata, err error) {
	err = autorest.Respond(
		resp,
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// listProductFamiliesMetadataNextResults retrieves the next set of results, if any.
func (client ProductsAndConfigurationsClient) listProductFamiliesMetadataNextResults(ctx context.Context, lastResults ProductFamiliesMetadata) (result ProductFamiliesMetadata, err error) {
	req, err := lastResults.productFamiliesMetadataPreparer(ctx)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "listProductFamiliesMetadataNextResults", nil, "Failure preparing next results request")
	}
	if req == nil {
		return
	}
	resp, err := client.ListProductFamiliesMetadataSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "listProductFamiliesMetadataNextResults", resp, "Failure sending next results request")
	}
	result, err = client.ListProductFamiliesMetadataResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "edgeorder.ProductsAndConfigurationsClient", "listProductFamiliesMetadataNextResults", resp, "Failure responding to next results request")
	}
	return
}

// ListProductFamiliesMetadataComplete enumerates all values, automatically crossing page boundaries as required.
func (client ProductsAndConfigurationsClient) ListProductFamiliesMetadataComplete(ctx context.Context, skipToken string) (result ProductFamiliesMetadataIterator, err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/ProductsAndConfigurationsClient.ListProductFamiliesMetadata")
		defer func() {
			sc := -1
			if result.Response().Response.Response != nil {
				sc = result.page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	result.page, err = client.ListProductFamiliesMetadata(ctx, skipToken)
	return
}
