package azurestackhci

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
	"context"
	"encoding/json"
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/date"
	"github.com/Azure/go-autorest/autorest/to"
	"github.com/Azure/go-autorest/tracing"
	"net/http"
)

// The package's fully qualified name.
const fqdn = "github.com/Azure/azure-sdk-for-go/services/preview/azurestackhci/mgmt/2021-07-01-preview/azurestackhci"

// AzureEntityResource the resource model definition for an Azure Resource Manager resource with an etag.
type AzureEntityResource struct {
	// Etag - READ-ONLY; Resource Etag.
	Etag *string `json:"etag,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for AzureEntityResource.
func (aer AzureEntityResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorAdditionalInfo the resource management error additional info.
type ErrorAdditionalInfo struct {
	// Type - READ-ONLY; The additional info type.
	Type *string `json:"type,omitempty"`
	// Info - READ-ONLY; The additional info.
	Info interface{} `json:"info,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorAdditionalInfo.
func (eai ErrorAdditionalInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorDetail the error detail.
type ErrorDetail struct {
	// Code - READ-ONLY; The error code.
	Code *string `json:"code,omitempty"`
	// Message - READ-ONLY; The error message.
	Message *string `json:"message,omitempty"`
	// Target - READ-ONLY; The error target.
	Target *string `json:"target,omitempty"`
	// Details - READ-ONLY; The error details.
	Details *[]ErrorDetail `json:"details,omitempty"`
	// AdditionalInfo - READ-ONLY; The error additional info.
	AdditionalInfo *[]ErrorAdditionalInfo `json:"additionalInfo,omitempty"`
}

// MarshalJSON is the custom marshaler for ErrorDetail.
func (ed ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ErrorResponse common error response for all Azure Resource Manager APIs to return error details for
// failed operations. (This also follows the OData error response format.).
type ErrorResponse struct {
	// Error - The error object.
	Error *ErrorDetail `json:"error,omitempty"`
}

// ExtendedLocation the complex type of the extended location.
type ExtendedLocation struct {
	// Name - The name of the extended location.
	Name *string `json:"name,omitempty"`
	// Type - The type of the extended location. Possible values include: 'EdgeZone'
	Type ExtendedLocationTypes `json:"type,omitempty"`
}

// Galleryimages the galleryimages resource definition.
type Galleryimages struct {
	autorest.Response        `json:"-"`
	*GalleryimagesProperties `json:"properties,omitempty"`
	// ExtendedLocation - The extendedLocation of the resource.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for Galleryimages.
func (g Galleryimages) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if g.GalleryimagesProperties != nil {
		objectMap["properties"] = g.GalleryimagesProperties
	}
	if g.ExtendedLocation != nil {
		objectMap["extendedLocation"] = g.ExtendedLocation
	}
	if g.Tags != nil {
		objectMap["tags"] = g.Tags
	}
	if g.Location != nil {
		objectMap["location"] = g.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Galleryimages struct.
func (g *Galleryimages) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var galleryimagesProperties GalleryimagesProperties
				err = json.Unmarshal(*v, &galleryimagesProperties)
				if err != nil {
					return err
				}
				g.GalleryimagesProperties = &galleryimagesProperties
			}
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				g.ExtendedLocation = &extendedLocation
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				g.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				g.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				g.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				g.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				g.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				g.SystemData = &systemData
			}
		}
	}

	return nil
}

// GalleryimagesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type GalleryimagesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(GalleryimagesClient) (Galleryimages, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *GalleryimagesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for GalleryimagesCreateOrUpdateFuture.Result.
func (future *GalleryimagesCreateOrUpdateFuture) result(client GalleryimagesClient) (g Galleryimages, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "azurestackhci.GalleryimagesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		g.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("azurestackhci.GalleryimagesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if g.Response.Response, err = future.GetResult(sender); err == nil && g.Response.Response.StatusCode != http.StatusNoContent {
		g, err = client.CreateOrUpdateResponder(g.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "azurestackhci.GalleryimagesCreateOrUpdateFuture", "Result", g.Response.Response, "Failure responding to request")
		}
	}
	return
}

// GalleryimagesListResult list of galleryimages.
type GalleryimagesListResult struct {
	autorest.Response `json:"-"`
	Value             *[]Galleryimages `json:"value,omitempty"`
	// NextLink - READ-ONLY; Link to the next set of results.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for GalleryimagesListResult.
func (glr GalleryimagesListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if glr.Value != nil {
		objectMap["value"] = glr.Value
	}
	return json.Marshal(objectMap)
}

// GalleryimagesListResultIterator provides access to a complete listing of Galleryimages values.
type GalleryimagesListResultIterator struct {
	i    int
	page GalleryimagesListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *GalleryimagesListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/GalleryimagesListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *GalleryimagesListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter GalleryimagesListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter GalleryimagesListResultIterator) Response() GalleryimagesListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter GalleryimagesListResultIterator) Value() Galleryimages {
	if !iter.page.NotDone() {
		return Galleryimages{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the GalleryimagesListResultIterator type.
func NewGalleryimagesListResultIterator(page GalleryimagesListResultPage) GalleryimagesListResultIterator {
	return GalleryimagesListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (glr GalleryimagesListResult) IsEmpty() bool {
	return glr.Value == nil || len(*glr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (glr GalleryimagesListResult) hasNextLink() bool {
	return glr.NextLink != nil && len(*glr.NextLink) != 0
}

// galleryimagesListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (glr GalleryimagesListResult) galleryimagesListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !glr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(glr.NextLink)))
}

// GalleryimagesListResultPage contains a page of Galleryimages values.
type GalleryimagesListResultPage struct {
	fn  func(context.Context, GalleryimagesListResult) (GalleryimagesListResult, error)
	glr GalleryimagesListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *GalleryimagesListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/GalleryimagesListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.glr)
		if err != nil {
			return err
		}
		page.glr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *GalleryimagesListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page GalleryimagesListResultPage) NotDone() bool {
	return !page.glr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page GalleryimagesListResultPage) Response() GalleryimagesListResult {
	return page.glr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page GalleryimagesListResultPage) Values() []Galleryimages {
	if page.glr.IsEmpty() {
		return nil
	}
	return *page.glr.Value
}

// Creates a new instance of the GalleryimagesListResultPage type.
func NewGalleryimagesListResultPage(cur GalleryimagesListResult, getNextPage func(context.Context, GalleryimagesListResult) (GalleryimagesListResult, error)) GalleryimagesListResultPage {
	return GalleryimagesListResultPage{
		fn:  getNextPage,
		glr: cur,
	}
}

// GalleryimagesPatch the galleryimages resource patch definition.
type GalleryimagesPatch struct {
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for GalleryimagesPatch.
func (gp GalleryimagesPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if gp.Tags != nil {
		objectMap["tags"] = gp.Tags
	}
	return json.Marshal(objectMap)
}

// GalleryimagesProperties ...
type GalleryimagesProperties struct {
	// ContainerName - Container Name for storage container
	ContainerName *string `json:"containerName,omitempty"`
	// ImagePath - location of the image the gallery image should be created from
	ImagePath *string `json:"imagePath,omitempty"`
	// OsType - operating system type that the gallery image uses. Expected to be linux or windows. Possible values include: 'Windows', 'Linux'
	OsType OperatingSystemTypes `json:"osType,omitempty"`
	// ProvisioningState - READ-ONLY; Provisioning state of the gallery image. Possible values include: 'Succeeded', 'Failed', 'InProgress', 'Accepted', 'Deleting'
	ProvisioningState ProvisioningStateEnum `json:"provisioningState,omitempty"`
	// ResourceName - name of the object to be used in moc
	ResourceName *string             `json:"resourceName,omitempty"`
	Status       *GalleryImageStatus `json:"status,omitempty"`
}

// MarshalJSON is the custom marshaler for GalleryimagesProperties.
func (gp GalleryimagesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if gp.ContainerName != nil {
		objectMap["containerName"] = gp.ContainerName
	}
	if gp.ImagePath != nil {
		objectMap["imagePath"] = gp.ImagePath
	}
	if gp.OsType != "" {
		objectMap["osType"] = gp.OsType
	}
	if gp.ResourceName != nil {
		objectMap["resourceName"] = gp.ResourceName
	}
	if gp.Status != nil {
		objectMap["status"] = gp.Status
	}
	return json.Marshal(objectMap)
}

// GalleryImageStatus galleryImageStatus defines the observed state of MOCGalleryImage
type GalleryImageStatus struct {
	// ErrorCode - GalleryImage provisioning error code
	ErrorCode *string `json:"errorCode,omitempty"`
	// ErrorMessage - Descriptive error message
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

// HardwareProfileUpdate hardwareProfile - Specifies the hardware settings for the virtual machine.
type HardwareProfileUpdate struct {
	// VMSize - Possible values include: 'Default', 'StandardA2V2', 'StandardA4V2', 'StandardD2sV3', 'StandardD4sV3', 'StandardD8sV3', 'StandardD16sV3', 'StandardD32sV3', 'StandardDS2V2', 'StandardDS3V2', 'StandardDS4V2', 'StandardDS5V2', 'StandardDS13V2', 'StandardK8SV1', 'StandardK8S2V1', 'StandardK8S3V1', 'StandardK8S4V1', 'StandardNK6', 'StandardNK12', 'StandardNV6', 'StandardNV12', 'StandardK8S5V1', 'Custom'
	VMSize VMSizeEnum `json:"vmSize,omitempty"`
	// Processors - number of processors for the virtual machine
	Processors *int32 `json:"processors,omitempty"`
	// MemoryGB - RAM in gb for the virtual machine
	MemoryGB *int32 `json:"memoryGB,omitempty"`
}

// Identity identity for the resource.
type Identity struct {
	// PrincipalID - READ-ONLY; The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty"`
	// Type - The identity type. Possible values include: 'SystemAssigned'
	Type ResourceIdentityType `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for Identity.
func (i Identity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if i.Type != "" {
		objectMap["type"] = i.Type
	}
	return json.Marshal(objectMap)
}

// InterfaceDNSSettings ...
type InterfaceDNSSettings struct {
	// DNSServers - List of DNS server IP Addresses for the interface
	DNSServers *[]string `json:"dnsServers,omitempty"`
}

// IPConfiguration interfaceIPConfiguration iPConfiguration in a network interface.
type IPConfiguration struct {
	// Name - Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// Properties - InterfaceIPConfigurationPropertiesFormat properties of IP configuration.
	Properties *IPConfigurationProperties `json:"properties,omitempty"`
}

// IPConfigurationProperties interfaceIPConfigurationPropertiesFormat properties of IP configuration.
type IPConfigurationProperties struct {
	// Gateway - Gateway for network interface
	Gateway *string `json:"gateway,omitempty"`
	// PrefixLength - prefixLength for network interface
	PrefixLength *string `json:"prefixLength,omitempty"`
	// PrivateIPAddress - PrivateIPAddress - Private IP address of the IP configuration.
	PrivateIPAddress *string `json:"privateIPAddress,omitempty"`
	// PrivateIPAllocationMethod - PrivateIPAllocationMethod - The private IP address allocation method. Possible values include: 'Static', 'Dynamic'. Possible values include: 'PrivateIPAllocationMethodEnumDynamic', 'PrivateIPAllocationMethodEnumStatic'
	PrivateIPAllocationMethod PrivateIPAllocationMethodEnum `json:"privateIPAllocationMethod,omitempty"`
	// Subnet - Subnet - Name of Subnet bound to the IP configuration.
	Subnet *IPConfigurationPropertiesSubnet `json:"subnet,omitempty"`
}

// IPConfigurationPropertiesSubnet subnet - Name of Subnet bound to the IP configuration.
type IPConfigurationPropertiesSubnet struct {
	// ID - ID - The ARM resource id in the form of /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/...
	ID *string `json:"id,omitempty"`
}

// IPPool ...
type IPPool struct {
	// IPPoolType - ip pool type. Possible values include: 'VM', 'Vippool'
	IPPoolType IPPoolTypeEnum `json:"ipPoolType,omitempty"`
	// Start - First IP in the pool
	Start *string `json:"start,omitempty"`
	// End - Last IP in the pool
	End  *string     `json:"end,omitempty"`
	Info *IPPoolInfo `json:"info,omitempty"`
}

// IPPoolInfo ...
type IPPoolInfo struct {
	// Used - READ-ONLY; no. of ip addresses allocated from the ip pool
	Used *string `json:"used,omitempty"`
	// Available - READ-ONLY; no. of ip addresses available in the ip pool
	Available *string `json:"available,omitempty"`
}

// MarshalJSON is the custom marshaler for IPPoolInfo.
func (ipi IPPoolInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Networkinterfaces the networkinterfaces resource definition.
type Networkinterfaces struct {
	autorest.Response            `json:"-"`
	*NetworkinterfacesProperties `json:"properties,omitempty"`
	// ExtendedLocation - The extendedLocation of the resource.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for Networkinterfaces.
func (n Networkinterfaces) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if n.NetworkinterfacesProperties != nil {
		objectMap["properties"] = n.NetworkinterfacesProperties
	}
	if n.ExtendedLocation != nil {
		objectMap["extendedLocation"] = n.ExtendedLocation
	}
	if n.Tags != nil {
		objectMap["tags"] = n.Tags
	}
	if n.Location != nil {
		objectMap["location"] = n.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Networkinterfaces struct.
func (n *Networkinterfaces) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var networkinterfacesProperties NetworkinterfacesProperties
				err = json.Unmarshal(*v, &networkinterfacesProperties)
				if err != nil {
					return err
				}
				n.NetworkinterfacesProperties = &networkinterfacesProperties
			}
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				n.ExtendedLocation = &extendedLocation
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				n.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				n.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				n.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				n.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				n.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				n.SystemData = &systemData
			}
		}
	}

	return nil
}

// NetworkinterfacesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type NetworkinterfacesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(NetworkinterfacesClient) (Networkinterfaces, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *NetworkinterfacesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for NetworkinterfacesCreateOrUpdateFuture.Result.
func (future *NetworkinterfacesCreateOrUpdateFuture) result(client NetworkinterfacesClient) (n Networkinterfaces, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "azurestackhci.NetworkinterfacesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		n.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("azurestackhci.NetworkinterfacesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if n.Response.Response, err = future.GetResult(sender); err == nil && n.Response.Response.StatusCode != http.StatusNoContent {
		n, err = client.CreateOrUpdateResponder(n.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "azurestackhci.NetworkinterfacesCreateOrUpdateFuture", "Result", n.Response.Response, "Failure responding to request")
		}
	}
	return
}

// NetworkinterfacesListResult ...
type NetworkinterfacesListResult struct {
	autorest.Response `json:"-"`
	Value             *[]Networkinterfaces `json:"value,omitempty"`
	NextLink          *string              `json:"nextLink,omitempty"`
}

// NetworkinterfacesListResultIterator provides access to a complete listing of Networkinterfaces values.
type NetworkinterfacesListResultIterator struct {
	i    int
	page NetworkinterfacesListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *NetworkinterfacesListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/NetworkinterfacesListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *NetworkinterfacesListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter NetworkinterfacesListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter NetworkinterfacesListResultIterator) Response() NetworkinterfacesListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter NetworkinterfacesListResultIterator) Value() Networkinterfaces {
	if !iter.page.NotDone() {
		return Networkinterfaces{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the NetworkinterfacesListResultIterator type.
func NewNetworkinterfacesListResultIterator(page NetworkinterfacesListResultPage) NetworkinterfacesListResultIterator {
	return NetworkinterfacesListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (nlr NetworkinterfacesListResult) IsEmpty() bool {
	return nlr.Value == nil || len(*nlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (nlr NetworkinterfacesListResult) hasNextLink() bool {
	return nlr.NextLink != nil && len(*nlr.NextLink) != 0
}

// networkinterfacesListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (nlr NetworkinterfacesListResult) networkinterfacesListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !nlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(nlr.NextLink)))
}

// NetworkinterfacesListResultPage contains a page of Networkinterfaces values.
type NetworkinterfacesListResultPage struct {
	fn  func(context.Context, NetworkinterfacesListResult) (NetworkinterfacesListResult, error)
	nlr NetworkinterfacesListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *NetworkinterfacesListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/NetworkinterfacesListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.nlr)
		if err != nil {
			return err
		}
		page.nlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *NetworkinterfacesListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page NetworkinterfacesListResultPage) NotDone() bool {
	return !page.nlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page NetworkinterfacesListResultPage) Response() NetworkinterfacesListResult {
	return page.nlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page NetworkinterfacesListResultPage) Values() []Networkinterfaces {
	if page.nlr.IsEmpty() {
		return nil
	}
	return *page.nlr.Value
}

// Creates a new instance of the NetworkinterfacesListResultPage type.
func NewNetworkinterfacesListResultPage(cur NetworkinterfacesListResult, getNextPage func(context.Context, NetworkinterfacesListResult) (NetworkinterfacesListResult, error)) NetworkinterfacesListResultPage {
	return NetworkinterfacesListResultPage{
		fn:  getNextPage,
		nlr: cur,
	}
}

// NetworkinterfacesPatch the networkinterfaces resource patch definition.
type NetworkinterfacesPatch struct {
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for NetworkinterfacesPatch.
func (np NetworkinterfacesPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if np.Tags != nil {
		objectMap["tags"] = np.Tags
	}
	return json.Marshal(objectMap)
}

// NetworkinterfacesProperties networkInterfaceSpec defines the desired state of NetworkInterface
type NetworkinterfacesProperties struct {
	// IPConfigurations - IPConfigurations - A list of IPConfigurations of the network interface.
	IPConfigurations *[]IPConfiguration `json:"ipConfigurations,omitempty"`
	// MacAddress - MacAddress - The MAC address of the network interface.
	MacAddress *string `json:"macAddress,omitempty"`
	// DNSSettings - DNS Settings for the interface
	DNSSettings *InterfaceDNSSettings `json:"dnsSettings,omitempty"`
	// ProvisioningState - READ-ONLY; Possible values include: 'Succeeded', 'Failed', 'InProgress', 'Accepted', 'Deleting'
	ProvisioningState ProvisioningStateEnum `json:"provisioningState,omitempty"`
	// ResourceName - name of the object to be used in moc
	ResourceName *string                 `json:"resourceName,omitempty"`
	Status       *NetworkInterfaceStatus `json:"status,omitempty"`
}

// MarshalJSON is the custom marshaler for NetworkinterfacesProperties.
func (np NetworkinterfacesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if np.IPConfigurations != nil {
		objectMap["ipConfigurations"] = np.IPConfigurations
	}
	if np.MacAddress != nil {
		objectMap["macAddress"] = np.MacAddress
	}
	if np.DNSSettings != nil {
		objectMap["dnsSettings"] = np.DNSSettings
	}
	if np.ResourceName != nil {
		objectMap["resourceName"] = np.ResourceName
	}
	if np.Status != nil {
		objectMap["status"] = np.Status
	}
	return json.Marshal(objectMap)
}

// NetworkInterfaceStatus networkInterfaceStatus defines the observed state of NetworkInterface
type NetworkInterfaceStatus struct {
	// ErrorCode - NetworkInterface provisioning error code
	ErrorCode *string `json:"errorCode,omitempty"`
	// ErrorMessage - Descriptive error message
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

// NetworkProfileUpdate networkProfile - describes the network update configuration the virtual machine
type NetworkProfileUpdate struct {
	// NetworkInterfaces - NetworkInterfaces - list of network interfaces to be attached to the virtual machine
	NetworkInterfaces *[]NetworkProfileUpdateNetworkInterfacesItem `json:"networkInterfaces,omitempty"`
}

// NetworkProfileUpdateNetworkInterfacesItem ...
type NetworkProfileUpdateNetworkInterfacesItem struct {
	// ID - Name of the network interface
	ID *string `json:"id,omitempty"`
}

// Operation details of a REST API operation, returned from the Resource Provider Operations API
type Operation struct {
	// Name - READ-ONLY; The name of the operation, as per Resource-Based Access Control (RBAC). Examples: "Microsoft.Compute/virtualMachines/write", "Microsoft.Compute/virtualMachines/capture/action"
	Name *string `json:"name,omitempty"`
	// IsDataAction - READ-ONLY; Whether the operation applies to data-plane. This is "true" for data-plane operations and "false" for ARM/control-plane operations.
	IsDataAction *bool `json:"isDataAction,omitempty"`
	// Display - Localized display information for this particular operation.
	Display *OperationDisplay `json:"display,omitempty"`
	// Origin - READ-ONLY; The intended executor of the operation; as in Resource Based Access Control (RBAC) and audit logs UX. Default value is "user,system". Possible values include: 'OriginUser', 'OriginSystem', 'OriginUsersystem'
	Origin Origin `json:"origin,omitempty"`
	// ActionType - READ-ONLY; Enum. Indicates the action type. "Internal" refers to actions that are for internal only APIs. Possible values include: 'Internal'
	ActionType ActionType `json:"actionType,omitempty"`
}

// MarshalJSON is the custom marshaler for Operation.
func (o Operation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if o.Display != nil {
		objectMap["display"] = o.Display
	}
	return json.Marshal(objectMap)
}

// OperationDisplay localized display information for this particular operation.
type OperationDisplay struct {
	// Provider - READ-ONLY; The localized friendly form of the resource provider name, e.g. "Microsoft Monitoring Insights" or "Microsoft Compute".
	Provider *string `json:"provider,omitempty"`
	// Resource - READ-ONLY; The localized friendly name of the resource type related to this operation. E.g. "Virtual Machines" or "Job Schedule Collections".
	Resource *string `json:"resource,omitempty"`
	// Operation - READ-ONLY; The concise, localized friendly name for the operation; suitable for dropdowns. E.g. "Create or Update Virtual Machine", "Restart Virtual Machine".
	Operation *string `json:"operation,omitempty"`
	// Description - READ-ONLY; The short, localized friendly description of the operation; suitable for tool tips and detailed views.
	Description *string `json:"description,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationDisplay.
func (o OperationDisplay) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// OperationListResult a list of REST API operations supported by an Azure Resource Provider. It contains
// an URL link to get the next set of results.
type OperationListResult struct {
	autorest.Response `json:"-"`
	// Value - READ-ONLY; List of operations supported by the resource provider
	Value *[]Operation `json:"value,omitempty"`
	// NextLink - READ-ONLY; URL to get the next set of operation list results (if there are any).
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON is the custom marshaler for OperationListResult.
func (olr OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Plan plan for the resource.
type Plan struct {
	// Name - A user defined name of the 3rd Party Artifact that is being procured.
	Name *string `json:"name,omitempty"`
	// Publisher - The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
	Publisher *string `json:"publisher,omitempty"`
	// Product - The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding.
	Product *string `json:"product,omitempty"`
	// PromotionCode - A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
	PromotionCode *string `json:"promotionCode,omitempty"`
	// Version - The version of the desired product/artifact.
	Version *string `json:"version,omitempty"`
}

// ProxyResource the resource model definition for a Azure Resource Manager proxy resource. It will not
// have tags and a location
type ProxyResource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for ProxyResource.
func (pr ProxyResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// Resource common fields that are returned in the response for all Azure Resource Manager resources
type Resource struct {
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	return json.Marshal(objectMap)
}

// ResourceModelWithAllowedPropertySet the resource model definition containing the full set of allowed
// properties for a resource. Except properties bag, there cannot be a top level property outside of this
// set.
type ResourceModelWithAllowedPropertySet struct {
	// ManagedBy - The fully qualified resource ID of the resource that manages this resource. Indicates if this resource is managed by another Azure resource. If this is present, complete mode deployment will not delete the resource if it is removed from the template since it is managed by another resource.
	ManagedBy *string `json:"managedBy,omitempty"`
	// Kind - Metadata used by portal/tooling/etc to render different UX experiences for resources of the same type; e.g. ApiApps are a kind of Microsoft.Web/sites type.  If supported, the resource provider must validate and persist this value.
	Kind *string `json:"kind,omitempty"`
	// Etag - READ-ONLY; The etag field is *not* required. If it is provided in the response body, it must also be provided as a header per the normal etag convention.  Entity tags are used for comparing two or more entities from the same requested resource. HTTP/1.1 uses entity tags in the etag (section 14.19), If-Match (section 14.24), If-None-Match (section 14.26), and If-Range (section 14.27) header fields.
	Etag     *string                                      `json:"etag,omitempty"`
	Identity *ResourceModelWithAllowedPropertySetIdentity `json:"identity,omitempty"`
	Sku      *ResourceModelWithAllowedPropertySetSku      `json:"sku,omitempty"`
	Plan     *ResourceModelWithAllowedPropertySetPlan     `json:"plan,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceModelWithAllowedPropertySet.
func (rmwaps ResourceModelWithAllowedPropertySet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rmwaps.ManagedBy != nil {
		objectMap["managedBy"] = rmwaps.ManagedBy
	}
	if rmwaps.Kind != nil {
		objectMap["kind"] = rmwaps.Kind
	}
	if rmwaps.Identity != nil {
		objectMap["identity"] = rmwaps.Identity
	}
	if rmwaps.Sku != nil {
		objectMap["sku"] = rmwaps.Sku
	}
	if rmwaps.Plan != nil {
		objectMap["plan"] = rmwaps.Plan
	}
	if rmwaps.Tags != nil {
		objectMap["tags"] = rmwaps.Tags
	}
	if rmwaps.Location != nil {
		objectMap["location"] = rmwaps.Location
	}
	return json.Marshal(objectMap)
}

// ResourceModelWithAllowedPropertySetIdentity ...
type ResourceModelWithAllowedPropertySetIdentity struct {
	// PrincipalID - READ-ONLY; The principal ID of resource identity.
	PrincipalID *string `json:"principalId,omitempty"`
	// TenantID - READ-ONLY; The tenant ID of resource.
	TenantID *string `json:"tenantId,omitempty"`
	// Type - The identity type. Possible values include: 'SystemAssigned'
	Type ResourceIdentityType `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for ResourceModelWithAllowedPropertySetIdentity.
func (rmwaps ResourceModelWithAllowedPropertySetIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if rmwaps.Type != "" {
		objectMap["type"] = rmwaps.Type
	}
	return json.Marshal(objectMap)
}

// ResourceModelWithAllowedPropertySetPlan ...
type ResourceModelWithAllowedPropertySetPlan struct {
	// Name - A user defined name of the 3rd Party Artifact that is being procured.
	Name *string `json:"name,omitempty"`
	// Publisher - The publisher of the 3rd Party Artifact that is being bought. E.g. NewRelic
	Publisher *string `json:"publisher,omitempty"`
	// Product - The 3rd Party artifact that is being procured. E.g. NewRelic. Product maps to the OfferID specified for the artifact at the time of Data Market onboarding.
	Product *string `json:"product,omitempty"`
	// PromotionCode - A publisher provided promotion code as provisioned in Data Market for the said product/artifact.
	PromotionCode *string `json:"promotionCode,omitempty"`
	// Version - The version of the desired product/artifact.
	Version *string `json:"version,omitempty"`
}

// ResourceModelWithAllowedPropertySetSku ...
type ResourceModelWithAllowedPropertySetSku struct {
	// Name - The name of the SKU. Ex - P3. It is typically a letter+number code
	Name *string `json:"name,omitempty"`
	// Tier - Possible values include: 'Free', 'Basic', 'Standard', 'Premium'
	Tier SkuTier `json:"tier,omitempty"`
	// Size - The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`
	// Family - If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`
	// Capacity - If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`
}

// Sku the resource model definition representing SKU
type Sku struct {
	// Name - The name of the SKU. Ex - P3. It is typically a letter+number code
	Name *string `json:"name,omitempty"`
	// Tier - Possible values include: 'Free', 'Basic', 'Standard', 'Premium'
	Tier SkuTier `json:"tier,omitempty"`
	// Size - The SKU size. When the name field is the combination of tier and some other value, this would be the standalone code.
	Size *string `json:"size,omitempty"`
	// Family - If the service has different generations of hardware, for the same SKU, then that can be captured here.
	Family *string `json:"family,omitempty"`
	// Capacity - If the SKU supports scale out/in then the capacity integer should be included. If scale out/in is not possible for the resource this may be omitted.
	Capacity *int32 `json:"capacity,omitempty"`
}

// StorageProfileUpdate ...
type StorageProfileUpdate struct {
	// DataDisks - adds data disks to the virtual machine for the update call
	DataDisks *[]StorageProfileUpdateDataDisksItem `json:"dataDisks,omitempty"`
}

// StorageProfileUpdateDataDisksItem ...
type StorageProfileUpdateDataDisksItem struct {
	Name *string `json:"name,omitempty"`
}

// SystemData metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// CreatedBy - The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`
	// CreatedByType - The type of identity that created the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	CreatedByType CreatedByType `json:"createdByType,omitempty"`
	// CreatedAt - The timestamp of resource creation (UTC).
	CreatedAt *date.Time `json:"createdAt,omitempty"`
	// LastModifiedBy - The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`
	// LastModifiedByType - The type of identity that last modified the resource. Possible values include: 'User', 'Application', 'ManagedIdentity', 'Key'
	LastModifiedByType CreatedByType `json:"lastModifiedByType,omitempty"`
	// LastModifiedAt - The timestamp of resource last modification (UTC)
	LastModifiedAt *date.Time `json:"lastModifiedAt,omitempty"`
}

// TrackedResource the resource model definition for an Azure Resource Manager tracked top level resource
// which has 'tags' and a 'location'
type TrackedResource struct {
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for TrackedResource.
func (tr TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if tr.Tags != nil {
		objectMap["tags"] = tr.Tags
	}
	if tr.Location != nil {
		objectMap["location"] = tr.Location
	}
	return json.Marshal(objectMap)
}

// Virtualharddisks the virtualharddisks resource definition.
type Virtualharddisks struct {
	autorest.Response           `json:"-"`
	*VirtualharddisksProperties `json:"properties,omitempty"`
	// ExtendedLocation - The extendedLocation of the resource.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for Virtualharddisks.
func (vVar Virtualharddisks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vVar.VirtualharddisksProperties != nil {
		objectMap["properties"] = vVar.VirtualharddisksProperties
	}
	if vVar.ExtendedLocation != nil {
		objectMap["extendedLocation"] = vVar.ExtendedLocation
	}
	if vVar.Tags != nil {
		objectMap["tags"] = vVar.Tags
	}
	if vVar.Location != nil {
		objectMap["location"] = vVar.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Virtualharddisks struct.
func (vVar *Virtualharddisks) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualharddisksProperties VirtualharddisksProperties
				err = json.Unmarshal(*v, &virtualharddisksProperties)
				if err != nil {
					return err
				}
				vVar.VirtualharddisksProperties = &virtualharddisksProperties
			}
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				vVar.ExtendedLocation = &extendedLocation
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vVar.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vVar.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vVar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vVar.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vVar.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				vVar.SystemData = &systemData
			}
		}
	}

	return nil
}

// VirtualharddisksCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualharddisksCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualharddisksClient) (Virtualharddisks, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualharddisksCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualharddisksCreateOrUpdateFuture.Result.
func (future *VirtualharddisksCreateOrUpdateFuture) result(client VirtualharddisksClient) (vVar Virtualharddisks, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "azurestackhci.VirtualharddisksCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vVar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("azurestackhci.VirtualharddisksCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vVar.Response.Response, err = future.GetResult(sender); err == nil && vVar.Response.Response.StatusCode != http.StatusNoContent {
		vVar, err = client.CreateOrUpdateResponder(vVar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "azurestackhci.VirtualharddisksCreateOrUpdateFuture", "Result", vVar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualharddisksListResult ...
type VirtualharddisksListResult struct {
	autorest.Response `json:"-"`
	Value             *[]Virtualharddisks `json:"value,omitempty"`
	NextLink          *string             `json:"nextLink,omitempty"`
}

// VirtualharddisksListResultIterator provides access to a complete listing of Virtualharddisks values.
type VirtualharddisksListResultIterator struct {
	i    int
	page VirtualharddisksListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualharddisksListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualharddisksListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualharddisksListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualharddisksListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualharddisksListResultIterator) Response() VirtualharddisksListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualharddisksListResultIterator) Value() Virtualharddisks {
	if !iter.page.NotDone() {
		return Virtualharddisks{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualharddisksListResultIterator type.
func NewVirtualharddisksListResultIterator(page VirtualharddisksListResultPage) VirtualharddisksListResultIterator {
	return VirtualharddisksListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vlr VirtualharddisksListResult) IsEmpty() bool {
	return vlr.Value == nil || len(*vlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vlr VirtualharddisksListResult) hasNextLink() bool {
	return vlr.NextLink != nil && len(*vlr.NextLink) != 0
}

// virtualharddisksListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vlr VirtualharddisksListResult) virtualharddisksListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !vlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vlr.NextLink)))
}

// VirtualharddisksListResultPage contains a page of Virtualharddisks values.
type VirtualharddisksListResultPage struct {
	fn  func(context.Context, VirtualharddisksListResult) (VirtualharddisksListResult, error)
	vlr VirtualharddisksListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualharddisksListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualharddisksListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vlr)
		if err != nil {
			return err
		}
		page.vlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualharddisksListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualharddisksListResultPage) NotDone() bool {
	return !page.vlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualharddisksListResultPage) Response() VirtualharddisksListResult {
	return page.vlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualharddisksListResultPage) Values() []Virtualharddisks {
	if page.vlr.IsEmpty() {
		return nil
	}
	return *page.vlr.Value
}

// Creates a new instance of the VirtualharddisksListResultPage type.
func NewVirtualharddisksListResultPage(cur VirtualharddisksListResult, getNextPage func(context.Context, VirtualharddisksListResult) (VirtualharddisksListResult, error)) VirtualharddisksListResultPage {
	return VirtualharddisksListResultPage{
		fn:  getNextPage,
		vlr: cur,
	}
}

// VirtualharddisksPatch the virtualharddisks resource patch definition.
type VirtualharddisksPatch struct {
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VirtualharddisksPatch.
func (vp VirtualharddisksPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vp.Tags != nil {
		objectMap["tags"] = vp.Tags
	}
	return json.Marshal(objectMap)
}

// VirtualharddisksProperties virtualHardDiskSpec defines the desired state of VirtualHardDisk
type VirtualharddisksProperties struct {
	BlockSizeBytes *int32 `json:"blockSizeBytes,omitempty"`
	// DiskSizeBytes - diskSizeBytes - size of the disk in GB
	DiskSizeBytes *int64 `json:"diskSizeBytes,omitempty"`
	// Dynamic - Boolean for enabling dynamic sizing on the virtual hard disk
	Dynamic             *bool  `json:"dynamic,omitempty"`
	LogicalSectorBytes  *int32 `json:"logicalSectorBytes,omitempty"`
	PhysicalSectorBytes *int32 `json:"physicalSectorBytes,omitempty"`
	// ProvisioningState - READ-ONLY; Possible values include: 'Succeeded', 'Failed', 'InProgress', 'Accepted', 'Deleting'
	ProvisioningState ProvisioningStateEnum `json:"provisioningState,omitempty"`
	// ResourceName - name of the object to be used in moc
	ResourceName *string                `json:"resourceName,omitempty"`
	Status       *VirtualHardDiskStatus `json:"status,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualharddisksProperties.
func (vp VirtualharddisksProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vp.BlockSizeBytes != nil {
		objectMap["blockSizeBytes"] = vp.BlockSizeBytes
	}
	if vp.DiskSizeBytes != nil {
		objectMap["diskSizeBytes"] = vp.DiskSizeBytes
	}
	if vp.Dynamic != nil {
		objectMap["dynamic"] = vp.Dynamic
	}
	if vp.LogicalSectorBytes != nil {
		objectMap["logicalSectorBytes"] = vp.LogicalSectorBytes
	}
	if vp.PhysicalSectorBytes != nil {
		objectMap["physicalSectorBytes"] = vp.PhysicalSectorBytes
	}
	if vp.ResourceName != nil {
		objectMap["resourceName"] = vp.ResourceName
	}
	if vp.Status != nil {
		objectMap["status"] = vp.Status
	}
	return json.Marshal(objectMap)
}

// VirtualHardDiskStatus virtualHardDiskStatus defines the observed state of VirtualHardDisk
type VirtualHardDiskStatus struct {
	// ErrorCode - NetworkInterface provisioning error code
	ErrorCode *string `json:"errorCode,omitempty"`
	// ErrorMessage - Descriptive error message
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

// Virtualmachines the virtualmachines resource definition.
type Virtualmachines struct {
	autorest.Response          `json:"-"`
	*VirtualmachinesProperties `json:"properties,omitempty"`
	// ExtendedLocation - The extendedLocation of the resource.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for Virtualmachines.
func (vVar Virtualmachines) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vVar.VirtualmachinesProperties != nil {
		objectMap["properties"] = vVar.VirtualmachinesProperties
	}
	if vVar.ExtendedLocation != nil {
		objectMap["extendedLocation"] = vVar.ExtendedLocation
	}
	if vVar.Tags != nil {
		objectMap["tags"] = vVar.Tags
	}
	if vVar.Location != nil {
		objectMap["location"] = vVar.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Virtualmachines struct.
func (vVar *Virtualmachines) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualmachinesProperties VirtualmachinesProperties
				err = json.Unmarshal(*v, &virtualmachinesProperties)
				if err != nil {
					return err
				}
				vVar.VirtualmachinesProperties = &virtualmachinesProperties
			}
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				vVar.ExtendedLocation = &extendedLocation
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vVar.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vVar.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vVar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vVar.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vVar.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				vVar.SystemData = &systemData
			}
		}
	}

	return nil
}

// VirtualmachinesCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualmachinesCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualmachinesClient) (Virtualmachines, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualmachinesCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualmachinesCreateOrUpdateFuture.Result.
func (future *VirtualmachinesCreateOrUpdateFuture) result(client VirtualmachinesClient) (vVar Virtualmachines, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "azurestackhci.VirtualmachinesCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vVar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("azurestackhci.VirtualmachinesCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vVar.Response.Response, err = future.GetResult(sender); err == nil && vVar.Response.Response.StatusCode != http.StatusNoContent {
		vVar, err = client.CreateOrUpdateResponder(vVar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "azurestackhci.VirtualmachinesCreateOrUpdateFuture", "Result", vVar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualmachinesListResult ...
type VirtualmachinesListResult struct {
	autorest.Response `json:"-"`
	Value             *[]Virtualmachines `json:"value,omitempty"`
	NextLink          *string            `json:"nextLink,omitempty"`
}

// VirtualmachinesListResultIterator provides access to a complete listing of Virtualmachines values.
type VirtualmachinesListResultIterator struct {
	i    int
	page VirtualmachinesListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualmachinesListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualmachinesListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualmachinesListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualmachinesListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualmachinesListResultIterator) Response() VirtualmachinesListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualmachinesListResultIterator) Value() Virtualmachines {
	if !iter.page.NotDone() {
		return Virtualmachines{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualmachinesListResultIterator type.
func NewVirtualmachinesListResultIterator(page VirtualmachinesListResultPage) VirtualmachinesListResultIterator {
	return VirtualmachinesListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vlr VirtualmachinesListResult) IsEmpty() bool {
	return vlr.Value == nil || len(*vlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vlr VirtualmachinesListResult) hasNextLink() bool {
	return vlr.NextLink != nil && len(*vlr.NextLink) != 0
}

// virtualmachinesListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vlr VirtualmachinesListResult) virtualmachinesListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !vlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vlr.NextLink)))
}

// VirtualmachinesListResultPage contains a page of Virtualmachines values.
type VirtualmachinesListResultPage struct {
	fn  func(context.Context, VirtualmachinesListResult) (VirtualmachinesListResult, error)
	vlr VirtualmachinesListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualmachinesListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualmachinesListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vlr)
		if err != nil {
			return err
		}
		page.vlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualmachinesListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualmachinesListResultPage) NotDone() bool {
	return !page.vlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualmachinesListResultPage) Response() VirtualmachinesListResult {
	return page.vlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualmachinesListResultPage) Values() []Virtualmachines {
	if page.vlr.IsEmpty() {
		return nil
	}
	return *page.vlr.Value
}

// Creates a new instance of the VirtualmachinesListResultPage type.
func NewVirtualmachinesListResultPage(cur VirtualmachinesListResult, getNextPage func(context.Context, VirtualmachinesListResult) (VirtualmachinesListResult, error)) VirtualmachinesListResultPage {
	return VirtualmachinesListResultPage{
		fn:  getNextPage,
		vlr: cur,
	}
}

// VirtualmachinesPatch the virtualmachines resource patch definition.
type VirtualmachinesPatch struct {
	Properties *VirtualMachineUpdateProperties `json:"properties,omitempty"`
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VirtualmachinesPatch.
func (vp VirtualmachinesPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vp.Properties != nil {
		objectMap["properties"] = vp.Properties
	}
	if vp.Tags != nil {
		objectMap["tags"] = vp.Tags
	}
	return json.Marshal(objectMap)
}

// VirtualmachinesProperties virtualMachineSpec defines the desired state of VirtualMachine
type VirtualmachinesProperties struct {
	// HardwareProfile - HardwareProfile - Specifies the hardware settings for the virtual machine.
	HardwareProfile *VirtualmachinesPropertiesHardwareProfile `json:"hardwareProfile,omitempty"`
	// NetworkProfile - NetworkProfile - describes the network configuration the virtual machine
	NetworkProfile *VirtualmachinesPropertiesNetworkProfile `json:"networkProfile,omitempty"`
	// OsProfile - OsProfile - describes the configuration of the operating system and sets login data
	OsProfile *VirtualmachinesPropertiesOsProfile `json:"osProfile,omitempty"`
	// ResourceName - name of the object to be used in moc
	ResourceName *string `json:"resourceName,omitempty"`
	// SecurityProfile - SecurityProfile - Specifies the security settings for the virtual machine.
	SecurityProfile *VirtualmachinesPropertiesSecurityProfile `json:"securityProfile,omitempty"`
	// StorageProfile - StorageProfile - contains information about the disks and storage information for the virtual machine
	StorageProfile *VirtualmachinesPropertiesStorageProfile `json:"storageProfile,omitempty"`
	// ProvisioningState - READ-ONLY; Possible values include: 'Succeeded', 'Failed', 'InProgress', 'Accepted', 'Deleting'
	ProvisioningState ProvisioningStateEnum `json:"provisioningState,omitempty"`
	Status            *VirtualMachineStatus `json:"status,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualmachinesProperties.
func (vp VirtualmachinesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vp.HardwareProfile != nil {
		objectMap["hardwareProfile"] = vp.HardwareProfile
	}
	if vp.NetworkProfile != nil {
		objectMap["networkProfile"] = vp.NetworkProfile
	}
	if vp.OsProfile != nil {
		objectMap["osProfile"] = vp.OsProfile
	}
	if vp.ResourceName != nil {
		objectMap["resourceName"] = vp.ResourceName
	}
	if vp.SecurityProfile != nil {
		objectMap["securityProfile"] = vp.SecurityProfile
	}
	if vp.StorageProfile != nil {
		objectMap["storageProfile"] = vp.StorageProfile
	}
	if vp.Status != nil {
		objectMap["status"] = vp.Status
	}
	return json.Marshal(objectMap)
}

// VirtualmachinesPropertiesHardwareProfile hardwareProfile - Specifies the hardware settings for the
// virtual machine.
type VirtualmachinesPropertiesHardwareProfile struct {
	VMSize *string `json:"vmSize,omitempty"`
	// Processors - number of processors for the virtual machine
	Processors *int32 `json:"processors,omitempty"`
	// MemoryGB - RAM in gb for the virtual machine
	MemoryGB            *int32                                                       `json:"memoryGB,omitempty"`
	DynamicMemoryConfig *VirtualmachinesPropertiesHardwareProfileDynamicMemoryConfig `json:"dynamicMemoryConfig,omitempty"`
}

// VirtualmachinesPropertiesHardwareProfileDynamicMemoryConfig ...
type VirtualmachinesPropertiesHardwareProfileDynamicMemoryConfig struct {
	MaximumMemoryGB    *int64 `json:"maximumMemoryGB,omitempty"`
	MinimumMemoryGB    *int64 `json:"minimumMemoryGB,omitempty"`
	TargetMemoryBuffer *int32 `json:"targetMemoryBuffer,omitempty"`
}

// VirtualmachinesPropertiesNetworkProfile networkProfile - describes the network configuration the virtual
// machine
type VirtualmachinesPropertiesNetworkProfile struct {
	// NetworkInterfaces - NetworkInterfaces - list of network interfaces to be attached to the virtual machine
	NetworkInterfaces *[]VirtualmachinesPropertiesNetworkProfileNetworkInterfacesItem `json:"networkInterfaces,omitempty"`
}

// VirtualmachinesPropertiesNetworkProfileNetworkInterfacesItem ...
type VirtualmachinesPropertiesNetworkProfileNetworkInterfacesItem struct {
	// ID - Name of the network interface
	ID *string `json:"id,omitempty"`
}

// VirtualmachinesPropertiesOsProfile osProfile - describes the configuration of the operating system and
// sets login data
type VirtualmachinesPropertiesOsProfile struct {
	// AdminPassword - AdminPassword - admin password
	AdminPassword *string `json:"adminPassword,omitempty"`
	// AdminUsername - AdminUsername - admin username
	AdminUsername *string `json:"adminUsername,omitempty"`
	// ComputerName - ComputerName - name of the compute
	ComputerName *string `json:"computerName,omitempty"`
	// LinuxConfiguration - LinuxConfiguration - linux specific configuration values for the virtual machine
	LinuxConfiguration *VirtualmachinesPropertiesOsProfileLinuxConfiguration `json:"linuxConfiguration,omitempty"`
	// OsType - OsType - string specifying whether the OS is Linux or Windows. Possible values include: 'OsTypeEnumLinux', 'OsTypeEnumWindows'
	OsType OsTypeEnum `json:"osType,omitempty"`
	// WindowsConfiguration - Windows Configuration for the virtual machine
	WindowsConfiguration *VirtualmachinesPropertiesOsProfileWindowsConfiguration `json:"windowsConfiguration,omitempty"`
}

// VirtualmachinesPropertiesOsProfileLinuxConfiguration linuxConfiguration - linux specific configuration
// values for the virtual machine
type VirtualmachinesPropertiesOsProfileLinuxConfiguration struct {
	// DisablePasswordAuthentication - DisablePasswordAuthentication - whether password authentication should be disabled
	DisablePasswordAuthentication *bool `json:"disablePasswordAuthentication,omitempty"`
	// SSH - SSH - contains settings related to ssh configuration
	SSH *VirtualmachinesPropertiesOsProfileLinuxConfigurationSSH `json:"ssh,omitempty"`
}

// VirtualmachinesPropertiesOsProfileLinuxConfigurationSSH SSH - contains settings related to ssh
// configuration
type VirtualmachinesPropertiesOsProfileLinuxConfigurationSSH struct {
	// PublicKeys - PublicKeys - The list of SSH public keys used to authenticate with linux based VMs.
	PublicKeys *[]VirtualmachinesPropertiesOsProfileLinuxConfigurationSSHPublicKeysItem `json:"publicKeys,omitempty"`
}

// VirtualmachinesPropertiesOsProfileLinuxConfigurationSSHPublicKeysItem ...
type VirtualmachinesPropertiesOsProfileLinuxConfigurationSSHPublicKeysItem struct {
	// KeyData - KeyData - SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Li      nux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
	KeyData *string `json:"keyData,omitempty"`
	// Path - Path - Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
	Path *string `json:"path,omitempty"`
}

// VirtualmachinesPropertiesOsProfileWindowsConfiguration windows Configuration for the virtual machine
type VirtualmachinesPropertiesOsProfileWindowsConfiguration struct {
	// EnableAutomaticUpdates - Whether to EnableAutomaticUpdates on the machine
	EnableAutomaticUpdates *bool `json:"enableAutomaticUpdates,omitempty"`
	// SSH - SSH Configuration
	SSH *VirtualmachinesPropertiesOsProfileWindowsConfigurationSSH `json:"ssh,omitempty"`
	// TimeZone - TimeZone for the virtual machine
	TimeZone *string `json:"timeZone,omitempty"`
}

// VirtualmachinesPropertiesOsProfileWindowsConfigurationSSH SSH Configuration
type VirtualmachinesPropertiesOsProfileWindowsConfigurationSSH struct {
	// PublicKeys - PublicKeys - The list of SSH public keys used to authenticate with linux based VMs.
	PublicKeys *[]VirtualmachinesPropertiesOsProfileWindowsConfigurationSSHPublicKeysItem `json:"publicKeys,omitempty"`
}

// VirtualmachinesPropertiesOsProfileWindowsConfigurationSSHPublicKeysItem ...
type VirtualmachinesPropertiesOsProfileWindowsConfigurationSSHPublicKeysItem struct {
	// KeyData - KeyData - SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa format. <br><br> For creating ssh keys, see [Create SSH keys on Linux and Mac for Li      nux VMs in Azure](https://docs.microsoft.com/azure/virtual-machines/virtual-machines-linux-mac-create-ssh-keys?toc=%2fazure%2fvirtual-machines%2flinux%2ftoc.json).
	KeyData *string `json:"keyData,omitempty"`
	// Path - Path - Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key is appended to the file. Example: /home/user/.ssh/authorized_keys
	Path *string `json:"path,omitempty"`
}

// VirtualmachinesPropertiesSecurityProfile securityProfile - Specifies the security settings for the
// virtual machine.
type VirtualmachinesPropertiesSecurityProfile struct {
	EnableTPM *bool `json:"enableTPM,omitempty"`
}

// VirtualmachinesPropertiesStorageProfile storageProfile - contains information about the disks and
// storage information for the virtual machine
type VirtualmachinesPropertiesStorageProfile struct {
	// DataDisks - adds data disks to the virtual machine
	DataDisks *[]VirtualmachinesPropertiesStorageProfileDataDisksItem `json:"dataDisks,omitempty"`
	// ImageReference - Which Image to use for the virtual machine
	ImageReference *VirtualmachinesPropertiesStorageProfileImageReference `json:"imageReference,omitempty"`
}

// VirtualmachinesPropertiesStorageProfileDataDisksItem ...
type VirtualmachinesPropertiesStorageProfileDataDisksItem struct {
	Name *string `json:"name,omitempty"`
}

// VirtualmachinesPropertiesStorageProfileImageReference which Image to use for the virtual machine
type VirtualmachinesPropertiesStorageProfileImageReference struct {
	// Name - Name - Name of the image
	Name *string `json:"name,omitempty"`
}

// VirtualmachinesRestartFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualmachinesRestartFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualmachinesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualmachinesRestartFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualmachinesRestartFuture.Result.
func (future *VirtualmachinesRestartFuture) result(client VirtualmachinesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "azurestackhci.VirtualmachinesRestartFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("azurestackhci.VirtualmachinesRestartFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualmachinesStartFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualmachinesStartFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualmachinesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualmachinesStartFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualmachinesStartFuture.Result.
func (future *VirtualmachinesStartFuture) result(client VirtualmachinesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "azurestackhci.VirtualmachinesStartFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("azurestackhci.VirtualmachinesStartFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualmachinesStopFuture an abstraction for monitoring and retrieving the results of a long-running
// operation.
type VirtualmachinesStopFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualmachinesClient) (autorest.Response, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualmachinesStopFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualmachinesStopFuture.Result.
func (future *VirtualmachinesStopFuture) result(client VirtualmachinesClient) (ar autorest.Response, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "azurestackhci.VirtualmachinesStopFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		ar.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("azurestackhci.VirtualmachinesStopFuture")
		return
	}
	ar.Response = future.Response()
	return
}

// VirtualMachineStatus virtualMachineStatus defines the observed state of VirtualMachine
type VirtualMachineStatus struct {
	// PowerState - PowerState of the VM. Possible values include: 'Deallocated', 'Deallocating', 'Running', 'Starting', 'Stopped', 'Stopping', 'Unknown'
	PowerState PowerStateEnum `json:"powerState,omitempty"`
	// ErrorCode - VM provisioning error code
	ErrorCode *string `json:"errorCode,omitempty"`
	// ErrorMessage - Descriptive error message
	ErrorMessage *string `json:"errorMessage,omitempty"`
}

// VirtualMachineUpdateProperties defines the resource properties for the update.
type VirtualMachineUpdateProperties struct {
	HardwareProfile *HardwareProfileUpdate `json:"hardwareProfile,omitempty"`
	StorageProfile  *StorageProfileUpdate  `json:"storageProfile,omitempty"`
	NetworkProfile  *NetworkProfileUpdate  `json:"networkProfile,omitempty"`
}

// Virtualnetworks the virtualnetworks resource definition.
type Virtualnetworks struct {
	autorest.Response          `json:"-"`
	*VirtualnetworksProperties `json:"properties,omitempty"`
	// ExtendedLocation - The extendedLocation of the resource.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`
	// Tags - Resource tags.
	Tags map[string]*string `json:"tags"`
	// Location - The geo-location where the resource lives
	Location *string `json:"location,omitempty"`
	// ID - READ-ONLY; Fully qualified resource ID for the resource. Ex - /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty"`
	// Name - READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty"`
	// Type - READ-ONLY; The type of the resource. E.g. "Microsoft.Compute/virtualMachines" or "Microsoft.Storage/storageAccounts"
	Type *string `json:"type,omitempty"`
	// SystemData - READ-ONLY; Azure Resource Manager metadata containing createdBy and modifiedBy information.
	SystemData *SystemData `json:"systemData,omitempty"`
}

// MarshalJSON is the custom marshaler for Virtualnetworks.
func (vVar Virtualnetworks) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vVar.VirtualnetworksProperties != nil {
		objectMap["properties"] = vVar.VirtualnetworksProperties
	}
	if vVar.ExtendedLocation != nil {
		objectMap["extendedLocation"] = vVar.ExtendedLocation
	}
	if vVar.Tags != nil {
		objectMap["tags"] = vVar.Tags
	}
	if vVar.Location != nil {
		objectMap["location"] = vVar.Location
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for Virtualnetworks struct.
func (vVar *Virtualnetworks) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "properties":
			if v != nil {
				var virtualnetworksProperties VirtualnetworksProperties
				err = json.Unmarshal(*v, &virtualnetworksProperties)
				if err != nil {
					return err
				}
				vVar.VirtualnetworksProperties = &virtualnetworksProperties
			}
		case "extendedLocation":
			if v != nil {
				var extendedLocation ExtendedLocation
				err = json.Unmarshal(*v, &extendedLocation)
				if err != nil {
					return err
				}
				vVar.ExtendedLocation = &extendedLocation
			}
		case "tags":
			if v != nil {
				var tags map[string]*string
				err = json.Unmarshal(*v, &tags)
				if err != nil {
					return err
				}
				vVar.Tags = tags
			}
		case "location":
			if v != nil {
				var location string
				err = json.Unmarshal(*v, &location)
				if err != nil {
					return err
				}
				vVar.Location = &location
			}
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vVar.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vVar.Name = &name
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vVar.Type = &typeVar
			}
		case "systemData":
			if v != nil {
				var systemData SystemData
				err = json.Unmarshal(*v, &systemData)
				if err != nil {
					return err
				}
				vVar.SystemData = &systemData
			}
		}
	}

	return nil
}

// VirtualnetworksCreateOrUpdateFuture an abstraction for monitoring and retrieving the results of a
// long-running operation.
type VirtualnetworksCreateOrUpdateFuture struct {
	azure.FutureAPI
	// Result returns the result of the asynchronous operation.
	// If the operation has not completed it will return an error.
	Result func(VirtualnetworksClient) (Virtualnetworks, error)
}

// UnmarshalJSON is the custom unmarshaller for CreateFuture.
func (future *VirtualnetworksCreateOrUpdateFuture) UnmarshalJSON(body []byte) error {
	var azFuture azure.Future
	if err := json.Unmarshal(body, &azFuture); err != nil {
		return err
	}
	future.FutureAPI = &azFuture
	future.Result = future.result
	return nil
}

// result is the default implementation for VirtualnetworksCreateOrUpdateFuture.Result.
func (future *VirtualnetworksCreateOrUpdateFuture) result(client VirtualnetworksClient) (vVar Virtualnetworks, err error) {
	var done bool
	done, err = future.DoneWithContext(context.Background(), client)
	if err != nil {
		err = autorest.NewErrorWithError(err, "azurestackhci.VirtualnetworksCreateOrUpdateFuture", "Result", future.Response(), "Polling failure")
		return
	}
	if !done {
		vVar.Response.Response = future.Response()
		err = azure.NewAsyncOpIncompleteError("azurestackhci.VirtualnetworksCreateOrUpdateFuture")
		return
	}
	sender := autorest.DecorateSender(client, autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
	if vVar.Response.Response, err = future.GetResult(sender); err == nil && vVar.Response.Response.StatusCode != http.StatusNoContent {
		vVar, err = client.CreateOrUpdateResponder(vVar.Response.Response)
		if err != nil {
			err = autorest.NewErrorWithError(err, "azurestackhci.VirtualnetworksCreateOrUpdateFuture", "Result", vVar.Response.Response, "Failure responding to request")
		}
	}
	return
}

// VirtualnetworksListResult ...
type VirtualnetworksListResult struct {
	autorest.Response `json:"-"`
	Value             *[]Virtualnetworks `json:"value,omitempty"`
	NextLink          *string            `json:"nextLink,omitempty"`
}

// VirtualnetworksListResultIterator provides access to a complete listing of Virtualnetworks values.
type VirtualnetworksListResultIterator struct {
	i    int
	page VirtualnetworksListResultPage
}

// NextWithContext advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
func (iter *VirtualnetworksListResultIterator) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualnetworksListResultIterator.NextWithContext")
		defer func() {
			sc := -1
			if iter.Response().Response.Response != nil {
				sc = iter.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	iter.i++
	if iter.i < len(iter.page.Values()) {
		return nil
	}
	err = iter.page.NextWithContext(ctx)
	if err != nil {
		iter.i--
		return err
	}
	iter.i = 0
	return nil
}

// Next advances to the next value.  If there was an error making
// the request the iterator does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (iter *VirtualnetworksListResultIterator) Next() error {
	return iter.NextWithContext(context.Background())
}

// NotDone returns true if the enumeration should be started or is not yet complete.
func (iter VirtualnetworksListResultIterator) NotDone() bool {
	return iter.page.NotDone() && iter.i < len(iter.page.Values())
}

// Response returns the raw server response from the last page request.
func (iter VirtualnetworksListResultIterator) Response() VirtualnetworksListResult {
	return iter.page.Response()
}

// Value returns the current value or a zero-initialized value if the
// iterator has advanced beyond the end of the collection.
func (iter VirtualnetworksListResultIterator) Value() Virtualnetworks {
	if !iter.page.NotDone() {
		return Virtualnetworks{}
	}
	return iter.page.Values()[iter.i]
}

// Creates a new instance of the VirtualnetworksListResultIterator type.
func NewVirtualnetworksListResultIterator(page VirtualnetworksListResultPage) VirtualnetworksListResultIterator {
	return VirtualnetworksListResultIterator{page: page}
}

// IsEmpty returns true if the ListResult contains no values.
func (vlr VirtualnetworksListResult) IsEmpty() bool {
	return vlr.Value == nil || len(*vlr.Value) == 0
}

// hasNextLink returns true if the NextLink is not empty.
func (vlr VirtualnetworksListResult) hasNextLink() bool {
	return vlr.NextLink != nil && len(*vlr.NextLink) != 0
}

// virtualnetworksListResultPreparer prepares a request to retrieve the next set of results.
// It returns nil if no more results exist.
func (vlr VirtualnetworksListResult) virtualnetworksListResultPreparer(ctx context.Context) (*http.Request, error) {
	if !vlr.hasNextLink() {
		return nil, nil
	}
	return autorest.Prepare((&http.Request{}).WithContext(ctx),
		autorest.AsJSON(),
		autorest.AsGet(),
		autorest.WithBaseURL(to.String(vlr.NextLink)))
}

// VirtualnetworksListResultPage contains a page of Virtualnetworks values.
type VirtualnetworksListResultPage struct {
	fn  func(context.Context, VirtualnetworksListResult) (VirtualnetworksListResult, error)
	vlr VirtualnetworksListResult
}

// NextWithContext advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
func (page *VirtualnetworksListResultPage) NextWithContext(ctx context.Context) (err error) {
	if tracing.IsEnabled() {
		ctx = tracing.StartSpan(ctx, fqdn+"/VirtualnetworksListResultPage.NextWithContext")
		defer func() {
			sc := -1
			if page.Response().Response.Response != nil {
				sc = page.Response().Response.Response.StatusCode
			}
			tracing.EndSpan(ctx, sc, err)
		}()
	}
	for {
		next, err := page.fn(ctx, page.vlr)
		if err != nil {
			return err
		}
		page.vlr = next
		if !next.hasNextLink() || !next.IsEmpty() {
			break
		}
	}
	return nil
}

// Next advances to the next page of values.  If there was an error making
// the request the page does not advance and the error is returned.
// Deprecated: Use NextWithContext() instead.
func (page *VirtualnetworksListResultPage) Next() error {
	return page.NextWithContext(context.Background())
}

// NotDone returns true if the page enumeration should be started or is not yet complete.
func (page VirtualnetworksListResultPage) NotDone() bool {
	return !page.vlr.IsEmpty()
}

// Response returns the raw server response from the last page request.
func (page VirtualnetworksListResultPage) Response() VirtualnetworksListResult {
	return page.vlr
}

// Values returns the slice of values for the current page or nil if there are no values.
func (page VirtualnetworksListResultPage) Values() []Virtualnetworks {
	if page.vlr.IsEmpty() {
		return nil
	}
	return *page.vlr.Value
}

// Creates a new instance of the VirtualnetworksListResultPage type.
func NewVirtualnetworksListResultPage(cur VirtualnetworksListResult, getNextPage func(context.Context, VirtualnetworksListResult) (VirtualnetworksListResult, error)) VirtualnetworksListResultPage {
	return VirtualnetworksListResultPage{
		fn:  getNextPage,
		vlr: cur,
	}
}

// VirtualnetworksPatch the virtualnetworks resource patch definition.
type VirtualnetworksPatch struct {
	// Tags - Resource tags
	Tags map[string]*string `json:"tags"`
}

// MarshalJSON is the custom marshaler for VirtualnetworksPatch.
func (vp VirtualnetworksPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vp.Tags != nil {
		objectMap["tags"] = vp.Tags
	}
	return json.Marshal(objectMap)
}

// VirtualnetworksProperties virtualNetworkSpec defines the desired state of VirtualNetwork
type VirtualnetworksProperties struct {
	// NetworkType - Type of the network. Possible values include: 'NetworkTypeEnumNAT', 'NetworkTypeEnumTransparent', 'NetworkTypeEnumL2Bridge', 'NetworkTypeEnumL2Tunnel', 'NetworkTypeEnumICS', 'NetworkTypeEnumPrivate', 'NetworkTypeEnumOverlay', 'NetworkTypeEnumInternal', 'NetworkTypeEnumMirrored'
	NetworkType NetworkTypeEnum `json:"networkType,omitempty"`
	// Subnets - Subnet - list of subnets under the virtual network
	Subnets *[]VirtualnetworksPropertiesSubnetsItem `json:"subnets,omitempty"`
	// ProvisioningState - READ-ONLY; Possible values include: 'Succeeded', 'Failed', 'InProgress', 'Accepted', 'Deleting'
	ProvisioningState ProvisioningStateEnum `json:"provisioningState,omitempty"`
	// ResourceName - name of the object to be used in moc
	ResourceName *string               `json:"resourceName,omitempty"`
	Status       *VirtualNetworkStatus `json:"status,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualnetworksProperties.
func (vp VirtualnetworksProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vp.NetworkType != "" {
		objectMap["networkType"] = vp.NetworkType
	}
	if vp.Subnets != nil {
		objectMap["subnets"] = vp.Subnets
	}
	if vp.ResourceName != nil {
		objectMap["resourceName"] = vp.ResourceName
	}
	if vp.Status != nil {
		objectMap["status"] = vp.Status
	}
	return json.Marshal(objectMap)
}

// VirtualnetworksPropertiesSubnetsItem subnet subnet in a virtual network resource.
type VirtualnetworksPropertiesSubnetsItem struct {
	// Name - Name - The name of the resource that is unique within a resource group. This name can be used to access the resource.
	Name *string `json:"name,omitempty"`
	// VirtualnetworksPropertiesSubnetsItemProperties - SubnetProperties - Properties of the subnet.
	*VirtualnetworksPropertiesSubnetsItemProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualnetworksPropertiesSubnetsItem.
func (vpI VirtualnetworksPropertiesSubnetsItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vpI.Name != nil {
		objectMap["name"] = vpI.Name
	}
	if vpI.VirtualnetworksPropertiesSubnetsItemProperties != nil {
		objectMap["properties"] = vpI.VirtualnetworksPropertiesSubnetsItemProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualnetworksPropertiesSubnetsItem struct.
func (vpI *VirtualnetworksPropertiesSubnetsItem) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vpI.Name = &name
			}
		case "properties":
			if v != nil {
				var virtualnetworksPropertiesSubnetsItemProperties VirtualnetworksPropertiesSubnetsItemProperties
				err = json.Unmarshal(*v, &virtualnetworksPropertiesSubnetsItemProperties)
				if err != nil {
					return err
				}
				vpI.VirtualnetworksPropertiesSubnetsItemProperties = &virtualnetworksPropertiesSubnetsItemProperties
			}
		}
	}

	return nil
}

// VirtualnetworksPropertiesSubnetsItemProperties subnetProperties - Properties of the subnet.
type VirtualnetworksPropertiesSubnetsItemProperties struct {
	// AddressPrefix - Cidr for this subnet - IPv4, IPv6
	AddressPrefix *string `json:"addressPrefix,omitempty"`
	// AddressPrefixes - AddressPrefixes - List of address prefixes for the subnet.
	AddressPrefixes *[]string `json:"addressPrefixes,omitempty"`
	// IPAllocationMethod - IPAllocationMethod - The IP address allocation method. Possible values include: 'Static', 'Dynamic'. Possible values include: 'Dynamic', 'Static'
	IPAllocationMethod IPAllocationMethodEnum `json:"ipAllocationMethod,omitempty"`
	// IPConfigurationReferences - IPConfigurationReferences - list of IPConfigurationReferences
	IPConfigurationReferences *[]VirtualnetworksPropertiesSubnetsItemPropertiesIPConfigurationReferencesItem `json:"ipConfigurationReferences,omitempty"`
	// RouteTable - RouteTable for the subnet
	RouteTable *VirtualnetworksPropertiesSubnetsItemPropertiesRouteTable `json:"routeTable,omitempty"`
	// IPPools - network associated pool of IP Addresses
	IPPools *[]IPPool `json:"ipPools,omitempty"`
	// Vlan - Vlan to use for the subnet
	Vlan *int32 `json:"vlan,omitempty"`
}

// VirtualnetworksPropertiesSubnetsItemPropertiesIPConfigurationReferencesItem iPConfigurationReference -
// Describes a IPConfiguration under the virtual network
type VirtualnetworksPropertiesSubnetsItemPropertiesIPConfigurationReferencesItem struct {
	// ID - Name of the Ip Configuration
	ID *string `json:"ID,omitempty"`
}

// VirtualnetworksPropertiesSubnetsItemPropertiesRouteTable routeTable for the subnet
type VirtualnetworksPropertiesSubnetsItemPropertiesRouteTable struct {
	// ID - route ID - ID of the IP route
	ID *string `json:"id,omitempty"`
	// Name - Name - READ-ONLY; Resource name.
	Name *string `json:"name,omitempty"`
	// VirtualnetworksPropertiesSubnetsItemPropertiesRouteTableProperties - RouteTablePropertiesFormat route Table resource.
	*VirtualnetworksPropertiesSubnetsItemPropertiesRouteTableProperties `json:"properties,omitempty"`
	// Type - Type - READ-ONLY; Resource type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualnetworksPropertiesSubnetsItemPropertiesRouteTable.
func (vpIT VirtualnetworksPropertiesSubnetsItemPropertiesRouteTable) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vpIT.ID != nil {
		objectMap["id"] = vpIT.ID
	}
	if vpIT.Name != nil {
		objectMap["name"] = vpIT.Name
	}
	if vpIT.VirtualnetworksPropertiesSubnetsItemPropertiesRouteTableProperties != nil {
		objectMap["properties"] = vpIT.VirtualnetworksPropertiesSubnetsItemPropertiesRouteTableProperties
	}
	if vpIT.Type != nil {
		objectMap["type"] = vpIT.Type
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualnetworksPropertiesSubnetsItemPropertiesRouteTable struct.
func (vpIT *VirtualnetworksPropertiesSubnetsItemPropertiesRouteTable) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "id":
			if v != nil {
				var ID string
				err = json.Unmarshal(*v, &ID)
				if err != nil {
					return err
				}
				vpIT.ID = &ID
			}
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vpIT.Name = &name
			}
		case "properties":
			if v != nil {
				var virtualnetworksPropertiesSubnetsItemPropertiesRouteTableProperties VirtualnetworksPropertiesSubnetsItemPropertiesRouteTableProperties
				err = json.Unmarshal(*v, &virtualnetworksPropertiesSubnetsItemPropertiesRouteTableProperties)
				if err != nil {
					return err
				}
				vpIT.VirtualnetworksPropertiesSubnetsItemPropertiesRouteTableProperties = &virtualnetworksPropertiesSubnetsItemPropertiesRouteTableProperties
			}
		case "type":
			if v != nil {
				var typeVar string
				err = json.Unmarshal(*v, &typeVar)
				if err != nil {
					return err
				}
				vpIT.Type = &typeVar
			}
		}
	}

	return nil
}

// VirtualnetworksPropertiesSubnetsItemPropertiesRouteTableProperties routeTablePropertiesFormat route
// Table resource.
type VirtualnetworksPropertiesSubnetsItemPropertiesRouteTableProperties struct {
	// Routes - Routes - Collection of routes contained within a route table.
	Routes *[]VirtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItem `json:"routes,omitempty"`
}

// VirtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItem route is associated with a
// subnet.
type VirtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItem struct {
	// Name - Name - name of the subnet
	Name *string `json:"name,omitempty"`
	// VirtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItemProperties - RoutePropertiesFormat - Properties of the route.
	*VirtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItemProperties `json:"properties,omitempty"`
}

// MarshalJSON is the custom marshaler for VirtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItem.
func (vpITI VirtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	if vpITI.Name != nil {
		objectMap["name"] = vpITI.Name
	}
	if vpITI.VirtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItemProperties != nil {
		objectMap["properties"] = vpITI.VirtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItemProperties
	}
	return json.Marshal(objectMap)
}

// UnmarshalJSON is the custom unmarshaler for VirtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItem struct.
func (vpITI *VirtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItem) UnmarshalJSON(body []byte) error {
	var m map[string]*json.RawMessage
	err := json.Unmarshal(body, &m)
	if err != nil {
		return err
	}
	for k, v := range m {
		switch k {
		case "name":
			if v != nil {
				var name string
				err = json.Unmarshal(*v, &name)
				if err != nil {
					return err
				}
				vpITI.Name = &name
			}
		case "properties":
			if v != nil {
				var virtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItemProperties VirtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItemProperties
				err = json.Unmarshal(*v, &virtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItemProperties)
				if err != nil {
					return err
				}
				vpITI.VirtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItemProperties = &virtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItemProperties
			}
		}
	}

	return nil
}

// VirtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItemProperties
// routePropertiesFormat - Properties of the route.
type VirtualnetworksPropertiesSubnetsItemPropertiesRouteTablePropertiesRoutesItemProperties struct {
	// AddressPrefix - AddressPrefix - The destination CIDR to which the route applies.
	AddressPrefix *string `json:"addressPrefix,omitempty"`
	// NextHopIPAddress - NextHopIPAddress - The IP address packets should be forwarded to. Next hop values are only allowed in routes where the next hop type is VirtualAppliance.
	NextHopIPAddress *string `json:"nextHopIpAddress,omitempty"`
}

// VirtualNetworkStatus virtualNetworkStatus defines the observed state of VirtualNetwork
type VirtualNetworkStatus struct {
	// ErrorCode - VirtualNetwork provisioning error code
	ErrorCode *string `json:"errorCode,omitempty"`
	// ErrorMessage - Descriptive error message
	ErrorMessage *string `json:"errorMessage,omitempty"`
}
