//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdatamigration

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// APIError - Error information.
type APIError struct {
	// Error information in OData format
	Error *ODataError `json:"error,omitempty"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// AuthenticationKeys - An authentication key.
type AuthenticationKeys struct {
	// The first authentication key.
	AuthKey1 *string `json:"authKey1,omitempty"`

	// The second authentication key.
	AuthKey2 *string `json:"authKey2,omitempty"`
}

// AvailableServiceSKU - Describes the available service SKU.
type AvailableServiceSKU struct {
	// A description of the scaling capacities of the SKU
	Capacity *AvailableServiceSKUCapacity `json:"capacity,omitempty"`

	// The resource type, including the provider namespace
	ResourceType *string `json:"resourceType,omitempty"`

	// SKU name, tier, etc.
	SKU *AvailableServiceSKUSKU `json:"sku,omitempty"`
}

// AvailableServiceSKUCapacity - A description of the scaling capacities of the SKU
type AvailableServiceSKUCapacity struct {
	// The default capacity
	Default *int32 `json:"default,omitempty"`

	// The maximum capacity
	Maximum *int32 `json:"maximum,omitempty"`

	// The minimum capacity, usually 0 or 1.
	Minimum *int32 `json:"minimum,omitempty"`

	// The scalability approach
	ScaleType *ServiceScalability `json:"scaleType,omitempty"`
}

// AvailableServiceSKUSKU - SKU name, tier, etc.
type AvailableServiceSKUSKU struct {
	// SKU family
	Family *string `json:"family,omitempty"`

	// The name of the SKU
	Name *string `json:"name,omitempty"`

	// SKU size
	Size *string `json:"size,omitempty"`

	// The tier of the SKU, such as "Basic", "General Purpose", or "Business Critical"
	Tier *string `json:"tier,omitempty"`
}

// AzureActiveDirectoryApp - Azure Active Directory Application
type AzureActiveDirectoryApp struct {
	// Key used to authenticate to the Azure Active Directory Application
	AppKey *string `json:"appKey,omitempty"`

	// Application ID of the Azure Active Directory Application
	ApplicationID *string `json:"applicationId,omitempty"`

	// Ignore checking azure permissions on the AAD app
	IgnoreAzurePermissions *bool `json:"ignoreAzurePermissions,omitempty"`

	// Tenant id of the customer
	TenantID *string `json:"tenantId,omitempty"`
}

// AzureBlob - Azure Blob Details
type AzureBlob struct {
	// Storage Account Key.
	AccountKey *string `json:"accountKey,omitempty"`

	// Blob container name where backups are stored.
	BlobContainerName *string `json:"blobContainerName,omitempty"`

	// Resource Id of the storage account where backups are stored.
	StorageAccountResourceID *string `json:"storageAccountResourceId,omitempty"`
}

// BackupConfiguration - Backup Configuration
type BackupConfiguration struct {
	// Source location of backups.
	SourceLocation *SourceLocation `json:"sourceLocation,omitempty"`

	// Target location for copying backups.
	TargetLocation *TargetLocation `json:"targetLocation,omitempty"`
}

// BackupFileInfo - Information of the backup file
type BackupFileInfo struct {
	// Sequence number of the backup file in the backup set
	FamilySequenceNumber *int32 `json:"familySequenceNumber,omitempty"`

	// Location of the backup file in shared folder
	FileLocation *string `json:"fileLocation,omitempty"`

	// Status of the backup file during migration
	Status *BackupFileStatus `json:"status,omitempty"`
}

// BackupSetInfo - Information of backup set
type BackupSetInfo struct {
	// Date and time that the backup operation finished
	BackupFinishedDate *time.Time `json:"backupFinishedDate,omitempty"`

	// Id for the set of backup files
	BackupSetID *string `json:"backupSetId,omitempty"`

	// Date and time that the backup operation began
	BackupStartDate *time.Time `json:"backupStartDate,omitempty"`

	// Enum of the different backup types
	BackupType *BackupType `json:"backupType,omitempty"`

	// Name of the database to which the backup set belongs
	DatabaseName *string `json:"databaseName,omitempty"`

	// First log sequence number of the backup file
	FirstLsn *string `json:"firstLsn,omitempty"`

	// Whether the backup set is restored or not
	IsBackupRestored *bool `json:"isBackupRestored,omitempty"`

	// Last log sequence number of the backup file
	LastLsn *string `json:"lastLsn,omitempty"`

	// Last modified time of the backup file in share location
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty"`

	// List of files in the backup set
	ListOfBackupFiles []*BackupFileInfo `json:"listOfBackupFiles,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BackupSetInfo.
func (b BackupSetInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "backupFinishedDate", b.BackupFinishedDate)
	populate(objectMap, "backupSetId", b.BackupSetID)
	populateTimeRFC3339(objectMap, "backupStartDate", b.BackupStartDate)
	populate(objectMap, "backupType", b.BackupType)
	populate(objectMap, "databaseName", b.DatabaseName)
	populate(objectMap, "firstLsn", b.FirstLsn)
	populate(objectMap, "isBackupRestored", b.IsBackupRestored)
	populate(objectMap, "lastLsn", b.LastLsn)
	populateTimeRFC3339(objectMap, "lastModifiedTime", b.LastModifiedTime)
	populate(objectMap, "listOfBackupFiles", b.ListOfBackupFiles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupSetInfo.
func (b *BackupSetInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupFinishedDate":
			err = unpopulateTimeRFC3339(val, &b.BackupFinishedDate)
			delete(rawMsg, key)
		case "backupSetId":
			err = unpopulate(val, &b.BackupSetID)
			delete(rawMsg, key)
		case "backupStartDate":
			err = unpopulateTimeRFC3339(val, &b.BackupStartDate)
			delete(rawMsg, key)
		case "backupType":
			err = unpopulate(val, &b.BackupType)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &b.DatabaseName)
			delete(rawMsg, key)
		case "firstLsn":
			err = unpopulate(val, &b.FirstLsn)
			delete(rawMsg, key)
		case "isBackupRestored":
			err = unpopulate(val, &b.IsBackupRestored)
			delete(rawMsg, key)
		case "lastLsn":
			err = unpopulate(val, &b.LastLsn)
			delete(rawMsg, key)
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, &b.LastModifiedTime)
			delete(rawMsg, key)
		case "listOfBackupFiles":
			err = unpopulate(val, &b.ListOfBackupFiles)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BlobShare - Blob container storage information.
type BlobShare struct {
	// SAS URI of Azure Storage Account Container.
	SasURI *string `json:"sasUri,omitempty"`
}

// CheckOCIDriverTaskInput - Input for the service task to check for OCI drivers.
type CheckOCIDriverTaskInput struct {
	// Version of the source server to check against. Optional.
	ServerVersion *string `json:"serverVersion,omitempty"`
}

// CheckOCIDriverTaskOutput - Output for the service task to check for OCI drivers.
type CheckOCIDriverTaskOutput struct {
	// Information about the installed driver if found and valid.
	InstalledDriver *OracleOCIDriverInfo `json:"installedDriver,omitempty"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CheckOCIDriverTaskOutput.
func (c CheckOCIDriverTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "installedDriver", c.InstalledDriver)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// CheckOCIDriverTaskProperties - Properties for the task that checks for OCI drivers.
type CheckOCIDriverTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Input for the service task to check for OCI drivers.
	Input *CheckOCIDriverTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*CheckOCIDriverTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type CheckOCIDriverTaskProperties.
func (c *CheckOCIDriverTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   c.TaskType,
		Errors:     c.Errors,
		State:      c.State,
		Commands:   c.Commands,
		ClientData: c.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CheckOCIDriverTaskProperties.
func (c CheckOCIDriverTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", c.ClientData)
	populate(objectMap, "commands", c.Commands)
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	populate(objectMap, "state", c.State)
	objectMap["taskType"] = TaskTypeServiceCheckOCI
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CheckOCIDriverTaskProperties.
func (c *CheckOCIDriverTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &c.ClientData)
			delete(rawMsg, key)
		case "commands":
			c.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &c.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &c.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &c.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CommandPropertiesClassification provides polymorphic access to related types.
// Call the interface's GetCommandProperties() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CommandProperties, *MigrateMISyncCompleteCommandProperties, *MigrateSyncCompleteCommandProperties, *MongoDbCancelCommand,
// - *MongoDbFinishCommand, *MongoDbRestartCommand
type CommandPropertiesClassification interface {
	// GetCommandProperties returns the CommandProperties content of the underlying type.
	GetCommandProperties() *CommandProperties
}

// CommandProperties - Base class for all types of DMS command properties. If command is not supported by current client,
// this object is returned.
type CommandProperties struct {
	// REQUIRED; Command type.
	CommandType *CommandType `json:"commandType,omitempty"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; The state of the command. This is ignored if submitted.
	State *CommandState `json:"state,omitempty" azure:"ro"`
}

// GetCommandProperties implements the CommandPropertiesClassification interface for type CommandProperties.
func (c *CommandProperties) GetCommandProperties() *CommandProperties { return c }

// MarshalJSON implements the json.Marshaller interface for type CommandProperties.
func (c CommandProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["commandType"] = c.CommandType
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "state", c.State)
	return json.Marshal(objectMap)
}

// ConnectToMongoDbTaskProperties - Properties for the task that validates the connection to and provides information about
// a MongoDB server
type ConnectToMongoDbTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Describes a connection to a MongoDB data source
	Input *MongoDbConnectionInfo `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; An array containing a single MongoDbClusterInfo object
	Output []*MongoDbClusterInfo `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ConnectToMongoDbTaskProperties.
func (c *ConnectToMongoDbTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   c.TaskType,
		Errors:     c.Errors,
		State:      c.State,
		Commands:   c.Commands,
		ClientData: c.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToMongoDbTaskProperties.
func (c ConnectToMongoDbTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", c.ClientData)
	populate(objectMap, "commands", c.Commands)
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	populate(objectMap, "state", c.State)
	objectMap["taskType"] = TaskTypeConnectMongoDb
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToMongoDbTaskProperties.
func (c *ConnectToMongoDbTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &c.ClientData)
			delete(rawMsg, key)
		case "commands":
			c.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &c.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &c.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &c.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToSourceMySQLTaskInput - Input for the task that validates MySQL database connection
type ConnectToSourceMySQLTaskInput struct {
	// REQUIRED; Information for connecting to MySQL source
	SourceConnectionInfo *MySQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// Permission group for validations
	CheckPermissionsGroup *ServerLevelPermissionsGroup `json:"checkPermissionsGroup,omitempty"`

	// Flag for whether or not the migration is offline
	IsOfflineMigration *bool `json:"isOfflineMigration,omitempty"`

	// Target Platform for the migration
	TargetPlatform *MySQLTargetPlatformType `json:"targetPlatform,omitempty"`
}

// ConnectToSourceMySQLTaskProperties - Properties for the task that validates MySQL database connection
type ConnectToSourceMySQLTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *ConnectToSourceMySQLTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToSourceNonSQLTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ConnectToSourceMySQLTaskProperties.
func (c *ConnectToSourceMySQLTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   c.TaskType,
		Errors:     c.Errors,
		State:      c.State,
		Commands:   c.Commands,
		ClientData: c.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceMySQLTaskProperties.
func (c ConnectToSourceMySQLTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", c.ClientData)
	populate(objectMap, "commands", c.Commands)
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	populate(objectMap, "state", c.State)
	objectMap["taskType"] = TaskTypeConnectToSourceMySQL
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourceMySQLTaskProperties.
func (c *ConnectToSourceMySQLTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &c.ClientData)
			delete(rawMsg, key)
		case "commands":
			c.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &c.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &c.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &c.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToSourceNonSQLTaskOutput - Output for connect to MySQL type source
type ConnectToSourceNonSQLTaskOutput struct {
	// READ-ONLY; List of databases on the server
	Databases []*string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Server properties
	ServerProperties *ServerProperties `json:"serverProperties,omitempty" azure:"ro"`

	// READ-ONLY; Server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors associated with the task
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceNonSQLTaskOutput.
func (c ConnectToSourceNonSQLTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databases", c.Databases)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "serverProperties", c.ServerProperties)
	populate(objectMap, "sourceServerBrandVersion", c.SourceServerBrandVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// ConnectToSourceOracleSyncTaskInput - Input for the task that validates Oracle database connection
type ConnectToSourceOracleSyncTaskInput struct {
	// REQUIRED; Information for connecting to Oracle source
	SourceConnectionInfo *OracleConnectionInfo `json:"sourceConnectionInfo,omitempty"`
}

// ConnectToSourceOracleSyncTaskOutput - Output for the task that validates Oracle database connection
type ConnectToSourceOracleSyncTaskOutput struct {
	// READ-ONLY; List of schemas on source server
	Databases []*string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Source server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Version of the source server
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors associated with the task
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceOracleSyncTaskOutput.
func (c ConnectToSourceOracleSyncTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databases", c.Databases)
	populate(objectMap, "sourceServerBrandVersion", c.SourceServerBrandVersion)
	populate(objectMap, "sourceServerVersion", c.SourceServerVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// ConnectToSourceOracleSyncTaskProperties - Properties for the task that validates Oracle database connection
type ConnectToSourceOracleSyncTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *ConnectToSourceOracleSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToSourceOracleSyncTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ConnectToSourceOracleSyncTaskProperties.
func (c *ConnectToSourceOracleSyncTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   c.TaskType,
		Errors:     c.Errors,
		State:      c.State,
		Commands:   c.Commands,
		ClientData: c.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceOracleSyncTaskProperties.
func (c ConnectToSourceOracleSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", c.ClientData)
	populate(objectMap, "commands", c.Commands)
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	populate(objectMap, "state", c.State)
	objectMap["taskType"] = TaskTypeConnectToSourceOracleSync
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourceOracleSyncTaskProperties.
func (c *ConnectToSourceOracleSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &c.ClientData)
			delete(rawMsg, key)
		case "commands":
			c.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &c.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &c.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &c.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToSourcePostgreSQLSyncTaskInput - Input for the task that validates connection to PostgreSQL and source server requirements
type ConnectToSourcePostgreSQLSyncTaskInput struct {
	// REQUIRED; Connection information for source PostgreSQL server
	SourceConnectionInfo *PostgreSQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`
}

// ConnectToSourcePostgreSQLSyncTaskOutput - Output for the task that validates connection to PostgreSQL and source server
// requirements
type ConnectToSourcePostgreSQLSyncTaskOutput struct {
	// READ-ONLY; List of databases on source server
	Databases []*string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Source server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Version of the source server
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors associated with the task
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourcePostgreSQLSyncTaskOutput.
func (c ConnectToSourcePostgreSQLSyncTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databases", c.Databases)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "sourceServerBrandVersion", c.SourceServerBrandVersion)
	populate(objectMap, "sourceServerVersion", c.SourceServerVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// ConnectToSourcePostgreSQLSyncTaskProperties - Properties for the task that validates connection to PostgreSQL server and
// source server requirements for online migration
type ConnectToSourcePostgreSQLSyncTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *ConnectToSourcePostgreSQLSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToSourcePostgreSQLSyncTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ConnectToSourcePostgreSQLSyncTaskProperties.
func (c *ConnectToSourcePostgreSQLSyncTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   c.TaskType,
		Errors:     c.Errors,
		State:      c.State,
		Commands:   c.Commands,
		ClientData: c.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourcePostgreSQLSyncTaskProperties.
func (c ConnectToSourcePostgreSQLSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", c.ClientData)
	populate(objectMap, "commands", c.Commands)
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	populate(objectMap, "state", c.State)
	objectMap["taskType"] = TaskTypeConnectToSourcePostgreSQLSync
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourcePostgreSQLSyncTaskProperties.
func (c *ConnectToSourcePostgreSQLSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &c.ClientData)
			delete(rawMsg, key)
		case "commands":
			c.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &c.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &c.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &c.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToSourceSQLServerSyncTaskProperties - Properties for the task that validates connection to SQL Server and source
// server requirements for online migration
type ConnectToSourceSQLServerSyncTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *ConnectToSourceSQLServerTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []ConnectToSourceSQLServerTaskOutputClassification `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ConnectToSourceSQLServerSyncTaskProperties.
func (c *ConnectToSourceSQLServerSyncTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   c.TaskType,
		Errors:     c.Errors,
		State:      c.State,
		Commands:   c.Commands,
		ClientData: c.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceSQLServerSyncTaskProperties.
func (c ConnectToSourceSQLServerSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", c.ClientData)
	populate(objectMap, "commands", c.Commands)
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	populate(objectMap, "state", c.State)
	objectMap["taskType"] = TaskTypeConnectToSourceSQLServerSync
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourceSQLServerSyncTaskProperties.
func (c *ConnectToSourceSQLServerSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &c.ClientData)
			delete(rawMsg, key)
		case "commands":
			c.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &c.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			c.Output, err = unmarshalConnectToSourceSQLServerTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &c.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &c.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToSourceSQLServerTaskInput - Input for the task that validates connection to SQL Server and also validates source
// server requirements
type ConnectToSourceSQLServerTaskInput struct {
	// REQUIRED; Connection information for Source SQL Server
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// Permission group for validations
	CheckPermissionsGroup *ServerLevelPermissionsGroup `json:"checkPermissionsGroup,omitempty"`

	// Flag for whether to collect agent jobs from source server.
	CollectAgentJobs *bool `json:"collectAgentJobs,omitempty"`

	// Flag for whether to collect databases from source server.
	CollectDatabases *bool `json:"collectDatabases,omitempty"`

	// Flag for whether to collect logins from source server.
	CollectLogins *bool `json:"collectLogins,omitempty"`

	// Flag for whether to collect TDE Certificate names from source server.
	CollectTdeCertificateInfo *bool `json:"collectTdeCertificateInfo,omitempty"`

	// encrypted key for secure fields
	EncryptedKeyForSecureFields *string `json:"encryptedKeyForSecureFields,omitempty"`

	// Flag for whether to validate SSIS catalog is reachable on the source server.
	ValidateSsisCatalogOnly *bool `json:"validateSsisCatalogOnly,omitempty"`
}

// ConnectToSourceSQLServerTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetConnectToSourceSQLServerTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ConnectToSourceSQLServerTaskOutput, *ConnectToSourceSQLServerTaskOutputAgentJobLevel, *ConnectToSourceSQLServerTaskOutputDatabaseLevel,
// - *ConnectToSourceSQLServerTaskOutputLoginLevel, *ConnectToSourceSQLServerTaskOutputTaskLevel
type ConnectToSourceSQLServerTaskOutputClassification interface {
	// GetConnectToSourceSQLServerTaskOutput returns the ConnectToSourceSQLServerTaskOutput content of the underlying type.
	GetConnectToSourceSQLServerTaskOutput() *ConnectToSourceSQLServerTaskOutput
}

// ConnectToSourceSQLServerTaskOutput - Output for the task that validates connection to SQL Server and also validates source
// server requirements
type ConnectToSourceSQLServerTaskOutput struct {
	// REQUIRED; Type of result - database level or task level
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetConnectToSourceSQLServerTaskOutput implements the ConnectToSourceSQLServerTaskOutputClassification interface for type
// ConnectToSourceSQLServerTaskOutput.
func (c *ConnectToSourceSQLServerTaskOutput) GetConnectToSourceSQLServerTaskOutput() *ConnectToSourceSQLServerTaskOutput {
	return c
}

// ConnectToSourceSQLServerTaskOutputAgentJobLevel - Agent Job level output for the task that validates connection to SQL
// Server and also validates source server requirements
type ConnectToSourceSQLServerTaskOutputAgentJobLevel struct {
	// REQUIRED; Type of result - database level or task level
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The state of the original Agent Job.
	IsEnabled *bool `json:"isEnabled,omitempty" azure:"ro"`

	// READ-ONLY; The type of Agent Job.
	JobCategory *string `json:"jobCategory,omitempty" azure:"ro"`

	// READ-ONLY; The owner of the Agent Job
	JobOwner *string `json:"jobOwner,omitempty" azure:"ro"`

	// READ-ONLY; UTC Date and time when the Agent Job was last executed.
	LastExecutedOn *time.Time `json:"lastExecutedOn,omitempty" azure:"ro"`

	// READ-ONLY; Information about eligibility of agent job for migration.
	MigrationEligibility *MigrationEligibilityInfo `json:"migrationEligibility,omitempty" azure:"ro"`

	// READ-ONLY; Agent Job name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// GetConnectToSourceSQLServerTaskOutput implements the ConnectToSourceSQLServerTaskOutputClassification interface for type
// ConnectToSourceSQLServerTaskOutputAgentJobLevel.
func (c *ConnectToSourceSQLServerTaskOutputAgentJobLevel) GetConnectToSourceSQLServerTaskOutput() *ConnectToSourceSQLServerTaskOutput {
	return &ConnectToSourceSQLServerTaskOutput{
		ID:         c.ID,
		ResultType: c.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceSQLServerTaskOutputAgentJobLevel.
func (c ConnectToSourceSQLServerTaskOutputAgentJobLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", c.ID)
	populate(objectMap, "isEnabled", c.IsEnabled)
	populate(objectMap, "jobCategory", c.JobCategory)
	populate(objectMap, "jobOwner", c.JobOwner)
	populateTimeRFC3339(objectMap, "lastExecutedOn", c.LastExecutedOn)
	populate(objectMap, "migrationEligibility", c.MigrationEligibility)
	populate(objectMap, "name", c.Name)
	objectMap["resultType"] = "AgentJobLevelOutput"
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourceSQLServerTaskOutputAgentJobLevel.
func (c *ConnectToSourceSQLServerTaskOutputAgentJobLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &c.ID)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, &c.IsEnabled)
			delete(rawMsg, key)
		case "jobCategory":
			err = unpopulate(val, &c.JobCategory)
			delete(rawMsg, key)
		case "jobOwner":
			err = unpopulate(val, &c.JobOwner)
			delete(rawMsg, key)
		case "lastExecutedOn":
			err = unpopulateTimeRFC3339(val, &c.LastExecutedOn)
			delete(rawMsg, key)
		case "migrationEligibility":
			err = unpopulate(val, &c.MigrationEligibility)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &c.Name)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &c.ResultType)
			delete(rawMsg, key)
		case "validationErrors":
			err = unpopulate(val, &c.ValidationErrors)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToSourceSQLServerTaskOutputDatabaseLevel - Database level output for the task that validates connection to SQL Server
// and also validates source server requirements
type ConnectToSourceSQLServerTaskOutputDatabaseLevel struct {
	// REQUIRED; Type of result - database level or task level
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; SQL Server compatibility level of database
	CompatibilityLevel *DatabaseCompatLevel `json:"compatibilityLevel,omitempty" azure:"ro"`

	// READ-ONLY; The list of database files
	DatabaseFiles []*DatabaseFileInfo `json:"databaseFiles,omitempty" azure:"ro"`

	// READ-ONLY; State of the database
	DatabaseState *DatabaseState `json:"databaseState,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Database name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Size of the file in megabytes
	SizeMB *float64 `json:"sizeMB,omitempty" azure:"ro"`
}

// GetConnectToSourceSQLServerTaskOutput implements the ConnectToSourceSQLServerTaskOutputClassification interface for type
// ConnectToSourceSQLServerTaskOutputDatabaseLevel.
func (c *ConnectToSourceSQLServerTaskOutputDatabaseLevel) GetConnectToSourceSQLServerTaskOutput() *ConnectToSourceSQLServerTaskOutput {
	return &ConnectToSourceSQLServerTaskOutput{
		ID:         c.ID,
		ResultType: c.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceSQLServerTaskOutputDatabaseLevel.
func (c ConnectToSourceSQLServerTaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compatibilityLevel", c.CompatibilityLevel)
	populate(objectMap, "databaseFiles", c.DatabaseFiles)
	populate(objectMap, "databaseState", c.DatabaseState)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	objectMap["resultType"] = "DatabaseLevelOutput"
	populate(objectMap, "sizeMB", c.SizeMB)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourceSQLServerTaskOutputDatabaseLevel.
func (c *ConnectToSourceSQLServerTaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compatibilityLevel":
			err = unpopulate(val, &c.CompatibilityLevel)
			delete(rawMsg, key)
		case "databaseFiles":
			err = unpopulate(val, &c.DatabaseFiles)
			delete(rawMsg, key)
		case "databaseState":
			err = unpopulate(val, &c.DatabaseState)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &c.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &c.Name)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &c.ResultType)
			delete(rawMsg, key)
		case "sizeMB":
			err = unpopulate(val, &c.SizeMB)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToSourceSQLServerTaskOutputLoginLevel - Login level output for the task that validates connection to SQL Server
// and also validates source server requirements
type ConnectToSourceSQLServerTaskOutputLoginLevel struct {
	// REQUIRED; Type of result - database level or task level
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; The default database for the login.
	DefaultDatabase *string `json:"defaultDatabase,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The state of the login.
	IsEnabled *bool `json:"isEnabled,omitempty" azure:"ro"`

	// READ-ONLY; The type of login.
	LoginType *LoginType `json:"loginType,omitempty" azure:"ro"`

	// READ-ONLY; Information about eligibility of login for migration.
	MigrationEligibility *MigrationEligibilityInfo `json:"migrationEligibility,omitempty" azure:"ro"`

	// READ-ONLY; Login name.
	Name *string `json:"name,omitempty" azure:"ro"`
}

// GetConnectToSourceSQLServerTaskOutput implements the ConnectToSourceSQLServerTaskOutputClassification interface for type
// ConnectToSourceSQLServerTaskOutputLoginLevel.
func (c *ConnectToSourceSQLServerTaskOutputLoginLevel) GetConnectToSourceSQLServerTaskOutput() *ConnectToSourceSQLServerTaskOutput {
	return &ConnectToSourceSQLServerTaskOutput{
		ID:         c.ID,
		ResultType: c.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceSQLServerTaskOutputLoginLevel.
func (c ConnectToSourceSQLServerTaskOutputLoginLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultDatabase", c.DefaultDatabase)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "isEnabled", c.IsEnabled)
	populate(objectMap, "loginType", c.LoginType)
	populate(objectMap, "migrationEligibility", c.MigrationEligibility)
	populate(objectMap, "name", c.Name)
	objectMap["resultType"] = "LoginLevelOutput"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourceSQLServerTaskOutputLoginLevel.
func (c *ConnectToSourceSQLServerTaskOutputLoginLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "defaultDatabase":
			err = unpopulate(val, &c.DefaultDatabase)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &c.ID)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, &c.IsEnabled)
			delete(rawMsg, key)
		case "loginType":
			err = unpopulate(val, &c.LoginType)
			delete(rawMsg, key)
		case "migrationEligibility":
			err = unpopulate(val, &c.MigrationEligibility)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &c.Name)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &c.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToSourceSQLServerTaskOutputTaskLevel - Task level output for the task that validates connection to SQL Server and
// also validates source server requirements
type ConnectToSourceSQLServerTaskOutputTaskLevel struct {
	// REQUIRED; Type of result - database level or task level
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Source agent jobs as a map from agent job name to id.
	AgentJobs *string `json:"agentJobs,omitempty" azure:"ro"`

	// READ-ONLY; Mapping from database name to TDE certificate name, if applicable
	DatabaseTdeCertificateMapping *string `json:"databaseTdeCertificateMapping,omitempty" azure:"ro"`

	// READ-ONLY; Source databases as a map from database name to database id
	Databases *string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Source logins as a map from login name to login id.
	Logins *string `json:"logins,omitempty" azure:"ro"`

	// READ-ONLY; Source server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// GetConnectToSourceSQLServerTaskOutput implements the ConnectToSourceSQLServerTaskOutputClassification interface for type
// ConnectToSourceSQLServerTaskOutputTaskLevel.
func (c *ConnectToSourceSQLServerTaskOutputTaskLevel) GetConnectToSourceSQLServerTaskOutput() *ConnectToSourceSQLServerTaskOutput {
	return &ConnectToSourceSQLServerTaskOutput{
		ID:         c.ID,
		ResultType: c.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceSQLServerTaskOutputTaskLevel.
func (c ConnectToSourceSQLServerTaskOutputTaskLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentJobs", c.AgentJobs)
	populate(objectMap, "databaseTdeCertificateMapping", c.DatabaseTdeCertificateMapping)
	populate(objectMap, "databases", c.Databases)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "logins", c.Logins)
	objectMap["resultType"] = "TaskLevelOutput"
	populate(objectMap, "sourceServerBrandVersion", c.SourceServerBrandVersion)
	populate(objectMap, "sourceServerVersion", c.SourceServerVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourceSQLServerTaskOutputTaskLevel.
func (c *ConnectToSourceSQLServerTaskOutputTaskLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentJobs":
			err = unpopulate(val, &c.AgentJobs)
			delete(rawMsg, key)
		case "databaseTdeCertificateMapping":
			err = unpopulate(val, &c.DatabaseTdeCertificateMapping)
			delete(rawMsg, key)
		case "databases":
			err = unpopulate(val, &c.Databases)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &c.ID)
			delete(rawMsg, key)
		case "logins":
			err = unpopulate(val, &c.Logins)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &c.ResultType)
			delete(rawMsg, key)
		case "sourceServerBrandVersion":
			err = unpopulate(val, &c.SourceServerBrandVersion)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &c.SourceServerVersion)
			delete(rawMsg, key)
		case "validationErrors":
			err = unpopulate(val, &c.ValidationErrors)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToSourceSQLServerTaskProperties - Properties for the task that validates connection to SQL Server and also validates
// source server requirements
type ConnectToSourceSQLServerTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *ConnectToSourceSQLServerTaskInput `json:"input,omitempty"`

	// Task id
	TaskID *string `json:"taskId,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []ConnectToSourceSQLServerTaskOutputClassification `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ConnectToSourceSQLServerTaskProperties.
func (c *ConnectToSourceSQLServerTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   c.TaskType,
		Errors:     c.Errors,
		State:      c.State,
		Commands:   c.Commands,
		ClientData: c.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceSQLServerTaskProperties.
func (c ConnectToSourceSQLServerTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", c.ClientData)
	populate(objectMap, "commands", c.Commands)
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	populate(objectMap, "state", c.State)
	populate(objectMap, "taskId", c.TaskID)
	objectMap["taskType"] = TaskTypeConnectToSourceSQLServer
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourceSQLServerTaskProperties.
func (c *ConnectToSourceSQLServerTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &c.ClientData)
			delete(rawMsg, key)
		case "commands":
			c.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &c.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			c.Output, err = unmarshalConnectToSourceSQLServerTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &c.State)
			delete(rawMsg, key)
		case "taskId":
			err = unpopulate(val, &c.TaskID)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &c.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToTargetAzureDbForMySQLTaskInput - Input for the task that validates connection to Azure Database for MySQL and
// target server requirements
type ConnectToTargetAzureDbForMySQLTaskInput struct {
	// REQUIRED; Connection information for source MySQL server
	SourceConnectionInfo *MySQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Connection information for target Azure Database for MySQL server
	TargetConnectionInfo *MySQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// Flag for whether or not the migration is offline
	IsOfflineMigration *bool `json:"isOfflineMigration,omitempty"`
}

// ConnectToTargetAzureDbForMySQLTaskOutput - Output for the task that validates connection to Azure Database for MySQL and
// target server requirements
type ConnectToTargetAzureDbForMySQLTaskOutput struct {
	// READ-ONLY; List of databases on target server
	Databases []*string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Version of the target server
	ServerVersion *string `json:"serverVersion,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors associated with the task
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetAzureDbForMySQLTaskOutput.
func (c ConnectToTargetAzureDbForMySQLTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databases", c.Databases)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "serverVersion", c.ServerVersion)
	populate(objectMap, "targetServerBrandVersion", c.TargetServerBrandVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// ConnectToTargetAzureDbForMySQLTaskProperties - Properties for the task that validates connection to Azure Database for
// MySQL and target server requirements
type ConnectToTargetAzureDbForMySQLTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *ConnectToTargetAzureDbForMySQLTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToTargetAzureDbForMySQLTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ConnectToTargetAzureDbForMySQLTaskProperties.
func (c *ConnectToTargetAzureDbForMySQLTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   c.TaskType,
		Errors:     c.Errors,
		State:      c.State,
		Commands:   c.Commands,
		ClientData: c.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetAzureDbForMySQLTaskProperties.
func (c ConnectToTargetAzureDbForMySQLTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", c.ClientData)
	populate(objectMap, "commands", c.Commands)
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	populate(objectMap, "state", c.State)
	objectMap["taskType"] = TaskTypeConnectToTargetAzureDbForMySQL
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToTargetAzureDbForMySQLTaskProperties.
func (c *ConnectToTargetAzureDbForMySQLTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &c.ClientData)
			delete(rawMsg, key)
		case "commands":
			c.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &c.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &c.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &c.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToTargetAzureDbForPostgreSQLSyncTaskInput - Input for the task that validates connection to Azure Database for PostgreSQL
// and target server requirements
type ConnectToTargetAzureDbForPostgreSQLSyncTaskInput struct {
	// REQUIRED; Connection information for source PostgreSQL server
	SourceConnectionInfo *PostgreSQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Connection information for target Azure Database for PostgreSQL server
	TargetConnectionInfo *PostgreSQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// ConnectToTargetAzureDbForPostgreSQLSyncTaskOutput - Output for the task that validates connection to Azure Database for
// PostgreSQL and target server requirements
type ConnectToTargetAzureDbForPostgreSQLSyncTaskOutput struct {
	// READ-ONLY; List of databases on target server
	Databases []*string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Version of the target server
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors associated with the task
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetAzureDbForPostgreSQLSyncTaskOutput.
func (c ConnectToTargetAzureDbForPostgreSQLSyncTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databases", c.Databases)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "targetServerBrandVersion", c.TargetServerBrandVersion)
	populate(objectMap, "targetServerVersion", c.TargetServerVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// ConnectToTargetAzureDbForPostgreSQLSyncTaskProperties - Properties for the task that validates connection to Azure Database
// For PostgreSQL server and target server requirements for online migration
type ConnectToTargetAzureDbForPostgreSQLSyncTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *ConnectToTargetAzureDbForPostgreSQLSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToTargetAzureDbForPostgreSQLSyncTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ConnectToTargetAzureDbForPostgreSQLSyncTaskProperties.
func (c *ConnectToTargetAzureDbForPostgreSQLSyncTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   c.TaskType,
		Errors:     c.Errors,
		State:      c.State,
		Commands:   c.Commands,
		ClientData: c.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetAzureDbForPostgreSQLSyncTaskProperties.
func (c ConnectToTargetAzureDbForPostgreSQLSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", c.ClientData)
	populate(objectMap, "commands", c.Commands)
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	populate(objectMap, "state", c.State)
	objectMap["taskType"] = TaskTypeConnectToTargetAzureDbForPostgreSQLSync
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToTargetAzureDbForPostgreSQLSyncTaskProperties.
func (c *ConnectToTargetAzureDbForPostgreSQLSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &c.ClientData)
			delete(rawMsg, key)
		case "commands":
			c.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &c.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &c.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &c.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskInput - Input for the task that validates connection to Azure Database
// for PostgreSQL and target server requirements for Oracle source.
type ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskInput struct {
	// REQUIRED; Connection information for target Azure Database for PostgreSQL server
	TargetConnectionInfo *PostgreSQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutput - Output for the task that validates connection to Azure Database
// for PostgreSQL and target server requirements for Oracle source.
type ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutput struct {
	// Mapping of schemas per database
	DatabaseSchemaMap []*ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutputDatabaseSchemaMapItem `json:"databaseSchemaMap,omitempty"`

	// READ-ONLY; List of databases on target server
	Databases []*string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Version of the target server
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors associated with the task
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutput.
func (c ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databaseSchemaMap", c.DatabaseSchemaMap)
	populate(objectMap, "databases", c.Databases)
	populate(objectMap, "targetServerBrandVersion", c.TargetServerBrandVersion)
	populate(objectMap, "targetServerVersion", c.TargetServerVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

type ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutputDatabaseSchemaMapItem struct {
	Database *string   `json:"database,omitempty"`
	Schemas  []*string `json:"schemas,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutputDatabaseSchemaMapItem.
func (c ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutputDatabaseSchemaMapItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "database", c.Database)
	populate(objectMap, "schemas", c.Schemas)
	return json.Marshal(objectMap)
}

// ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskProperties - Properties for the task that validates connection to Azure
// Database For PostgreSQL server and target server requirements for online migration for Oracle source.
type ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskProperties.
func (c *ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   c.TaskType,
		Errors:     c.Errors,
		State:      c.State,
		Commands:   c.Commands,
		ClientData: c.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskProperties.
func (c ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", c.ClientData)
	populate(objectMap, "commands", c.Commands)
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	populate(objectMap, "state", c.State)
	objectMap["taskType"] = TaskTypeConnectToTargetOracleAzureDbForPostgreSQLSync
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskProperties.
func (c *ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &c.ClientData)
			delete(rawMsg, key)
		case "commands":
			c.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &c.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &c.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &c.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToTargetSQLDbSyncTaskInput - Input for the task that validates connection to Azure SQL DB and target server requirements
type ConnectToTargetSQLDbSyncTaskInput struct {
	// REQUIRED; Connection information for source SQL Server
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Connection information for target SQL DB
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// ConnectToTargetSQLDbSyncTaskProperties - Properties for the task that validates connection to SQL DB and target server
// requirements for online migration
type ConnectToTargetSQLDbSyncTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *ConnectToTargetSQLDbSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToTargetSQLDbTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ConnectToTargetSQLDbSyncTaskProperties.
func (c *ConnectToTargetSQLDbSyncTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   c.TaskType,
		Errors:     c.Errors,
		State:      c.State,
		Commands:   c.Commands,
		ClientData: c.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetSQLDbSyncTaskProperties.
func (c ConnectToTargetSQLDbSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", c.ClientData)
	populate(objectMap, "commands", c.Commands)
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	populate(objectMap, "state", c.State)
	objectMap["taskType"] = TaskTypeConnectToTargetSQLDbSync
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToTargetSQLDbSyncTaskProperties.
func (c *ConnectToTargetSQLDbSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &c.ClientData)
			delete(rawMsg, key)
		case "commands":
			c.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &c.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &c.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &c.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToTargetSQLDbTaskInput - Input for the task that validates connection to SQL DB and target server requirements
type ConnectToTargetSQLDbTaskInput struct {
	// REQUIRED; Connection information for target SQL DB
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// Boolean flag indicating whether to query object counts for each database on the target server
	QueryObjectCounts *bool `json:"queryObjectCounts,omitempty"`
}

// ConnectToTargetSQLDbTaskOutput - Output for the task that validates connection to SQL DB and target server requirements
type ConnectToTargetSQLDbTaskOutput struct {
	// READ-ONLY; Source databases as a map from database name to database id
	Databases *string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Version of the target server
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// ConnectToTargetSQLDbTaskProperties - Properties for the task that validates connection to SQL DB and target server requirements
type ConnectToTargetSQLDbTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// DateTime in UTC when the task was created
	CreatedOn *string `json:"createdOn,omitempty"`

	// Task input
	Input *ConnectToTargetSQLDbTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToTargetSQLDbTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ConnectToTargetSQLDbTaskProperties.
func (c *ConnectToTargetSQLDbTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   c.TaskType,
		Errors:     c.Errors,
		State:      c.State,
		Commands:   c.Commands,
		ClientData: c.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetSQLDbTaskProperties.
func (c ConnectToTargetSQLDbTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", c.ClientData)
	populate(objectMap, "commands", c.Commands)
	populate(objectMap, "createdOn", c.CreatedOn)
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	populate(objectMap, "state", c.State)
	objectMap["taskType"] = TaskTypeConnectToTargetSQLDb
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToTargetSQLDbTaskProperties.
func (c *ConnectToTargetSQLDbTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &c.ClientData)
			delete(rawMsg, key)
		case "commands":
			c.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulate(val, &c.CreatedOn)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &c.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &c.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &c.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToTargetSQLMISyncTaskInput - Input for the task that validates connection to Azure SQL Database Managed Instance
// online scenario.
type ConnectToTargetSQLMISyncTaskInput struct {
	// REQUIRED; Azure Active Directory Application the DMS instance will use to connect to the target instance of Azure SQL Database
	// Managed Instance and the Azure Storage Account
	AzureApp *AzureActiveDirectoryApp `json:"azureApp,omitempty"`

	// REQUIRED; Connection information for Azure SQL Database Managed Instance
	TargetConnectionInfo *MiSQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// ConnectToTargetSQLMISyncTaskOutput - Output for the task that validates connection to Azure SQL Database Managed Instance.
type ConnectToTargetSQLMISyncTaskOutput struct {
	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetSQLMISyncTaskOutput.
func (c ConnectToTargetSQLMISyncTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "targetServerBrandVersion", c.TargetServerBrandVersion)
	populate(objectMap, "targetServerVersion", c.TargetServerVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// ConnectToTargetSQLMISyncTaskProperties - Properties for the task that validates connection to Azure SQL Database Managed
// Instance
type ConnectToTargetSQLMISyncTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *ConnectToTargetSQLMISyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToTargetSQLMISyncTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ConnectToTargetSQLMISyncTaskProperties.
func (c *ConnectToTargetSQLMISyncTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   c.TaskType,
		Errors:     c.Errors,
		State:      c.State,
		Commands:   c.Commands,
		ClientData: c.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetSQLMISyncTaskProperties.
func (c ConnectToTargetSQLMISyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", c.ClientData)
	populate(objectMap, "commands", c.Commands)
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	populate(objectMap, "state", c.State)
	objectMap["taskType"] = TaskTypeConnectToTargetAzureSQLDbMISyncLRS
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToTargetSQLMISyncTaskProperties.
func (c *ConnectToTargetSQLMISyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &c.ClientData)
			delete(rawMsg, key)
		case "commands":
			c.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &c.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &c.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &c.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToTargetSQLMITaskInput - Input for the task that validates connection to Azure SQL Database Managed Instance.
type ConnectToTargetSQLMITaskInput struct {
	// REQUIRED; Connection information for target SQL Server
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// Flag for whether to collect agent jobs from target SQL MI server.
	CollectAgentJobs *bool `json:"collectAgentJobs,omitempty"`

	// Flag for whether to collect logins from target SQL MI server.
	CollectLogins *bool `json:"collectLogins,omitempty"`

	// Flag for whether to validate SSIS catalog is reachable on the target SQL MI server.
	ValidateSsisCatalogOnly *bool `json:"validateSsisCatalogOnly,omitempty"`
}

// ConnectToTargetSQLMITaskOutput - Output for the task that validates connection to Azure SQL Database Managed Instance.
type ConnectToTargetSQLMITaskOutput struct {
	// READ-ONLY; List of agent jobs on the target server.
	AgentJobs []*string `json:"agentJobs,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; List of logins on the target server.
	Logins []*string `json:"logins,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetSQLMITaskOutput.
func (c ConnectToTargetSQLMITaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentJobs", c.AgentJobs)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "logins", c.Logins)
	populate(objectMap, "targetServerBrandVersion", c.TargetServerBrandVersion)
	populate(objectMap, "targetServerVersion", c.TargetServerVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// ConnectToTargetSQLMITaskProperties - Properties for the task that validates connection to Azure SQL Database Managed Instance
type ConnectToTargetSQLMITaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *ConnectToTargetSQLMITaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToTargetSQLMITaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ConnectToTargetSQLMITaskProperties.
func (c *ConnectToTargetSQLMITaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   c.TaskType,
		Errors:     c.Errors,
		State:      c.State,
		Commands:   c.Commands,
		ClientData: c.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetSQLMITaskProperties.
func (c ConnectToTargetSQLMITaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", c.ClientData)
	populate(objectMap, "commands", c.Commands)
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	populate(objectMap, "state", c.State)
	objectMap["taskType"] = TaskTypeConnectToTargetAzureSQLDbMI
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToTargetSQLMITaskProperties.
func (c *ConnectToTargetSQLMITaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &c.ClientData)
			delete(rawMsg, key)
		case "commands":
			c.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &c.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &c.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &c.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectionInfoClassification provides polymorphic access to related types.
// Call the interface's GetConnectionInfo() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ConnectionInfo, *MiSQLConnectionInfo, *MongoDbConnectionInfo, *MySQLConnectionInfo, *OracleConnectionInfo, *PostgreSQLConnectionInfo,
// - *SQLConnectionInfo
type ConnectionInfoClassification interface {
	// GetConnectionInfo returns the ConnectionInfo content of the underlying type.
	GetConnectionInfo() *ConnectionInfo
}

// ConnectionInfo - Defines the connection properties of a server
type ConnectionInfo struct {
	// REQUIRED; Type of connection info
	Type *string `json:"type,omitempty"`

	// Password credential.
	Password *string `json:"password,omitempty"`

	// User name
	UserName *string `json:"userName,omitempty"`
}

// GetConnectionInfo implements the ConnectionInfoClassification interface for type ConnectionInfo.
func (c *ConnectionInfo) GetConnectionInfo() *ConnectionInfo { return c }

// CopyProgressDetails - Details on progress of ADF copy activity
type CopyProgressDetails struct {
	// READ-ONLY; Copy Duration in seconds
	CopyDuration *int32 `json:"copyDuration,omitempty" azure:"ro"`

	// READ-ONLY; Copy Start
	CopyStart *time.Time `json:"copyStart,omitempty" azure:"ro"`

	// READ-ONLY; Copy throughput in KBps
	CopyThroughput *float64 `json:"copyThroughput,omitempty" azure:"ro"`

	// READ-ONLY; Bytes read
	DataRead *int64 `json:"dataRead,omitempty" azure:"ro"`

	// READ-ONLY; Bytes written
	DataWritten *int64 `json:"dataWritten,omitempty" azure:"ro"`

	// READ-ONLY; Type of parallel copy (Dynamic range, Physical partition, none).
	ParallelCopyType *string `json:"parallelCopyType,omitempty" azure:"ro"`

	// READ-ONLY; Rows Copied
	RowsCopied *int64 `json:"rowsCopied,omitempty" azure:"ro"`

	// READ-ONLY; Rows read
	RowsRead *int64 `json:"rowsRead,omitempty" azure:"ro"`

	// READ-ONLY; Status of the Copy activity (InProgress, Succeeded, Failed, Canceled).
	Status *string `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Table Name
	TableName *string `json:"tableName,omitempty" azure:"ro"`

	// READ-ONLY; The degree of parallelization.
	UsedParallelCopies *int32 `json:"usedParallelCopies,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CopyProgressDetails.
func (c CopyProgressDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "copyDuration", c.CopyDuration)
	populateTimeRFC3339(objectMap, "copyStart", c.CopyStart)
	populate(objectMap, "copyThroughput", c.CopyThroughput)
	populate(objectMap, "dataRead", c.DataRead)
	populate(objectMap, "dataWritten", c.DataWritten)
	populate(objectMap, "parallelCopyType", c.ParallelCopyType)
	populate(objectMap, "rowsCopied", c.RowsCopied)
	populate(objectMap, "rowsRead", c.RowsRead)
	populate(objectMap, "status", c.Status)
	populate(objectMap, "tableName", c.TableName)
	populate(objectMap, "usedParallelCopies", c.UsedParallelCopies)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CopyProgressDetails.
func (c *CopyProgressDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "copyDuration":
			err = unpopulate(val, &c.CopyDuration)
			delete(rawMsg, key)
		case "copyStart":
			err = unpopulateTimeRFC3339(val, &c.CopyStart)
			delete(rawMsg, key)
		case "copyThroughput":
			err = unpopulate(val, &c.CopyThroughput)
			delete(rawMsg, key)
		case "dataRead":
			err = unpopulate(val, &c.DataRead)
			delete(rawMsg, key)
		case "dataWritten":
			err = unpopulate(val, &c.DataWritten)
			delete(rawMsg, key)
		case "parallelCopyType":
			err = unpopulate(val, &c.ParallelCopyType)
			delete(rawMsg, key)
		case "rowsCopied":
			err = unpopulate(val, &c.RowsCopied)
			delete(rawMsg, key)
		case "rowsRead":
			err = unpopulate(val, &c.RowsRead)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &c.Status)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, &c.TableName)
			delete(rawMsg, key)
		case "usedParallelCopies":
			err = unpopulate(val, &c.UsedParallelCopies)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataIntegrityValidationResult - Results for checksum based Data Integrity validation results
type DataIntegrityValidationResult struct {
	// List of failed table names of source and target pair
	FailedObjects map[string]*string `json:"failedObjects,omitempty"`

	// List of errors that happened while performing data integrity validation
	ValidationErrors *ValidationError `json:"validationErrors,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataIntegrityValidationResult.
func (d DataIntegrityValidationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "failedObjects", d.FailedObjects)
	populate(objectMap, "validationErrors", d.ValidationErrors)
	return json.Marshal(objectMap)
}

// DataItemMigrationSummaryResult - Basic summary of a data item migration
type DataItemMigrationSummaryResult struct {
	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all errors of the item
	ErrorPrefix *string `json:"errorPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Number of successfully completed items
	ItemsCompletedCount *int64 `json:"itemsCompletedCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of items
	ItemsCount *int64 `json:"itemsCount,omitempty" azure:"ro"`

	// READ-ONLY; Name of the item
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all sub-tem results of the item
	ResultPrefix *string `json:"resultPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Status message
	StatusMessage *string `json:"statusMessage,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataItemMigrationSummaryResult.
func (d DataItemMigrationSummaryResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endedOn", d.EndedOn)
	populate(objectMap, "errorPrefix", d.ErrorPrefix)
	populate(objectMap, "itemsCompletedCount", d.ItemsCompletedCount)
	populate(objectMap, "itemsCount", d.ItemsCount)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "resultPrefix", d.ResultPrefix)
	populateTimeRFC3339(objectMap, "startedOn", d.StartedOn)
	populate(objectMap, "state", d.State)
	populate(objectMap, "statusMessage", d.StatusMessage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataItemMigrationSummaryResult.
func (d *DataItemMigrationSummaryResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &d.EndedOn)
			delete(rawMsg, key)
		case "errorPrefix":
			err = unpopulate(val, &d.ErrorPrefix)
			delete(rawMsg, key)
		case "itemsCompletedCount":
			err = unpopulate(val, &d.ItemsCompletedCount)
			delete(rawMsg, key)
		case "itemsCount":
			err = unpopulate(val, &d.ItemsCount)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "resultPrefix":
			err = unpopulate(val, &d.ResultPrefix)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &d.StartedOn)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &d.State)
			delete(rawMsg, key)
		case "statusMessage":
			err = unpopulate(val, &d.StatusMessage)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Database - Information about a single database
type Database struct {
	// Collation name of the database
	Collation *string `json:"collation,omitempty"`

	// SQL Server compatibility level of database
	CompatibilityLevel *DatabaseCompatLevel `json:"compatibilityLevel,omitempty"`

	// State of the database
	DatabaseState *DatabaseState `json:"databaseState,omitempty"`

	// Fully qualified name
	Fqdn *string `json:"fqdn,omitempty"`

	// Unique identifier for the database
	ID *string `json:"id,omitempty"`

	// Install id of the database
	InstallID *string `json:"installId,omitempty"`

	// Name of the database
	Name *string `json:"name,omitempty"`

	// Number of cores on the server
	ServerCoreCount *int32 `json:"serverCoreCount,omitempty"`

	// Default path of the backup folder
	ServerDefaultBackupPath *string `json:"serverDefaultBackupPath,omitempty"`

	// Default path of the data files
	ServerDefaultDataPath *string `json:"serverDefaultDataPath,omitempty"`

	// Default path of the log files
	ServerDefaultLogPath *string `json:"serverDefaultLogPath,omitempty"`

	// Edition of the server
	ServerEdition *string `json:"serverEdition,omitempty"`

	// The unique Server Id
	ServerID *string `json:"serverId,omitempty"`

	// Product level of the server (RTM, SP, CTP).
	ServerLevel *string `json:"serverLevel,omitempty"`

	// Name of the server
	ServerName *string `json:"serverName,omitempty"`

	// Version of the server
	ServerVersion *string `json:"serverVersion,omitempty"`

	// Number of cores on the server that have VISIBLE ONLINE status
	ServerVisibleOnlineCoreCount *int32 `json:"serverVisibleOnlineCoreCount,omitempty"`
}

// DatabaseBackupInfo - Information about backup files when existing backup mode is used.
type DatabaseBackupInfo struct {
	// READ-ONLY; The list of backup files for the current database.
	BackupFiles []*string `json:"backupFiles,omitempty" azure:"ro"`

	// READ-ONLY; Date and time when the backup operation finished.
	BackupFinishDate *time.Time `json:"backupFinishDate,omitempty" azure:"ro"`

	// READ-ONLY; Backup Type.
	BackupType *BackupType `json:"backupType,omitempty" azure:"ro"`

	// READ-ONLY; Database name.
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Number of files in the backup set.
	FamilyCount *int32 `json:"familyCount,omitempty" azure:"ro"`

	// READ-ONLY; Whether the backup set is compressed
	IsCompressed *bool `json:"isCompressed,omitempty" azure:"ro"`

	// READ-ONLY; Database was damaged when backed up, but the backup operation was requested to continue despite errors.
	IsDamaged *bool `json:"isDamaged,omitempty" azure:"ro"`

	// READ-ONLY; Position of current database backup in the file.
	Position *int32 `json:"position,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseBackupInfo.
func (d DatabaseBackupInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupFiles", d.BackupFiles)
	populateTimeRFC3339(objectMap, "backupFinishDate", d.BackupFinishDate)
	populate(objectMap, "backupType", d.BackupType)
	populate(objectMap, "databaseName", d.DatabaseName)
	populate(objectMap, "familyCount", d.FamilyCount)
	populate(objectMap, "isCompressed", d.IsCompressed)
	populate(objectMap, "isDamaged", d.IsDamaged)
	populate(objectMap, "position", d.Position)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseBackupInfo.
func (d *DatabaseBackupInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupFiles":
			err = unpopulate(val, &d.BackupFiles)
			delete(rawMsg, key)
		case "backupFinishDate":
			err = unpopulateTimeRFC3339(val, &d.BackupFinishDate)
			delete(rawMsg, key)
		case "backupType":
			err = unpopulate(val, &d.BackupType)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &d.DatabaseName)
			delete(rawMsg, key)
		case "familyCount":
			err = unpopulate(val, &d.FamilyCount)
			delete(rawMsg, key)
		case "isCompressed":
			err = unpopulate(val, &d.IsCompressed)
			delete(rawMsg, key)
		case "isDamaged":
			err = unpopulate(val, &d.IsDamaged)
			delete(rawMsg, key)
		case "position":
			err = unpopulate(val, &d.Position)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatabaseFileInfo - Database file specific information
type DatabaseFileInfo struct {
	// Name of the database
	DatabaseName *string `json:"databaseName,omitempty"`

	// Database file type
	FileType *DatabaseFileType `json:"fileType,omitempty"`

	// Unique identifier for database file
	ID *string `json:"id,omitempty"`

	// Logical name of the file
	LogicalName *string `json:"logicalName,omitempty"`

	// Operating-system full path of the file
	PhysicalFullName *string `json:"physicalFullName,omitempty"`

	// Suggested full path of the file for restoring
	RestoreFullName *string `json:"restoreFullName,omitempty"`

	// Size of the file in megabytes
	SizeMB *float64 `json:"sizeMB,omitempty"`
}

// DatabaseFileInput - Database file specific information for input
type DatabaseFileInput struct {
	// Database file type
	FileType *DatabaseFileType `json:"fileType,omitempty"`

	// Unique identifier for database file
	ID *string `json:"id,omitempty"`

	// Logical name of the file
	LogicalName *string `json:"logicalName,omitempty"`

	// Operating-system full path of the file
	PhysicalFullName *string `json:"physicalFullName,omitempty"`

	// Suggested full path of the file for restoring
	RestoreFullName *string `json:"restoreFullName,omitempty"`
}

// DatabaseInfo - Project Database Details
type DatabaseInfo struct {
	// REQUIRED; Name of the database
	SourceDatabaseName *string `json:"sourceDatabaseName,omitempty"`
}

// DatabaseMigration - Database Migration Resource.
type DatabaseMigration struct {
	// Database Migration Resource properties.
	Properties DatabaseMigrationPropertiesClassification `json:"properties,omitempty"`

	// READ-ONLY
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseMigration.
func (d DatabaseMigration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", d.ID)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseMigration.
func (d *DatabaseMigration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &d.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "properties":
			d.Properties, err = unmarshalDatabaseMigrationPropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &d.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &d.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatabaseMigrationListResult - A list of Database Migrations.
type DatabaseMigrationListResult struct {
	// READ-ONLY
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY
	Value []*DatabaseMigration `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseMigrationListResult.
func (d DatabaseMigrationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DatabaseMigrationPropertiesClassification provides polymorphic access to related types.
// Call the interface's GetDatabaseMigrationProperties() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DatabaseMigrationProperties, *DatabaseMigrationPropertiesSQLDb, *DatabaseMigrationPropertiesSQLMi, *DatabaseMigrationPropertiesSQLVM
type DatabaseMigrationPropertiesClassification interface {
	// GetDatabaseMigrationProperties returns the DatabaseMigrationProperties content of the underlying type.
	GetDatabaseMigrationProperties() *DatabaseMigrationProperties
}

// DatabaseMigrationProperties - Database Migration Resource properties.
type DatabaseMigrationProperties struct {
	// REQUIRED
	Kind *ResourceType `json:"kind,omitempty"`

	// ID tracking current migration operation.
	MigrationOperationID *string `json:"migrationOperationId,omitempty"`

	// Resource Id of the Migration Service.
	MigrationService *string `json:"migrationService,omitempty"`

	// Error message for migration provisioning failure, if any.
	ProvisioningError *string `json:"provisioningError,omitempty"`

	// Resource Id of the target resource (SQL VM or SQL Managed Instance).
	Scope *string `json:"scope,omitempty"`

	// Name of the source database.
	SourceDatabaseName *string `json:"sourceDatabaseName,omitempty"`

	// Source SQL Server connection details.
	SourceSQLConnection *SQLConnectionInformation `json:"sourceSqlConnection,omitempty"`

	// Database collation to be used for the target database.
	TargetDatabaseCollation *string `json:"targetDatabaseCollation,omitempty"`

	// READ-ONLY; Database migration end time.
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Error details in case of migration failure.
	MigrationFailureError *ErrorInfo `json:"migrationFailureError,omitempty" azure:"ro"`

	// READ-ONLY; Migration status.
	MigrationStatus *string `json:"migrationStatus,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning State of migration. ProvisioningState as Succeeded implies that validations have been performed
	// and migration has started.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Name of the source sql server.
	SourceServerName *string `json:"sourceServerName,omitempty" azure:"ro"`

	// READ-ONLY; Database migration start time.
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`
}

// GetDatabaseMigrationProperties implements the DatabaseMigrationPropertiesClassification interface for type DatabaseMigrationProperties.
func (d *DatabaseMigrationProperties) GetDatabaseMigrationProperties() *DatabaseMigrationProperties {
	return d
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseMigrationProperties.
func (d DatabaseMigrationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endedOn", d.EndedOn)
	objectMap["kind"] = d.Kind
	populate(objectMap, "migrationFailureError", d.MigrationFailureError)
	populate(objectMap, "migrationOperationId", d.MigrationOperationID)
	populate(objectMap, "migrationService", d.MigrationService)
	populate(objectMap, "migrationStatus", d.MigrationStatus)
	populate(objectMap, "provisioningError", d.ProvisioningError)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "scope", d.Scope)
	populate(objectMap, "sourceDatabaseName", d.SourceDatabaseName)
	populate(objectMap, "sourceSqlConnection", d.SourceSQLConnection)
	populate(objectMap, "sourceServerName", d.SourceServerName)
	populateTimeRFC3339(objectMap, "startedOn", d.StartedOn)
	populate(objectMap, "targetDatabaseCollation", d.TargetDatabaseCollation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseMigrationProperties.
func (d *DatabaseMigrationProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &d.EndedOn)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &d.Kind)
			delete(rawMsg, key)
		case "migrationFailureError":
			err = unpopulate(val, &d.MigrationFailureError)
			delete(rawMsg, key)
		case "migrationOperationId":
			err = unpopulate(val, &d.MigrationOperationID)
			delete(rawMsg, key)
		case "migrationService":
			err = unpopulate(val, &d.MigrationService)
			delete(rawMsg, key)
		case "migrationStatus":
			err = unpopulate(val, &d.MigrationStatus)
			delete(rawMsg, key)
		case "provisioningError":
			err = unpopulate(val, &d.ProvisioningError)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &d.ProvisioningState)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &d.Scope)
			delete(rawMsg, key)
		case "sourceDatabaseName":
			err = unpopulate(val, &d.SourceDatabaseName)
			delete(rawMsg, key)
		case "sourceSqlConnection":
			err = unpopulate(val, &d.SourceSQLConnection)
			delete(rawMsg, key)
		case "sourceServerName":
			err = unpopulate(val, &d.SourceServerName)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &d.StartedOn)
			delete(rawMsg, key)
		case "targetDatabaseCollation":
			err = unpopulate(val, &d.TargetDatabaseCollation)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatabaseMigrationPropertiesSQLDb - Database Migration Resource properties for SQL database.
type DatabaseMigrationPropertiesSQLDb struct {
	// REQUIRED
	Kind *ResourceType `json:"kind,omitempty"`

	// ID tracking current migration operation.
	MigrationOperationID *string `json:"migrationOperationId,omitempty"`

	// Resource Id of the Migration Service.
	MigrationService *string `json:"migrationService,omitempty"`

	// Error message for migration provisioning failure, if any.
	ProvisioningError *string `json:"provisioningError,omitempty"`

	// Resource Id of the target resource (SQL VM or SQL Managed Instance).
	Scope *string `json:"scope,omitempty"`

	// Name of the source database.
	SourceDatabaseName *string `json:"sourceDatabaseName,omitempty"`

	// Source SQL Server connection details.
	SourceSQLConnection *SQLConnectionInformation `json:"sourceSqlConnection,omitempty"`

	// List of tables to copy.
	TableList []*string `json:"tableList,omitempty"`

	// Database collation to be used for the target database.
	TargetDatabaseCollation *string `json:"targetDatabaseCollation,omitempty"`

	// Target SQL DB connection details.
	TargetSQLConnection *SQLConnectionInformation `json:"targetSqlConnection,omitempty"`

	// READ-ONLY; Database migration end time.
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Error details in case of migration failure.
	MigrationFailureError *ErrorInfo `json:"migrationFailureError,omitempty" azure:"ro"`

	// READ-ONLY; Migration status.
	MigrationStatus *string `json:"migrationStatus,omitempty" azure:"ro"`

	// READ-ONLY; Detailed migration status. Not included by default.
	MigrationStatusDetails *SQLDbMigrationStatusDetails `json:"migrationStatusDetails,omitempty" azure:"ro"`

	// READ-ONLY; Offline configuration.
	OfflineConfiguration *SQLDbOfflineConfiguration `json:"offlineConfiguration,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning State of migration. ProvisioningState as Succeeded implies that validations have been performed
	// and migration has started.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Name of the source sql server.
	SourceServerName *string `json:"sourceServerName,omitempty" azure:"ro"`

	// READ-ONLY; Database migration start time.
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`
}

// GetDatabaseMigrationProperties implements the DatabaseMigrationPropertiesClassification interface for type DatabaseMigrationPropertiesSQLDb.
func (d *DatabaseMigrationPropertiesSQLDb) GetDatabaseMigrationProperties() *DatabaseMigrationProperties {
	return &DatabaseMigrationProperties{
		Kind:                    d.Kind,
		Scope:                   d.Scope,
		ProvisioningState:       d.ProvisioningState,
		MigrationStatus:         d.MigrationStatus,
		StartedOn:               d.StartedOn,
		EndedOn:                 d.EndedOn,
		SourceSQLConnection:     d.SourceSQLConnection,
		SourceDatabaseName:      d.SourceDatabaseName,
		SourceServerName:        d.SourceServerName,
		MigrationService:        d.MigrationService,
		MigrationOperationID:    d.MigrationOperationID,
		MigrationFailureError:   d.MigrationFailureError,
		TargetDatabaseCollation: d.TargetDatabaseCollation,
		ProvisioningError:       d.ProvisioningError,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseMigrationPropertiesSQLDb.
func (d DatabaseMigrationPropertiesSQLDb) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endedOn", d.EndedOn)
	objectMap["kind"] = ResourceTypeSQLDb
	populate(objectMap, "migrationFailureError", d.MigrationFailureError)
	populate(objectMap, "migrationOperationId", d.MigrationOperationID)
	populate(objectMap, "migrationService", d.MigrationService)
	populate(objectMap, "migrationStatus", d.MigrationStatus)
	populate(objectMap, "migrationStatusDetails", d.MigrationStatusDetails)
	populate(objectMap, "offlineConfiguration", d.OfflineConfiguration)
	populate(objectMap, "provisioningError", d.ProvisioningError)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "scope", d.Scope)
	populate(objectMap, "sourceDatabaseName", d.SourceDatabaseName)
	populate(objectMap, "sourceSqlConnection", d.SourceSQLConnection)
	populate(objectMap, "sourceServerName", d.SourceServerName)
	populateTimeRFC3339(objectMap, "startedOn", d.StartedOn)
	populate(objectMap, "tableList", d.TableList)
	populate(objectMap, "targetDatabaseCollation", d.TargetDatabaseCollation)
	populate(objectMap, "targetSqlConnection", d.TargetSQLConnection)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseMigrationPropertiesSQLDb.
func (d *DatabaseMigrationPropertiesSQLDb) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &d.EndedOn)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &d.Kind)
			delete(rawMsg, key)
		case "migrationFailureError":
			err = unpopulate(val, &d.MigrationFailureError)
			delete(rawMsg, key)
		case "migrationOperationId":
			err = unpopulate(val, &d.MigrationOperationID)
			delete(rawMsg, key)
		case "migrationService":
			err = unpopulate(val, &d.MigrationService)
			delete(rawMsg, key)
		case "migrationStatus":
			err = unpopulate(val, &d.MigrationStatus)
			delete(rawMsg, key)
		case "migrationStatusDetails":
			err = unpopulate(val, &d.MigrationStatusDetails)
			delete(rawMsg, key)
		case "offlineConfiguration":
			err = unpopulate(val, &d.OfflineConfiguration)
			delete(rawMsg, key)
		case "provisioningError":
			err = unpopulate(val, &d.ProvisioningError)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &d.ProvisioningState)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &d.Scope)
			delete(rawMsg, key)
		case "sourceDatabaseName":
			err = unpopulate(val, &d.SourceDatabaseName)
			delete(rawMsg, key)
		case "sourceSqlConnection":
			err = unpopulate(val, &d.SourceSQLConnection)
			delete(rawMsg, key)
		case "sourceServerName":
			err = unpopulate(val, &d.SourceServerName)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &d.StartedOn)
			delete(rawMsg, key)
		case "tableList":
			err = unpopulate(val, &d.TableList)
			delete(rawMsg, key)
		case "targetDatabaseCollation":
			err = unpopulate(val, &d.TargetDatabaseCollation)
			delete(rawMsg, key)
		case "targetSqlConnection":
			err = unpopulate(val, &d.TargetSQLConnection)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatabaseMigrationPropertiesSQLMi - Database Migration Resource properties for SQL Managed Instance.
type DatabaseMigrationPropertiesSQLMi struct {
	// REQUIRED
	Kind *ResourceType `json:"kind,omitempty"`

	// Backup configuration info.
	BackupConfiguration *BackupConfiguration `json:"backupConfiguration,omitempty"`

	// ID tracking current migration operation.
	MigrationOperationID *string `json:"migrationOperationId,omitempty"`

	// Resource Id of the Migration Service.
	MigrationService *string `json:"migrationService,omitempty"`

	// Offline configuration.
	OfflineConfiguration *OfflineConfiguration `json:"offlineConfiguration,omitempty"`

	// Error message for migration provisioning failure, if any.
	ProvisioningError *string `json:"provisioningError,omitempty"`

	// Resource Id of the target resource (SQL VM or SQL Managed Instance).
	Scope *string `json:"scope,omitempty"`

	// Name of the source database.
	SourceDatabaseName *string `json:"sourceDatabaseName,omitempty"`

	// Source SQL Server connection details.
	SourceSQLConnection *SQLConnectionInformation `json:"sourceSqlConnection,omitempty"`

	// Database collation to be used for the target database.
	TargetDatabaseCollation *string `json:"targetDatabaseCollation,omitempty"`

	// READ-ONLY; Database migration end time.
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Error details in case of migration failure.
	MigrationFailureError *ErrorInfo `json:"migrationFailureError,omitempty" azure:"ro"`

	// READ-ONLY; Migration status.
	MigrationStatus *string `json:"migrationStatus,omitempty" azure:"ro"`

	// READ-ONLY; Detailed migration status. Not included by default.
	MigrationStatusDetails *MigrationStatusDetails `json:"migrationStatusDetails,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning State of migration. ProvisioningState as Succeeded implies that validations have been performed
	// and migration has started.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Name of the source sql server.
	SourceServerName *string `json:"sourceServerName,omitempty" azure:"ro"`

	// READ-ONLY; Database migration start time.
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`
}

// GetDatabaseMigrationProperties implements the DatabaseMigrationPropertiesClassification interface for type DatabaseMigrationPropertiesSQLMi.
func (d *DatabaseMigrationPropertiesSQLMi) GetDatabaseMigrationProperties() *DatabaseMigrationProperties {
	return &DatabaseMigrationProperties{
		Kind:                    d.Kind,
		Scope:                   d.Scope,
		ProvisioningState:       d.ProvisioningState,
		MigrationStatus:         d.MigrationStatus,
		StartedOn:               d.StartedOn,
		EndedOn:                 d.EndedOn,
		SourceSQLConnection:     d.SourceSQLConnection,
		SourceDatabaseName:      d.SourceDatabaseName,
		SourceServerName:        d.SourceServerName,
		MigrationService:        d.MigrationService,
		MigrationOperationID:    d.MigrationOperationID,
		MigrationFailureError:   d.MigrationFailureError,
		TargetDatabaseCollation: d.TargetDatabaseCollation,
		ProvisioningError:       d.ProvisioningError,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseMigrationPropertiesSQLMi.
func (d DatabaseMigrationPropertiesSQLMi) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupConfiguration", d.BackupConfiguration)
	populateTimeRFC3339(objectMap, "endedOn", d.EndedOn)
	objectMap["kind"] = ResourceTypeSQLMi
	populate(objectMap, "migrationFailureError", d.MigrationFailureError)
	populate(objectMap, "migrationOperationId", d.MigrationOperationID)
	populate(objectMap, "migrationService", d.MigrationService)
	populate(objectMap, "migrationStatus", d.MigrationStatus)
	populate(objectMap, "migrationStatusDetails", d.MigrationStatusDetails)
	populate(objectMap, "offlineConfiguration", d.OfflineConfiguration)
	populate(objectMap, "provisioningError", d.ProvisioningError)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "scope", d.Scope)
	populate(objectMap, "sourceDatabaseName", d.SourceDatabaseName)
	populate(objectMap, "sourceSqlConnection", d.SourceSQLConnection)
	populate(objectMap, "sourceServerName", d.SourceServerName)
	populateTimeRFC3339(objectMap, "startedOn", d.StartedOn)
	populate(objectMap, "targetDatabaseCollation", d.TargetDatabaseCollation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseMigrationPropertiesSQLMi.
func (d *DatabaseMigrationPropertiesSQLMi) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupConfiguration":
			err = unpopulate(val, &d.BackupConfiguration)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &d.EndedOn)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &d.Kind)
			delete(rawMsg, key)
		case "migrationFailureError":
			err = unpopulate(val, &d.MigrationFailureError)
			delete(rawMsg, key)
		case "migrationOperationId":
			err = unpopulate(val, &d.MigrationOperationID)
			delete(rawMsg, key)
		case "migrationService":
			err = unpopulate(val, &d.MigrationService)
			delete(rawMsg, key)
		case "migrationStatus":
			err = unpopulate(val, &d.MigrationStatus)
			delete(rawMsg, key)
		case "migrationStatusDetails":
			err = unpopulate(val, &d.MigrationStatusDetails)
			delete(rawMsg, key)
		case "offlineConfiguration":
			err = unpopulate(val, &d.OfflineConfiguration)
			delete(rawMsg, key)
		case "provisioningError":
			err = unpopulate(val, &d.ProvisioningError)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &d.ProvisioningState)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &d.Scope)
			delete(rawMsg, key)
		case "sourceDatabaseName":
			err = unpopulate(val, &d.SourceDatabaseName)
			delete(rawMsg, key)
		case "sourceSqlConnection":
			err = unpopulate(val, &d.SourceSQLConnection)
			delete(rawMsg, key)
		case "sourceServerName":
			err = unpopulate(val, &d.SourceServerName)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &d.StartedOn)
			delete(rawMsg, key)
		case "targetDatabaseCollation":
			err = unpopulate(val, &d.TargetDatabaseCollation)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatabaseMigrationPropertiesSQLVM - Database Migration Resource properties for SQL Virtual Machine.
type DatabaseMigrationPropertiesSQLVM struct {
	// REQUIRED
	Kind *ResourceType `json:"kind,omitempty"`

	// Backup configuration info.
	BackupConfiguration *BackupConfiguration `json:"backupConfiguration,omitempty"`

	// ID tracking current migration operation.
	MigrationOperationID *string `json:"migrationOperationId,omitempty"`

	// Resource Id of the Migration Service.
	MigrationService *string `json:"migrationService,omitempty"`

	// Offline configuration.
	OfflineConfiguration *OfflineConfiguration `json:"offlineConfiguration,omitempty"`

	// Error message for migration provisioning failure, if any.
	ProvisioningError *string `json:"provisioningError,omitempty"`

	// Resource Id of the target resource (SQL VM or SQL Managed Instance).
	Scope *string `json:"scope,omitempty"`

	// Name of the source database.
	SourceDatabaseName *string `json:"sourceDatabaseName,omitempty"`

	// Source SQL Server connection details.
	SourceSQLConnection *SQLConnectionInformation `json:"sourceSqlConnection,omitempty"`

	// Database collation to be used for the target database.
	TargetDatabaseCollation *string `json:"targetDatabaseCollation,omitempty"`

	// READ-ONLY; Database migration end time.
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Error details in case of migration failure.
	MigrationFailureError *ErrorInfo `json:"migrationFailureError,omitempty" azure:"ro"`

	// READ-ONLY; Migration status.
	MigrationStatus *string `json:"migrationStatus,omitempty" azure:"ro"`

	// READ-ONLY; Detailed migration status. Not included by default.
	MigrationStatusDetails *MigrationStatusDetails `json:"migrationStatusDetails,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning State of migration. ProvisioningState as Succeeded implies that validations have been performed
	// and migration has started.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Name of the source sql server.
	SourceServerName *string `json:"sourceServerName,omitempty" azure:"ro"`

	// READ-ONLY; Database migration start time.
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`
}

// GetDatabaseMigrationProperties implements the DatabaseMigrationPropertiesClassification interface for type DatabaseMigrationPropertiesSQLVM.
func (d *DatabaseMigrationPropertiesSQLVM) GetDatabaseMigrationProperties() *DatabaseMigrationProperties {
	return &DatabaseMigrationProperties{
		Kind:                    d.Kind,
		Scope:                   d.Scope,
		ProvisioningState:       d.ProvisioningState,
		MigrationStatus:         d.MigrationStatus,
		StartedOn:               d.StartedOn,
		EndedOn:                 d.EndedOn,
		SourceSQLConnection:     d.SourceSQLConnection,
		SourceDatabaseName:      d.SourceDatabaseName,
		SourceServerName:        d.SourceServerName,
		MigrationService:        d.MigrationService,
		MigrationOperationID:    d.MigrationOperationID,
		MigrationFailureError:   d.MigrationFailureError,
		TargetDatabaseCollation: d.TargetDatabaseCollation,
		ProvisioningError:       d.ProvisioningError,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseMigrationPropertiesSQLVM.
func (d DatabaseMigrationPropertiesSQLVM) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupConfiguration", d.BackupConfiguration)
	populateTimeRFC3339(objectMap, "endedOn", d.EndedOn)
	objectMap["kind"] = ResourceTypeSQLVM
	populate(objectMap, "migrationFailureError", d.MigrationFailureError)
	populate(objectMap, "migrationOperationId", d.MigrationOperationID)
	populate(objectMap, "migrationService", d.MigrationService)
	populate(objectMap, "migrationStatus", d.MigrationStatus)
	populate(objectMap, "migrationStatusDetails", d.MigrationStatusDetails)
	populate(objectMap, "offlineConfiguration", d.OfflineConfiguration)
	populate(objectMap, "provisioningError", d.ProvisioningError)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "scope", d.Scope)
	populate(objectMap, "sourceDatabaseName", d.SourceDatabaseName)
	populate(objectMap, "sourceSqlConnection", d.SourceSQLConnection)
	populate(objectMap, "sourceServerName", d.SourceServerName)
	populateTimeRFC3339(objectMap, "startedOn", d.StartedOn)
	populate(objectMap, "targetDatabaseCollation", d.TargetDatabaseCollation)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseMigrationPropertiesSQLVM.
func (d *DatabaseMigrationPropertiesSQLVM) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupConfiguration":
			err = unpopulate(val, &d.BackupConfiguration)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &d.EndedOn)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &d.Kind)
			delete(rawMsg, key)
		case "migrationFailureError":
			err = unpopulate(val, &d.MigrationFailureError)
			delete(rawMsg, key)
		case "migrationOperationId":
			err = unpopulate(val, &d.MigrationOperationID)
			delete(rawMsg, key)
		case "migrationService":
			err = unpopulate(val, &d.MigrationService)
			delete(rawMsg, key)
		case "migrationStatus":
			err = unpopulate(val, &d.MigrationStatus)
			delete(rawMsg, key)
		case "migrationStatusDetails":
			err = unpopulate(val, &d.MigrationStatusDetails)
			delete(rawMsg, key)
		case "offlineConfiguration":
			err = unpopulate(val, &d.OfflineConfiguration)
			delete(rawMsg, key)
		case "provisioningError":
			err = unpopulate(val, &d.ProvisioningError)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &d.ProvisioningState)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &d.Scope)
			delete(rawMsg, key)
		case "sourceDatabaseName":
			err = unpopulate(val, &d.SourceDatabaseName)
			delete(rawMsg, key)
		case "sourceSqlConnection":
			err = unpopulate(val, &d.SourceSQLConnection)
			delete(rawMsg, key)
		case "sourceServerName":
			err = unpopulate(val, &d.SourceServerName)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &d.StartedOn)
			delete(rawMsg, key)
		case "targetDatabaseCollation":
			err = unpopulate(val, &d.TargetDatabaseCollation)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatabaseMigrationSQLDb - Database Migration Resource for SQL Database.
type DatabaseMigrationSQLDb struct {
	// Database Migration Resource properties for SQL database.
	Properties *DatabaseMigrationPropertiesSQLDb `json:"properties,omitempty"`

	// READ-ONLY
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY
	Type *string `json:"type,omitempty" azure:"ro"`
}

// DatabaseMigrationSQLMi - Database Migration Resource for SQL Managed Instance.
type DatabaseMigrationSQLMi struct {
	// Database Migration Resource properties for SQL Managed Instance.
	Properties *DatabaseMigrationPropertiesSQLMi `json:"properties,omitempty"`

	// READ-ONLY
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY
	Type *string `json:"type,omitempty" azure:"ro"`
}

// DatabaseMigrationSQLVM - Database Migration Resource for SQL Virtual Machine.
type DatabaseMigrationSQLVM struct {
	// Database Migration Resource properties for SQL Virtual Machine.
	Properties *DatabaseMigrationPropertiesSQLVM `json:"properties,omitempty"`

	// READ-ONLY
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY
	Type *string `json:"type,omitempty" azure:"ro"`
}

// DatabaseMigrationsSQLDbClientBeginCancelOptions contains the optional parameters for the DatabaseMigrationsSQLDbClient.BeginCancel
// method.
type DatabaseMigrationsSQLDbClientBeginCancelOptions struct {
	// placeholder for future optional parameters
}

// DatabaseMigrationsSQLDbClientBeginCreateOrUpdateOptions contains the optional parameters for the DatabaseMigrationsSQLDbClient.BeginCreateOrUpdate
// method.
type DatabaseMigrationsSQLDbClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DatabaseMigrationsSQLDbClientBeginDeleteOptions contains the optional parameters for the DatabaseMigrationsSQLDbClient.BeginDelete
// method.
type DatabaseMigrationsSQLDbClientBeginDeleteOptions struct {
	// Optional force delete boolean. If this is provided as true, migration will be deleted even if active.
	Force *bool
}

// DatabaseMigrationsSQLDbClientGetOptions contains the optional parameters for the DatabaseMigrationsSQLDbClient.Get method.
type DatabaseMigrationsSQLDbClientGetOptions struct {
	// Complete migration details be included in the response.
	Expand *string
	// Optional migration operation ID. If this is provided, then details of migration operation for that ID are retrieved. If
	// not provided (default), then details related to most recent or current operation
	// are retrieved.
	MigrationOperationID *string
}

// DatabaseMigrationsSQLMiClientBeginCancelOptions contains the optional parameters for the DatabaseMigrationsSQLMiClient.BeginCancel
// method.
type DatabaseMigrationsSQLMiClientBeginCancelOptions struct {
	// placeholder for future optional parameters
}

// DatabaseMigrationsSQLMiClientBeginCreateOrUpdateOptions contains the optional parameters for the DatabaseMigrationsSQLMiClient.BeginCreateOrUpdate
// method.
type DatabaseMigrationsSQLMiClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DatabaseMigrationsSQLMiClientBeginCutoverOptions contains the optional parameters for the DatabaseMigrationsSQLMiClient.BeginCutover
// method.
type DatabaseMigrationsSQLMiClientBeginCutoverOptions struct {
	// placeholder for future optional parameters
}

// DatabaseMigrationsSQLMiClientGetOptions contains the optional parameters for the DatabaseMigrationsSQLMiClient.Get method.
type DatabaseMigrationsSQLMiClientGetOptions struct {
	// Complete migration details be included in the response.
	Expand *string
	// Optional migration operation ID. If this is provided, then details of migration operation for that ID are retrieved. If
	// not provided (default), then details related to most recent or current operation
	// are retrieved.
	MigrationOperationID *string
}

// DatabaseMigrationsSQLVMClientBeginCancelOptions contains the optional parameters for the DatabaseMigrationsSQLVMClient.BeginCancel
// method.
type DatabaseMigrationsSQLVMClientBeginCancelOptions struct {
	// placeholder for future optional parameters
}

// DatabaseMigrationsSQLVMClientBeginCreateOrUpdateOptions contains the optional parameters for the DatabaseMigrationsSQLVMClient.BeginCreateOrUpdate
// method.
type DatabaseMigrationsSQLVMClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DatabaseMigrationsSQLVMClientBeginCutoverOptions contains the optional parameters for the DatabaseMigrationsSQLVMClient.BeginCutover
// method.
type DatabaseMigrationsSQLVMClientBeginCutoverOptions struct {
	// placeholder for future optional parameters
}

// DatabaseMigrationsSQLVMClientGetOptions contains the optional parameters for the DatabaseMigrationsSQLVMClient.Get method.
type DatabaseMigrationsSQLVMClientGetOptions struct {
	// Complete migration details be included in the response.
	Expand *string
	// Optional migration operation ID. If this is provided, then details of migration operation for that ID are retrieved. If
	// not provided (default), then details related to most recent or current operation
	// are retrieved.
	MigrationOperationID *string
}

// DatabaseObjectName - A representation of the name of an object in a database
type DatabaseObjectName struct {
	// Type of the object in the database
	ObjectType *ObjectType `json:"objectType,omitempty"`

	// READ-ONLY; The unescaped name of the database containing the object
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; The unescaped name of the object
	ObjectName *string `json:"objectName,omitempty" azure:"ro"`

	// READ-ONLY; The unescaped name of the schema containing the object
	SchemaName *string `json:"schemaName,omitempty" azure:"ro"`
}

// DatabaseSummaryResult - Summary of database results in the migration
type DatabaseSummaryResult struct {
	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all errors of the item
	ErrorPrefix *string `json:"errorPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Number of successfully completed items
	ItemsCompletedCount *int64 `json:"itemsCompletedCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of items
	ItemsCount *int64 `json:"itemsCount,omitempty" azure:"ro"`

	// READ-ONLY; Name of the item
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all sub-tem results of the item
	ResultPrefix *string `json:"resultPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Size of the database in megabytes
	SizeMB *float64 `json:"sizeMB,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Status message
	StatusMessage *string `json:"statusMessage,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseSummaryResult.
func (d DatabaseSummaryResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endedOn", d.EndedOn)
	populate(objectMap, "errorPrefix", d.ErrorPrefix)
	populate(objectMap, "itemsCompletedCount", d.ItemsCompletedCount)
	populate(objectMap, "itemsCount", d.ItemsCount)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "resultPrefix", d.ResultPrefix)
	populate(objectMap, "sizeMB", d.SizeMB)
	populateTimeRFC3339(objectMap, "startedOn", d.StartedOn)
	populate(objectMap, "state", d.State)
	populate(objectMap, "statusMessage", d.StatusMessage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseSummaryResult.
func (d *DatabaseSummaryResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &d.EndedOn)
			delete(rawMsg, key)
		case "errorPrefix":
			err = unpopulate(val, &d.ErrorPrefix)
			delete(rawMsg, key)
		case "itemsCompletedCount":
			err = unpopulate(val, &d.ItemsCompletedCount)
			delete(rawMsg, key)
		case "itemsCount":
			err = unpopulate(val, &d.ItemsCount)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "resultPrefix":
			err = unpopulate(val, &d.ResultPrefix)
			delete(rawMsg, key)
		case "sizeMB":
			err = unpopulate(val, &d.SizeMB)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &d.StartedOn)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &d.State)
			delete(rawMsg, key)
		case "statusMessage":
			err = unpopulate(val, &d.StatusMessage)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatabaseTable - Table properties
type DatabaseTable struct {
	// READ-ONLY; Indicates whether table is empty or not
	HasRows *bool `json:"hasRows,omitempty" azure:"ro"`

	// READ-ONLY; Schema-qualified name of the table
	Name *string `json:"name,omitempty" azure:"ro"`
}

// DeleteNode - Details of node to be deleted.
type DeleteNode struct {
	// The name of integration runtime.
	IntegrationRuntimeName *string `json:"integrationRuntimeName,omitempty"`

	// The name of node to delete.
	NodeName *string `json:"nodeName,omitempty"`
}

// Error - Migration Task errors
type Error struct {
	// Error type
	Type *ErrorType `json:"type,omitempty"`

	// READ-ONLY; Error description
	Message *string `json:"message,omitempty" azure:"ro"`
}

// ErrorInfo - Error details
type ErrorInfo struct {
	// READ-ONLY; Error code.
	Code *string `json:"code,omitempty" azure:"ro"`

	// READ-ONLY; Error message.
	Message *string `json:"message,omitempty" azure:"ro"`
}

// ExecutionStatistics - Description about the errors happen while performing migration validation
type ExecutionStatistics struct {
	// CPU Time in millisecond(s) for the query execution
	CPUTimeMs *float32 `json:"cpuTimeMs,omitempty"`

	// Time taken in millisecond(s) for executing the query
	ElapsedTimeMs *float32 `json:"elapsedTimeMs,omitempty"`

	// No. of query executions
	ExecutionCount *int64 `json:"executionCount,omitempty"`

	// Indicates whether the query resulted in an error
	HasErrors *bool `json:"hasErrors,omitempty"`

	// List of sql Errors
	SQLErrors []*string `json:"sqlErrors,omitempty"`

	// Dictionary of sql query execution wait types and the respective statistics
	WaitStats map[string]*WaitStatistics `json:"waitStats,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExecutionStatistics.
func (e ExecutionStatistics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cpuTimeMs", e.CPUTimeMs)
	populate(objectMap, "elapsedTimeMs", e.ElapsedTimeMs)
	populate(objectMap, "executionCount", e.ExecutionCount)
	populate(objectMap, "hasErrors", e.HasErrors)
	populate(objectMap, "sqlErrors", e.SQLErrors)
	populate(objectMap, "waitStats", e.WaitStats)
	return json.Marshal(objectMap)
}

// FileList - OData page of files
type FileList struct {
	// URL to load the next page of files
	NextLink *string `json:"nextLink,omitempty"`

	// List of files
	Value []*ProjectFile `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FileList.
func (f FileList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// FileShare - File share information with Path, Username, and Password.
type FileShare struct {
	// REQUIRED; The folder path for this share.
	Path *string `json:"path,omitempty"`

	// Password credential used to connect to the share location.
	Password *string `json:"password,omitempty"`

	// User name credential to connect to the share location
	UserName *string `json:"userName,omitempty"`
}

// FileStorageInfo - File storage information.
type FileStorageInfo struct {
	// Dictionary of
	Headers map[string]*string `json:"headers,omitempty"`

	// A URI that can be used to access the file content.
	URI *string `json:"uri,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FileStorageInfo.
func (f FileStorageInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "headers", f.Headers)
	populate(objectMap, "uri", f.URI)
	return json.Marshal(objectMap)
}

// FilesClientCreateOrUpdateOptions contains the optional parameters for the FilesClient.CreateOrUpdate method.
type FilesClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// FilesClientDeleteOptions contains the optional parameters for the FilesClient.Delete method.
type FilesClientDeleteOptions struct {
	// placeholder for future optional parameters
}

// FilesClientGetOptions contains the optional parameters for the FilesClient.Get method.
type FilesClientGetOptions struct {
	// placeholder for future optional parameters
}

// FilesClientListOptions contains the optional parameters for the FilesClient.List method.
type FilesClientListOptions struct {
	// placeholder for future optional parameters
}

// FilesClientReadOptions contains the optional parameters for the FilesClient.Read method.
type FilesClientReadOptions struct {
	// placeholder for future optional parameters
}

// FilesClientReadWriteOptions contains the optional parameters for the FilesClient.ReadWrite method.
type FilesClientReadWriteOptions struct {
	// placeholder for future optional parameters
}

// FilesClientUpdateOptions contains the optional parameters for the FilesClient.Update method.
type FilesClientUpdateOptions struct {
	// placeholder for future optional parameters
}

// GetProjectDetailsNonSQLTaskInput - Input for the task that reads configuration from project artifacts
type GetProjectDetailsNonSQLTaskInput struct {
	// REQUIRED; A URL that points to the location to access project artifacts
	ProjectLocation *string `json:"projectLocation,omitempty"`

	// REQUIRED; Name of the migration project
	ProjectName *string `json:"projectName,omitempty"`
}

// GetTdeCertificatesSQLTaskInput - Input for the task that gets TDE certificates in Base64 encoded format.
type GetTdeCertificatesSQLTaskInput struct {
	// REQUIRED; Backup file share information for file share to be used for temporarily storing files.
	BackupFileShare *FileShare `json:"backupFileShare,omitempty"`

	// REQUIRED; Connection information for SQL Server
	ConnectionInfo *SQLConnectionInfo `json:"connectionInfo,omitempty"`

	// REQUIRED; List containing certificate names and corresponding password to use for encrypting the exported certificate.
	SelectedCertificates []*SelectedCertificateInput `json:"selectedCertificates,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GetTdeCertificatesSQLTaskInput.
func (g GetTdeCertificatesSQLTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupFileShare", g.BackupFileShare)
	populate(objectMap, "connectionInfo", g.ConnectionInfo)
	populate(objectMap, "selectedCertificates", g.SelectedCertificates)
	return json.Marshal(objectMap)
}

// GetTdeCertificatesSQLTaskOutput - Output of the task that gets TDE certificates in Base64 encoded format.
type GetTdeCertificatesSQLTaskOutput struct {
	// READ-ONLY; Mapping from certificate name to base 64 encoded format.
	Base64EncodedCertificates *string `json:"base64EncodedCertificates,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetTdeCertificatesSQLTaskOutput.
func (g GetTdeCertificatesSQLTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "base64EncodedCertificates", g.Base64EncodedCertificates)
	populate(objectMap, "validationErrors", g.ValidationErrors)
	return json.Marshal(objectMap)
}

// GetTdeCertificatesSQLTaskProperties - Properties for the task that gets TDE certificates in Base64 encoded format.
type GetTdeCertificatesSQLTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *GetTdeCertificatesSQLTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*GetTdeCertificatesSQLTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type GetTdeCertificatesSQLTaskProperties.
func (g *GetTdeCertificatesSQLTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   g.TaskType,
		Errors:     g.Errors,
		State:      g.State,
		Commands:   g.Commands,
		ClientData: g.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GetTdeCertificatesSQLTaskProperties.
func (g GetTdeCertificatesSQLTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", g.ClientData)
	populate(objectMap, "commands", g.Commands)
	populate(objectMap, "errors", g.Errors)
	populate(objectMap, "input", g.Input)
	populate(objectMap, "output", g.Output)
	populate(objectMap, "state", g.State)
	objectMap["taskType"] = TaskTypeGetTDECertificatesSQL
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetTdeCertificatesSQLTaskProperties.
func (g *GetTdeCertificatesSQLTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &g.ClientData)
			delete(rawMsg, key)
		case "commands":
			g.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &g.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &g.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &g.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &g.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &g.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetUserTablesMySQLTaskInput - Input for the task that collects user tables for the given list of databases
type GetUserTablesMySQLTaskInput struct {
	// REQUIRED; Connection information for SQL Server
	ConnectionInfo *MySQLConnectionInfo `json:"connectionInfo,omitempty"`

	// REQUIRED; List of database names to collect tables for
	SelectedDatabases []*string `json:"selectedDatabases,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesMySQLTaskInput.
func (g GetUserTablesMySQLTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "connectionInfo", g.ConnectionInfo)
	populate(objectMap, "selectedDatabases", g.SelectedDatabases)
	return json.Marshal(objectMap)
}

// GetUserTablesMySQLTaskOutput - Output of the task that collects user tables for the given list of databases
type GetUserTablesMySQLTaskOutput struct {
	// READ-ONLY; Mapping from database name to list of tables
	DatabasesToTables *string `json:"databasesToTables,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesMySQLTaskOutput.
func (g GetUserTablesMySQLTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databasesToTables", g.DatabasesToTables)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "validationErrors", g.ValidationErrors)
	return json.Marshal(objectMap)
}

// GetUserTablesMySQLTaskProperties - Properties for the task that collects user tables for the given list of databases
type GetUserTablesMySQLTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *GetUserTablesMySQLTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*GetUserTablesMySQLTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type GetUserTablesMySQLTaskProperties.
func (g *GetUserTablesMySQLTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   g.TaskType,
		Errors:     g.Errors,
		State:      g.State,
		Commands:   g.Commands,
		ClientData: g.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesMySQLTaskProperties.
func (g GetUserTablesMySQLTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", g.ClientData)
	populate(objectMap, "commands", g.Commands)
	populate(objectMap, "errors", g.Errors)
	populate(objectMap, "input", g.Input)
	populate(objectMap, "output", g.Output)
	populate(objectMap, "state", g.State)
	objectMap["taskType"] = TaskTypeGetUserTablesMySQL
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetUserTablesMySQLTaskProperties.
func (g *GetUserTablesMySQLTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &g.ClientData)
			delete(rawMsg, key)
		case "commands":
			g.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &g.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &g.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &g.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &g.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &g.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetUserTablesOracleTaskInput - Input for the task that gets the list of tables contained within a provided list of Oracle
// schemas.
type GetUserTablesOracleTaskInput struct {
	// REQUIRED; Information for connecting to Oracle source
	ConnectionInfo *OracleConnectionInfo `json:"connectionInfo,omitempty"`

	// REQUIRED; List of Oracle schemas for which to collect tables
	SelectedSchemas []*string `json:"selectedSchemas,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesOracleTaskInput.
func (g GetUserTablesOracleTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "connectionInfo", g.ConnectionInfo)
	populate(objectMap, "selectedSchemas", g.SelectedSchemas)
	return json.Marshal(objectMap)
}

// GetUserTablesOracleTaskOutput - Output for the task that gets the list of tables contained within a provided list of Oracle
// schemas.
type GetUserTablesOracleTaskOutput struct {
	// READ-ONLY; The schema this result is for
	SchemaName *string `json:"schemaName,omitempty" azure:"ro"`

	// READ-ONLY; List of valid tables found for this schema
	Tables []*DatabaseTable `json:"tables,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors associated with the task
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesOracleTaskOutput.
func (g GetUserTablesOracleTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "schemaName", g.SchemaName)
	populate(objectMap, "tables", g.Tables)
	populate(objectMap, "validationErrors", g.ValidationErrors)
	return json.Marshal(objectMap)
}

// GetUserTablesOracleTaskProperties - Properties for the task that collects user tables for the given list of Oracle schemas
type GetUserTablesOracleTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *GetUserTablesOracleTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*GetUserTablesOracleTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type GetUserTablesOracleTaskProperties.
func (g *GetUserTablesOracleTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   g.TaskType,
		Errors:     g.Errors,
		State:      g.State,
		Commands:   g.Commands,
		ClientData: g.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesOracleTaskProperties.
func (g GetUserTablesOracleTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", g.ClientData)
	populate(objectMap, "commands", g.Commands)
	populate(objectMap, "errors", g.Errors)
	populate(objectMap, "input", g.Input)
	populate(objectMap, "output", g.Output)
	populate(objectMap, "state", g.State)
	objectMap["taskType"] = TaskTypeGetUserTablesOracle
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetUserTablesOracleTaskProperties.
func (g *GetUserTablesOracleTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &g.ClientData)
			delete(rawMsg, key)
		case "commands":
			g.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &g.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &g.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &g.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &g.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &g.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetUserTablesPostgreSQLTaskInput - Input for the task that gets the list of tables for a provided list of PostgreSQL databases.
type GetUserTablesPostgreSQLTaskInput struct {
	// REQUIRED; Information for connecting to PostgreSQL source
	ConnectionInfo *PostgreSQLConnectionInfo `json:"connectionInfo,omitempty"`

	// REQUIRED; List of PostgreSQL databases for which to collect tables
	SelectedDatabases []*string `json:"selectedDatabases,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesPostgreSQLTaskInput.
func (g GetUserTablesPostgreSQLTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "connectionInfo", g.ConnectionInfo)
	populate(objectMap, "selectedDatabases", g.SelectedDatabases)
	return json.Marshal(objectMap)
}

// GetUserTablesPostgreSQLTaskOutput - Output for the task that gets the list of tables for a provided list of PostgreSQL
// databases.
type GetUserTablesPostgreSQLTaskOutput struct {
	// READ-ONLY; The database this result is for
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; List of valid tables found for this database
	Tables []*DatabaseTable `json:"tables,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors associated with the task
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesPostgreSQLTaskOutput.
func (g GetUserTablesPostgreSQLTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databaseName", g.DatabaseName)
	populate(objectMap, "tables", g.Tables)
	populate(objectMap, "validationErrors", g.ValidationErrors)
	return json.Marshal(objectMap)
}

// GetUserTablesPostgreSQLTaskProperties - Properties for the task that collects user tables for the given list of databases
type GetUserTablesPostgreSQLTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *GetUserTablesPostgreSQLTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*GetUserTablesPostgreSQLTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type GetUserTablesPostgreSQLTaskProperties.
func (g *GetUserTablesPostgreSQLTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   g.TaskType,
		Errors:     g.Errors,
		State:      g.State,
		Commands:   g.Commands,
		ClientData: g.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesPostgreSQLTaskProperties.
func (g GetUserTablesPostgreSQLTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", g.ClientData)
	populate(objectMap, "commands", g.Commands)
	populate(objectMap, "errors", g.Errors)
	populate(objectMap, "input", g.Input)
	populate(objectMap, "output", g.Output)
	populate(objectMap, "state", g.State)
	objectMap["taskType"] = TaskTypeGetUserTablesPostgreSQL
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetUserTablesPostgreSQLTaskProperties.
func (g *GetUserTablesPostgreSQLTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &g.ClientData)
			delete(rawMsg, key)
		case "commands":
			g.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &g.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &g.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &g.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &g.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &g.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetUserTablesSQLSyncTaskInput - Input for the task that collects user tables for the given list of databases
type GetUserTablesSQLSyncTaskInput struct {
	// REQUIRED; List of source database names to collect tables for
	SelectedSourceDatabases []*string `json:"selectedSourceDatabases,omitempty"`

	// REQUIRED; List of target database names to collect tables for
	SelectedTargetDatabases []*string `json:"selectedTargetDatabases,omitempty"`

	// REQUIRED; Connection information for SQL Server
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Connection information for SQL DB
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesSQLSyncTaskInput.
func (g GetUserTablesSQLSyncTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "selectedSourceDatabases", g.SelectedSourceDatabases)
	populate(objectMap, "selectedTargetDatabases", g.SelectedTargetDatabases)
	populate(objectMap, "sourceConnectionInfo", g.SourceConnectionInfo)
	populate(objectMap, "targetConnectionInfo", g.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// GetUserTablesSQLSyncTaskOutput - Output of the task that collects user tables for the given list of databases
type GetUserTablesSQLSyncTaskOutput struct {
	// READ-ONLY; Mapping from database name to list of source tables
	DatabasesToSourceTables *string `json:"databasesToSourceTables,omitempty" azure:"ro"`

	// READ-ONLY; Mapping from database name to list of target tables
	DatabasesToTargetTables *string `json:"databasesToTargetTables,omitempty" azure:"ro"`

	// READ-ONLY; Mapping from database name to list of validation errors
	TableValidationErrors *string `json:"tableValidationErrors,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesSQLSyncTaskOutput.
func (g GetUserTablesSQLSyncTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databasesToSourceTables", g.DatabasesToSourceTables)
	populate(objectMap, "databasesToTargetTables", g.DatabasesToTargetTables)
	populate(objectMap, "tableValidationErrors", g.TableValidationErrors)
	populate(objectMap, "validationErrors", g.ValidationErrors)
	return json.Marshal(objectMap)
}

// GetUserTablesSQLSyncTaskProperties - Properties for the task that collects user tables for the given list of databases
type GetUserTablesSQLSyncTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *GetUserTablesSQLSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*GetUserTablesSQLSyncTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type GetUserTablesSQLSyncTaskProperties.
func (g *GetUserTablesSQLSyncTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   g.TaskType,
		Errors:     g.Errors,
		State:      g.State,
		Commands:   g.Commands,
		ClientData: g.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesSQLSyncTaskProperties.
func (g GetUserTablesSQLSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", g.ClientData)
	populate(objectMap, "commands", g.Commands)
	populate(objectMap, "errors", g.Errors)
	populate(objectMap, "input", g.Input)
	populate(objectMap, "output", g.Output)
	populate(objectMap, "state", g.State)
	objectMap["taskType"] = TaskTypeGetUserTablesAzureSQLDbSync
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetUserTablesSQLSyncTaskProperties.
func (g *GetUserTablesSQLSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &g.ClientData)
			delete(rawMsg, key)
		case "commands":
			g.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &g.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &g.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &g.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &g.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &g.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetUserTablesSQLTaskInput - Input for the task that collects user tables for the given list of databases
type GetUserTablesSQLTaskInput struct {
	// REQUIRED; Connection information for SQL Server
	ConnectionInfo *SQLConnectionInfo `json:"connectionInfo,omitempty"`

	// REQUIRED; List of database names to collect tables for
	SelectedDatabases []*string `json:"selectedDatabases,omitempty"`

	// encrypted key for secure fields
	EncryptedKeyForSecureFields *string `json:"encryptedKeyForSecureFields,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesSQLTaskInput.
func (g GetUserTablesSQLTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "connectionInfo", g.ConnectionInfo)
	populate(objectMap, "encryptedKeyForSecureFields", g.EncryptedKeyForSecureFields)
	populate(objectMap, "selectedDatabases", g.SelectedDatabases)
	return json.Marshal(objectMap)
}

// GetUserTablesSQLTaskOutput - Output of the task that collects user tables for the given list of databases
type GetUserTablesSQLTaskOutput struct {
	// READ-ONLY; Mapping from database name to list of tables
	DatabasesToTables *string `json:"databasesToTables,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesSQLTaskOutput.
func (g GetUserTablesSQLTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databasesToTables", g.DatabasesToTables)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "validationErrors", g.ValidationErrors)
	return json.Marshal(objectMap)
}

// GetUserTablesSQLTaskProperties - Properties for the task that collects user tables for the given list of databases
type GetUserTablesSQLTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *GetUserTablesSQLTaskInput `json:"input,omitempty"`

	// Task id
	TaskID *string `json:"taskId,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*GetUserTablesSQLTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type GetUserTablesSQLTaskProperties.
func (g *GetUserTablesSQLTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   g.TaskType,
		Errors:     g.Errors,
		State:      g.State,
		Commands:   g.Commands,
		ClientData: g.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesSQLTaskProperties.
func (g GetUserTablesSQLTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", g.ClientData)
	populate(objectMap, "commands", g.Commands)
	populate(objectMap, "errors", g.Errors)
	populate(objectMap, "input", g.Input)
	populate(objectMap, "output", g.Output)
	populate(objectMap, "state", g.State)
	populate(objectMap, "taskId", g.TaskID)
	objectMap["taskType"] = TaskTypeGetUserTablesSQL
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetUserTablesSQLTaskProperties.
func (g *GetUserTablesSQLTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &g.ClientData)
			delete(rawMsg, key)
		case "commands":
			g.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &g.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &g.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &g.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &g.State)
			delete(rawMsg, key)
		case "taskId":
			err = unpopulate(val, &g.TaskID)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &g.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// InstallOCIDriverTaskInput - Input for the service task to install an OCI driver.
type InstallOCIDriverTaskInput struct {
	// Name of the uploaded driver package to install.
	DriverPackageName *string `json:"driverPackageName,omitempty"`
}

// InstallOCIDriverTaskOutput - Output for the service task to install an OCI driver.
type InstallOCIDriverTaskOutput struct {
	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type InstallOCIDriverTaskOutput.
func (i InstallOCIDriverTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "validationErrors", i.ValidationErrors)
	return json.Marshal(objectMap)
}

// InstallOCIDriverTaskProperties - Properties for the task that installs an OCI driver.
type InstallOCIDriverTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Input for the service task to install an OCI driver.
	Input *InstallOCIDriverTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*InstallOCIDriverTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type InstallOCIDriverTaskProperties.
func (i *InstallOCIDriverTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   i.TaskType,
		Errors:     i.Errors,
		State:      i.State,
		Commands:   i.Commands,
		ClientData: i.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type InstallOCIDriverTaskProperties.
func (i InstallOCIDriverTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", i.ClientData)
	populate(objectMap, "commands", i.Commands)
	populate(objectMap, "errors", i.Errors)
	populate(objectMap, "input", i.Input)
	populate(objectMap, "output", i.Output)
	populate(objectMap, "state", i.State)
	objectMap["taskType"] = TaskTypeServiceInstallOCI
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InstallOCIDriverTaskProperties.
func (i *InstallOCIDriverTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &i.ClientData)
			delete(rawMsg, key)
		case "commands":
			i.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &i.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &i.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &i.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &i.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &i.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IntegrationRuntimeMonitoringData - Integration Runtime Monitoring Data.
type IntegrationRuntimeMonitoringData struct {
	// READ-ONLY; The name of Integration Runtime.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Integration Runtime node monitoring data.
	Nodes []*NodeMonitoringData `json:"nodes,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type IntegrationRuntimeMonitoringData.
func (i IntegrationRuntimeMonitoringData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", i.Name)
	populate(objectMap, "nodes", i.Nodes)
	return json.Marshal(objectMap)
}

// MiSQLConnectionInfo - Properties required to create a connection to Azure SQL database Managed instance
type MiSQLConnectionInfo struct {
	// REQUIRED; Resource id for Azure SQL database Managed instance
	ManagedInstanceResourceID *string `json:"managedInstanceResourceId,omitempty"`

	// REQUIRED; Type of connection info
	Type *string `json:"type,omitempty"`

	// Password credential.
	Password *string `json:"password,omitempty"`

	// User name
	UserName *string `json:"userName,omitempty"`
}

// GetConnectionInfo implements the ConnectionInfoClassification interface for type MiSQLConnectionInfo.
func (m *MiSQLConnectionInfo) GetConnectionInfo() *ConnectionInfo {
	return &ConnectionInfo{
		Type:     m.Type,
		UserName: m.UserName,
		Password: m.Password,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MiSQLConnectionInfo.
func (m MiSQLConnectionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "managedInstanceResourceId", m.ManagedInstanceResourceID)
	populate(objectMap, "password", m.Password)
	objectMap["type"] = "MiSqlConnectionInfo"
	populate(objectMap, "userName", m.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MiSQLConnectionInfo.
func (m *MiSQLConnectionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "managedInstanceResourceId":
			err = unpopulate(val, &m.ManagedInstanceResourceID)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, &m.Password)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &m.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateMISyncCompleteCommandInput - Input for command that completes online migration for an Azure SQL Database Managed
// Instance.
type MigrateMISyncCompleteCommandInput struct {
	// REQUIRED; Name of managed instance database
	SourceDatabaseName *string `json:"sourceDatabaseName,omitempty"`
}

// MigrateMISyncCompleteCommandOutput - Output for command that completes online migration for an Azure SQL Database Managed
// Instance.
type MigrateMISyncCompleteCommandOutput struct {
	// List of errors that happened during the command execution
	Errors []*ReportableException `json:"errors,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMISyncCompleteCommandOutput.
func (m MigrateMISyncCompleteCommandOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errors", m.Errors)
	return json.Marshal(objectMap)
}

// MigrateMISyncCompleteCommandProperties - Properties for the command that completes online migration for an Azure SQL Database
// Managed Instance.
type MigrateMISyncCompleteCommandProperties struct {
	// REQUIRED; Command type.
	CommandType *CommandType `json:"commandType,omitempty"`

	// Command input
	Input *MigrateMISyncCompleteCommandInput `json:"input,omitempty"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Command output. This is ignored if submitted.
	Output *MigrateMISyncCompleteCommandOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the command. This is ignored if submitted.
	State *CommandState `json:"state,omitempty" azure:"ro"`
}

// GetCommandProperties implements the CommandPropertiesClassification interface for type MigrateMISyncCompleteCommandProperties.
func (m *MigrateMISyncCompleteCommandProperties) GetCommandProperties() *CommandProperties {
	return &CommandProperties{
		CommandType: m.CommandType,
		Errors:      m.Errors,
		State:       m.State,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMISyncCompleteCommandProperties.
func (m MigrateMISyncCompleteCommandProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["commandType"] = CommandTypeMigrateSQLServerAzureDbSQLMiComplete
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	populate(objectMap, "state", m.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMISyncCompleteCommandProperties.
func (m *MigrateMISyncCompleteCommandProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commandType":
			err = unpopulate(val, &m.CommandType)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &m.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateMongoDbTaskProperties - Properties for the task that migrates data between MongoDB data sources
type MigrateMongoDbTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Describes how a MongoDB data migration should be performed
	Input *MongoDbMigrationSettings `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY
	Output []MongoDbProgressClassification `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type MigrateMongoDbTaskProperties.
func (m *MigrateMongoDbTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   m.TaskType,
		Errors:     m.Errors,
		State:      m.State,
		Commands:   m.Commands,
		ClientData: m.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMongoDbTaskProperties.
func (m MigrateMongoDbTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", m.ClientData)
	populate(objectMap, "commands", m.Commands)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	populate(objectMap, "state", m.State)
	objectMap["taskType"] = TaskTypeMigrateMongoDb
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMongoDbTaskProperties.
func (m *MigrateMongoDbTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &m.ClientData)
			delete(rawMsg, key)
		case "commands":
			m.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMongoDbProgressClassificationArray(val)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &m.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateMySQLAzureDbForMySQLOfflineDatabaseInput - Database specific information for offline MySQL to Azure Database for
// MySQL migration task inputs
type MigrateMySQLAzureDbForMySQLOfflineDatabaseInput struct {
	// Name of the database
	Name *string `json:"name,omitempty"`

	// Mapping of source to target tables
	TableMap map[string]*string `json:"tableMap,omitempty"`

	// Name of target database. Note: Target database will be truncated before starting migration.
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLOfflineDatabaseInput.
func (m MigrateMySQLAzureDbForMySQLOfflineDatabaseInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", m.Name)
	populate(objectMap, "tableMap", m.TableMap)
	populate(objectMap, "targetDatabaseName", m.TargetDatabaseName)
	return json.Marshal(objectMap)
}

// MigrateMySQLAzureDbForMySQLOfflineTaskInput - Input for the task that migrates MySQL databases to Azure Database for MySQL
// for offline migrations
type MigrateMySQLAzureDbForMySQLOfflineTaskInput struct {
	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateMySQLAzureDbForMySQLOfflineDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Connection information for source MySQL
	SourceConnectionInfo *MySQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Connection information for target Azure Database for MySQL
	TargetConnectionInfo *MySQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// encrypted key for secure fields
	EncryptedKeyForSecureFields *string `json:"encryptedKeyForSecureFields,omitempty"`

	// Setting to set the source server read only
	MakeSourceServerReadOnly *bool `json:"makeSourceServerReadOnly,omitempty"`

	// Optional parameters for fine tuning the data transfer rate during migration
	OptionalAgentSettings map[string]*string `json:"optionalAgentSettings,omitempty"`

	// Parameter to specify when the migration started
	StartedOn *time.Time `json:"startedOn,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLOfflineTaskInput.
func (m MigrateMySQLAzureDbForMySQLOfflineTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptedKeyForSecureFields", m.EncryptedKeyForSecureFields)
	populate(objectMap, "makeSourceServerReadOnly", m.MakeSourceServerReadOnly)
	populate(objectMap, "optionalAgentSettings", m.OptionalAgentSettings)
	populate(objectMap, "selectedDatabases", m.SelectedDatabases)
	populate(objectMap, "sourceConnectionInfo", m.SourceConnectionInfo)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "targetConnectionInfo", m.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLOfflineTaskInput.
func (m *MigrateMySQLAzureDbForMySQLOfflineTaskInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedKeyForSecureFields":
			err = unpopulate(val, &m.EncryptedKeyForSecureFields)
			delete(rawMsg, key)
		case "makeSourceServerReadOnly":
			err = unpopulate(val, &m.MakeSourceServerReadOnly)
			delete(rawMsg, key)
		case "optionalAgentSettings":
			err = unpopulate(val, &m.OptionalAgentSettings)
			delete(rawMsg, key)
		case "selectedDatabases":
			err = unpopulate(val, &m.SelectedDatabases)
			delete(rawMsg, key)
		case "sourceConnectionInfo":
			err = unpopulate(val, &m.SourceConnectionInfo)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "targetConnectionInfo":
			err = unpopulate(val, &m.TargetConnectionInfo)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateMySQLAzureDbForMySQLOfflineTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateMySQLAzureDbForMySQLOfflineTaskOutput, *MigrateMySQLAzureDbForMySQLOfflineTaskOutputDatabaseLevel, *MigrateMySQLAzureDbForMySQLOfflineTaskOutputError,
// - *MigrateMySQLAzureDbForMySQLOfflineTaskOutputMigrationLevel, *MigrateMySQLAzureDbForMySQLOfflineTaskOutputTableLevel
type MigrateMySQLAzureDbForMySQLOfflineTaskOutputClassification interface {
	// GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput returns the MigrateMySQLAzureDbForMySQLOfflineTaskOutput content of the underlying type.
	GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput() *MigrateMySQLAzureDbForMySQLOfflineTaskOutput
}

// MigrateMySQLAzureDbForMySQLOfflineTaskOutput - Output for the task that migrates MySQL databases to Azure Database for
// MySQL for offline migrations
type MigrateMySQLAzureDbForMySQLOfflineTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput implements the MigrateMySQLAzureDbForMySQLOfflineTaskOutputClassification
// interface for type MigrateMySQLAzureDbForMySQLOfflineTaskOutput.
func (m *MigrateMySQLAzureDbForMySQLOfflineTaskOutput) GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput() *MigrateMySQLAzureDbForMySQLOfflineTaskOutput {
	return m
}

type MigrateMySQLAzureDbForMySQLOfflineTaskOutputDatabaseLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of database/object errors.
	ErrorCount *int64 `json:"errorCount,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all errors of the item
	ErrorPrefix *string `json:"errorPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Migration exceptions and warnings.
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Last time the storage was updated
	LastStorageUpdate *time.Time `json:"lastStorageUpdate,omitempty" azure:"ro"`

	// READ-ONLY; Migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Number of objects
	NumberOfObjects *int64 `json:"numberOfObjects,omitempty" azure:"ro"`

	// READ-ONLY; Number of successfully completed objects
	NumberOfObjectsCompleted *int64 `json:"numberOfObjectsCompleted,omitempty" azure:"ro"`

	// READ-ONLY; Summary of object results in the migration
	ObjectSummary *string `json:"objectSummary,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all sub-tem results of the item
	ResultPrefix *string `json:"resultPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Migration stage that this database is in
	Stage *DatabaseMigrationStage `json:"stage,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Status message
	StatusMessage *string `json:"statusMessage,omitempty" azure:"ro"`
}

// GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput implements the MigrateMySQLAzureDbForMySQLOfflineTaskOutputClassification
// interface for type MigrateMySQLAzureDbForMySQLOfflineTaskOutputDatabaseLevel.
func (m *MigrateMySQLAzureDbForMySQLOfflineTaskOutputDatabaseLevel) GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput() *MigrateMySQLAzureDbForMySQLOfflineTaskOutput {
	return &MigrateMySQLAzureDbForMySQLOfflineTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLOfflineTaskOutputDatabaseLevel.
func (m MigrateMySQLAzureDbForMySQLOfflineTaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databaseName", m.DatabaseName)
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "errorCount", m.ErrorCount)
	populate(objectMap, "errorPrefix", m.ErrorPrefix)
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "id", m.ID)
	populateTimeRFC3339(objectMap, "lastStorageUpdate", m.LastStorageUpdate)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "numberOfObjects", m.NumberOfObjects)
	populate(objectMap, "numberOfObjectsCompleted", m.NumberOfObjectsCompleted)
	populate(objectMap, "objectSummary", m.ObjectSummary)
	populate(objectMap, "resultPrefix", m.ResultPrefix)
	objectMap["resultType"] = "DatabaseLevelOutput"
	populate(objectMap, "stage", m.Stage)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "state", m.State)
	populate(objectMap, "statusMessage", m.StatusMessage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLOfflineTaskOutputDatabaseLevel.
func (m *MigrateMySQLAzureDbForMySQLOfflineTaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "errorCount":
			err = unpopulate(val, &m.ErrorCount)
			delete(rawMsg, key)
		case "errorPrefix":
			err = unpopulate(val, &m.ErrorPrefix)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "lastStorageUpdate":
			err = unpopulateTimeRFC3339(val, &m.LastStorageUpdate)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "numberOfObjects":
			err = unpopulate(val, &m.NumberOfObjects)
			delete(rawMsg, key)
		case "numberOfObjectsCompleted":
			err = unpopulate(val, &m.NumberOfObjectsCompleted)
			delete(rawMsg, key)
		case "objectSummary":
			err = unpopulate(val, &m.ObjectSummary)
			delete(rawMsg, key)
		case "resultPrefix":
			err = unpopulate(val, &m.ResultPrefix)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "stage":
			err = unpopulate(val, &m.Stage)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "statusMessage":
			err = unpopulate(val, &m.StatusMessage)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateMySQLAzureDbForMySQLOfflineTaskOutputError struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Migration error
	Error *ReportableException `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput implements the MigrateMySQLAzureDbForMySQLOfflineTaskOutputClassification
// interface for type MigrateMySQLAzureDbForMySQLOfflineTaskOutputError.
func (m *MigrateMySQLAzureDbForMySQLOfflineTaskOutputError) GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput() *MigrateMySQLAzureDbForMySQLOfflineTaskOutput {
	return &MigrateMySQLAzureDbForMySQLOfflineTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLOfflineTaskOutputError.
func (m MigrateMySQLAzureDbForMySQLOfflineTaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", m.Error)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "ErrorOutput"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLOfflineTaskOutputError.
func (m *MigrateMySQLAzureDbForMySQLOfflineTaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &m.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateMySQLAzureDbForMySQLOfflineTaskOutputMigrationLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// Selected databases as a map from database name to database id
	Databases *string `json:"databases,omitempty"`

	// Migration Report Result, provides unique url for downloading your migration report.
	MigrationReportResult *MigrationReportResult `json:"migrationReportResult,omitempty"`

	// READ-ONLY; Summary of database results in the migration
	DatabaseSummary *string `json:"databaseSummary,omitempty" azure:"ro"`

	// READ-ONLY; Duration of task execution in seconds.
	DurationInSeconds *int64 `json:"durationInSeconds,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Migration exceptions and warnings.
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Last time the storage was updated
	LastStorageUpdate *time.Time `json:"lastStorageUpdate,omitempty" azure:"ro"`

	// READ-ONLY; Migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Source server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current status of migration
	Status *MigrationStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Migration status message
	StatusMessage *string `json:"statusMessage,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput implements the MigrateMySQLAzureDbForMySQLOfflineTaskOutputClassification
// interface for type MigrateMySQLAzureDbForMySQLOfflineTaskOutputMigrationLevel.
func (m *MigrateMySQLAzureDbForMySQLOfflineTaskOutputMigrationLevel) GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput() *MigrateMySQLAzureDbForMySQLOfflineTaskOutput {
	return &MigrateMySQLAzureDbForMySQLOfflineTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLOfflineTaskOutputMigrationLevel.
func (m MigrateMySQLAzureDbForMySQLOfflineTaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databaseSummary", m.DatabaseSummary)
	populate(objectMap, "databases", m.Databases)
	populate(objectMap, "durationInSeconds", m.DurationInSeconds)
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "id", m.ID)
	populateTimeRFC3339(objectMap, "lastStorageUpdate", m.LastStorageUpdate)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "migrationReportResult", m.MigrationReportResult)
	objectMap["resultType"] = "MigrationLevelOutput"
	populate(objectMap, "sourceServerBrandVersion", m.SourceServerBrandVersion)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "status", m.Status)
	populate(objectMap, "statusMessage", m.StatusMessage)
	populate(objectMap, "targetServerBrandVersion", m.TargetServerBrandVersion)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLOfflineTaskOutputMigrationLevel.
func (m *MigrateMySQLAzureDbForMySQLOfflineTaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseSummary":
			err = unpopulate(val, &m.DatabaseSummary)
			delete(rawMsg, key)
		case "databases":
			err = unpopulate(val, &m.Databases)
			delete(rawMsg, key)
		case "durationInSeconds":
			err = unpopulate(val, &m.DurationInSeconds)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "lastStorageUpdate":
			err = unpopulateTimeRFC3339(val, &m.LastStorageUpdate)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "migrationReportResult":
			err = unpopulate(val, &m.MigrationReportResult)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "sourceServerBrandVersion":
			err = unpopulate(val, &m.SourceServerBrandVersion)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		case "statusMessage":
			err = unpopulate(val, &m.StatusMessage)
			delete(rawMsg, key)
		case "targetServerBrandVersion":
			err = unpopulate(val, &m.TargetServerBrandVersion)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateMySQLAzureDbForMySQLOfflineTaskOutputTableLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all errors of the item
	ErrorPrefix *string `json:"errorPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Number of successfully completed items
	ItemsCompletedCount *int64 `json:"itemsCompletedCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of items
	ItemsCount *int64 `json:"itemsCount,omitempty" azure:"ro"`

	// READ-ONLY; Last time the storage was updated
	LastStorageUpdate *time.Time `json:"lastStorageUpdate,omitempty" azure:"ro"`

	// READ-ONLY; Name of the item
	ObjectName *string `json:"objectName,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all sub-tem results of the item
	ResultPrefix *string `json:"resultPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Status message
	StatusMessage *string `json:"statusMessage,omitempty" azure:"ro"`
}

// GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput implements the MigrateMySQLAzureDbForMySQLOfflineTaskOutputClassification
// interface for type MigrateMySQLAzureDbForMySQLOfflineTaskOutputTableLevel.
func (m *MigrateMySQLAzureDbForMySQLOfflineTaskOutputTableLevel) GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput() *MigrateMySQLAzureDbForMySQLOfflineTaskOutput {
	return &MigrateMySQLAzureDbForMySQLOfflineTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLOfflineTaskOutputTableLevel.
func (m MigrateMySQLAzureDbForMySQLOfflineTaskOutputTableLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "errorPrefix", m.ErrorPrefix)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "itemsCompletedCount", m.ItemsCompletedCount)
	populate(objectMap, "itemsCount", m.ItemsCount)
	populateTimeRFC3339(objectMap, "lastStorageUpdate", m.LastStorageUpdate)
	populate(objectMap, "objectName", m.ObjectName)
	populate(objectMap, "resultPrefix", m.ResultPrefix)
	objectMap["resultType"] = "TableLevelOutput"
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "state", m.State)
	populate(objectMap, "statusMessage", m.StatusMessage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLOfflineTaskOutputTableLevel.
func (m *MigrateMySQLAzureDbForMySQLOfflineTaskOutputTableLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "errorPrefix":
			err = unpopulate(val, &m.ErrorPrefix)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "itemsCompletedCount":
			err = unpopulate(val, &m.ItemsCompletedCount)
			delete(rawMsg, key)
		case "itemsCount":
			err = unpopulate(val, &m.ItemsCount)
			delete(rawMsg, key)
		case "lastStorageUpdate":
			err = unpopulateTimeRFC3339(val, &m.LastStorageUpdate)
			delete(rawMsg, key)
		case "objectName":
			err = unpopulate(val, &m.ObjectName)
			delete(rawMsg, key)
		case "resultPrefix":
			err = unpopulate(val, &m.ResultPrefix)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "statusMessage":
			err = unpopulate(val, &m.StatusMessage)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateMySQLAzureDbForMySQLOfflineTaskProperties - Properties for the task that migrates MySQL databases to Azure Database
// for MySQL for offline migrations
type MigrateMySQLAzureDbForMySQLOfflineTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *MigrateMySQLAzureDbForMySQLOfflineTaskInput `json:"input,omitempty"`

	// whether the task can be cloned or not
	IsCloneable *bool `json:"isCloneable,omitempty"`

	// Task id
	TaskID *string `json:"taskId,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateMySQLAzureDbForMySQLOfflineTaskOutputClassification `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type MigrateMySQLAzureDbForMySQLOfflineTaskProperties.
func (m *MigrateMySQLAzureDbForMySQLOfflineTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   m.TaskType,
		Errors:     m.Errors,
		State:      m.State,
		Commands:   m.Commands,
		ClientData: m.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLOfflineTaskProperties.
func (m MigrateMySQLAzureDbForMySQLOfflineTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", m.ClientData)
	populate(objectMap, "commands", m.Commands)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "input", m.Input)
	populate(objectMap, "isCloneable", m.IsCloneable)
	populate(objectMap, "output", m.Output)
	populate(objectMap, "state", m.State)
	populate(objectMap, "taskId", m.TaskID)
	objectMap["taskType"] = TaskTypeMigrateMySQLAzureDbForMySQL
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLOfflineTaskProperties.
func (m *MigrateMySQLAzureDbForMySQLOfflineTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &m.ClientData)
			delete(rawMsg, key)
		case "commands":
			m.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "isCloneable":
			err = unpopulate(val, &m.IsCloneable)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateMySQLAzureDbForMySQLOfflineTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "taskId":
			err = unpopulate(val, &m.TaskID)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &m.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateMySQLAzureDbForMySQLSyncDatabaseInput - Database specific information for MySQL to Azure Database for MySQL migration
// task inputs
type MigrateMySQLAzureDbForMySQLSyncDatabaseInput struct {
	// Migration settings which tune the migration behavior
	MigrationSetting map[string]*string `json:"migrationSetting,omitempty"`

	// Name of the database
	Name *string `json:"name,omitempty"`

	// Source settings to tune source endpoint migration behavior
	SourceSetting map[string]*string `json:"sourceSetting,omitempty"`

	// Mapping of source to target tables
	TableMap map[string]*string `json:"tableMap,omitempty"`

	// Name of target database. Note: Target database will be truncated before starting migration.
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty"`

	// Target settings to tune target endpoint migration behavior
	TargetSetting map[string]*string `json:"targetSetting,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLSyncDatabaseInput.
func (m MigrateMySQLAzureDbForMySQLSyncDatabaseInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "migrationSetting", m.MigrationSetting)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "sourceSetting", m.SourceSetting)
	populate(objectMap, "tableMap", m.TableMap)
	populate(objectMap, "targetDatabaseName", m.TargetDatabaseName)
	populate(objectMap, "targetSetting", m.TargetSetting)
	return json.Marshal(objectMap)
}

// MigrateMySQLAzureDbForMySQLSyncTaskInput - Input for the task that migrates MySQL databases to Azure Database for MySQL
// for online migrations
type MigrateMySQLAzureDbForMySQLSyncTaskInput struct {
	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateMySQLAzureDbForMySQLSyncDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Connection information for source MySQL
	SourceConnectionInfo *MySQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Connection information for target Azure Database for MySQL
	TargetConnectionInfo *MySQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskInput.
func (m MigrateMySQLAzureDbForMySQLSyncTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "selectedDatabases", m.SelectedDatabases)
	populate(objectMap, "sourceConnectionInfo", m.SourceConnectionInfo)
	populate(objectMap, "targetConnectionInfo", m.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// MigrateMySQLAzureDbForMySQLSyncTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateMySQLAzureDbForMySQLSyncTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateMySQLAzureDbForMySQLSyncTaskOutput, *MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseError, *MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseLevel,
// - *MigrateMySQLAzureDbForMySQLSyncTaskOutputError, *MigrateMySQLAzureDbForMySQLSyncTaskOutputMigrationLevel, *MigrateMySQLAzureDbForMySQLSyncTaskOutputTableLevel
type MigrateMySQLAzureDbForMySQLSyncTaskOutputClassification interface {
	// GetMigrateMySQLAzureDbForMySQLSyncTaskOutput returns the MigrateMySQLAzureDbForMySQLSyncTaskOutput content of the underlying type.
	GetMigrateMySQLAzureDbForMySQLSyncTaskOutput() *MigrateMySQLAzureDbForMySQLSyncTaskOutput
}

// MigrateMySQLAzureDbForMySQLSyncTaskOutput - Output for the task that migrates MySQL databases to Azure Database for MySQL
// for online migrations
type MigrateMySQLAzureDbForMySQLSyncTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateMySQLAzureDbForMySQLSyncTaskOutput implements the MigrateMySQLAzureDbForMySQLSyncTaskOutputClassification interface
// for type MigrateMySQLAzureDbForMySQLSyncTaskOutput.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutput) GetMigrateMySQLAzureDbForMySQLSyncTaskOutput() *MigrateMySQLAzureDbForMySQLSyncTaskOutput {
	return m
}

type MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseError struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// Error message
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// List of error events.
	Events []*SyncMigrationDatabaseErrorEvent `json:"events,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateMySQLAzureDbForMySQLSyncTaskOutput implements the MigrateMySQLAzureDbForMySQLSyncTaskOutputClassification interface
// for type MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseError.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseError) GetMigrateMySQLAzureDbForMySQLSyncTaskOutput() *MigrateMySQLAzureDbForMySQLSyncTaskOutput {
	return &MigrateMySQLAzureDbForMySQLSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseError.
func (m MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errorMessage", m.ErrorMessage)
	populate(objectMap, "events", m.Events)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "DatabaseLevelErrorOutput"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseError.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorMessage":
			err = unpopulate(val, &m.ErrorMessage)
			delete(rawMsg, key)
		case "events":
			err = unpopulate(val, &m.Events)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Number of applied changes
	AppliedChanges *int64 `json:"appliedChanges,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc deletes
	CdcDeleteCounter *int64 `json:"cdcDeleteCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc inserts
	CdcInsertCounter *int64 `json:"cdcInsertCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc updates
	CdcUpdateCounter *int64 `json:"cdcUpdateCounter,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables completed in full load
	FullLoadCompletedTables *int64 `json:"fullLoadCompletedTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables errored in full load
	FullLoadErroredTables *int64 `json:"fullLoadErroredTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables loading in full load
	FullLoadLoadingTables *int64 `json:"fullLoadLoadingTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables queued in full load
	FullLoadQueuedTables *int64 `json:"fullLoadQueuedTables,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Number of incoming changes
	IncomingChanges *int64 `json:"incomingChanges,omitempty" azure:"ro"`

	// READ-ONLY; Indicates if initial load (full load) has been completed
	InitializationCompleted *bool `json:"initializationCompleted,omitempty" azure:"ro"`

	// READ-ONLY; CDC apply latency
	Latency *int64 `json:"latency,omitempty" azure:"ro"`

	// READ-ONLY; Migration state that this database is in
	MigrationState *SyncDatabaseMigrationReportingState `json:"migrationState,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`
}

// GetMigrateMySQLAzureDbForMySQLSyncTaskOutput implements the MigrateMySQLAzureDbForMySQLSyncTaskOutputClassification interface
// for type MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseLevel.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseLevel) GetMigrateMySQLAzureDbForMySQLSyncTaskOutput() *MigrateMySQLAzureDbForMySQLSyncTaskOutput {
	return &MigrateMySQLAzureDbForMySQLSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseLevel.
func (m MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "appliedChanges", m.AppliedChanges)
	populate(objectMap, "cdcDeleteCounter", m.CdcDeleteCounter)
	populate(objectMap, "cdcInsertCounter", m.CdcInsertCounter)
	populate(objectMap, "cdcUpdateCounter", m.CdcUpdateCounter)
	populate(objectMap, "databaseName", m.DatabaseName)
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "fullLoadCompletedTables", m.FullLoadCompletedTables)
	populate(objectMap, "fullLoadErroredTables", m.FullLoadErroredTables)
	populate(objectMap, "fullLoadLoadingTables", m.FullLoadLoadingTables)
	populate(objectMap, "fullLoadQueuedTables", m.FullLoadQueuedTables)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "incomingChanges", m.IncomingChanges)
	populate(objectMap, "initializationCompleted", m.InitializationCompleted)
	populate(objectMap, "latency", m.Latency)
	populate(objectMap, "migrationState", m.MigrationState)
	objectMap["resultType"] = "DatabaseLevelOutput"
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseLevel.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appliedChanges":
			err = unpopulate(val, &m.AppliedChanges)
			delete(rawMsg, key)
		case "cdcDeleteCounter":
			err = unpopulate(val, &m.CdcDeleteCounter)
			delete(rawMsg, key)
		case "cdcInsertCounter":
			err = unpopulate(val, &m.CdcInsertCounter)
			delete(rawMsg, key)
		case "cdcUpdateCounter":
			err = unpopulate(val, &m.CdcUpdateCounter)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "fullLoadCompletedTables":
			err = unpopulate(val, &m.FullLoadCompletedTables)
			delete(rawMsg, key)
		case "fullLoadErroredTables":
			err = unpopulate(val, &m.FullLoadErroredTables)
			delete(rawMsg, key)
		case "fullLoadLoadingTables":
			err = unpopulate(val, &m.FullLoadLoadingTables)
			delete(rawMsg, key)
		case "fullLoadQueuedTables":
			err = unpopulate(val, &m.FullLoadQueuedTables)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "incomingChanges":
			err = unpopulate(val, &m.IncomingChanges)
			delete(rawMsg, key)
		case "initializationCompleted":
			err = unpopulate(val, &m.InitializationCompleted)
			delete(rawMsg, key)
		case "latency":
			err = unpopulate(val, &m.Latency)
			delete(rawMsg, key)
		case "migrationState":
			err = unpopulate(val, &m.MigrationState)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateMySQLAzureDbForMySQLSyncTaskOutputError struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Migration error
	Error *ReportableException `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateMySQLAzureDbForMySQLSyncTaskOutput implements the MigrateMySQLAzureDbForMySQLSyncTaskOutputClassification interface
// for type MigrateMySQLAzureDbForMySQLSyncTaskOutputError.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutputError) GetMigrateMySQLAzureDbForMySQLSyncTaskOutput() *MigrateMySQLAzureDbForMySQLSyncTaskOutput {
	return &MigrateMySQLAzureDbForMySQLSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputError.
func (m MigrateMySQLAzureDbForMySQLSyncTaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", m.Error)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "ErrorOutput"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputError.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &m.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateMySQLAzureDbForMySQLSyncTaskOutputMigrationLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Source server name
	SourceServer *string `json:"sourceServer,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Target server name
	TargetServer *string `json:"targetServer,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// GetMigrateMySQLAzureDbForMySQLSyncTaskOutput implements the MigrateMySQLAzureDbForMySQLSyncTaskOutputClassification interface
// for type MigrateMySQLAzureDbForMySQLSyncTaskOutputMigrationLevel.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutputMigrationLevel) GetMigrateMySQLAzureDbForMySQLSyncTaskOutput() *MigrateMySQLAzureDbForMySQLSyncTaskOutput {
	return &MigrateMySQLAzureDbForMySQLSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputMigrationLevel.
func (m MigrateMySQLAzureDbForMySQLSyncTaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "MigrationLevelOutput"
	populate(objectMap, "sourceServer", m.SourceServer)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "targetServer", m.TargetServer)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputMigrationLevel.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "sourceServer":
			err = unpopulate(val, &m.SourceServer)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "targetServer":
			err = unpopulate(val, &m.TargetServer)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateMySQLAzureDbForMySQLSyncTaskOutputTableLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Number of applied deletes
	CdcDeleteCounter *string `json:"cdcDeleteCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of applied inserts
	CdcInsertCounter *string `json:"cdcInsertCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of applied updates
	CdcUpdateCounter *string `json:"cdcUpdateCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of data errors occurred
	DataErrorsCounter *int64 `json:"dataErrorsCounter,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Full load end time
	FullLoadEndedOn *time.Time `json:"fullLoadEndedOn,omitempty" azure:"ro"`

	// READ-ONLY; Estimate to finish full load
	FullLoadEstFinishTime *time.Time `json:"fullLoadEstFinishTime,omitempty" azure:"ro"`

	// READ-ONLY; Full load start time
	FullLoadStartedOn *time.Time `json:"fullLoadStartedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of rows applied in full load
	FullLoadTotalRows *int64 `json:"fullLoadTotalRows,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Last modified time on target
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty" azure:"ro"`

	// READ-ONLY; Current state of the table migration
	State *SyncTableMigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Name of the table
	TableName *string `json:"tableName,omitempty" azure:"ro"`

	// READ-ONLY; Total number of applied changes
	TotalChangesApplied *int64 `json:"totalChangesApplied,omitempty" azure:"ro"`
}

// GetMigrateMySQLAzureDbForMySQLSyncTaskOutput implements the MigrateMySQLAzureDbForMySQLSyncTaskOutputClassification interface
// for type MigrateMySQLAzureDbForMySQLSyncTaskOutputTableLevel.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutputTableLevel) GetMigrateMySQLAzureDbForMySQLSyncTaskOutput() *MigrateMySQLAzureDbForMySQLSyncTaskOutput {
	return &MigrateMySQLAzureDbForMySQLSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputTableLevel.
func (m MigrateMySQLAzureDbForMySQLSyncTaskOutputTableLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cdcDeleteCounter", m.CdcDeleteCounter)
	populate(objectMap, "cdcInsertCounter", m.CdcInsertCounter)
	populate(objectMap, "cdcUpdateCounter", m.CdcUpdateCounter)
	populate(objectMap, "dataErrorsCounter", m.DataErrorsCounter)
	populate(objectMap, "databaseName", m.DatabaseName)
	populateTimeRFC3339(objectMap, "fullLoadEndedOn", m.FullLoadEndedOn)
	populateTimeRFC3339(objectMap, "fullLoadEstFinishTime", m.FullLoadEstFinishTime)
	populateTimeRFC3339(objectMap, "fullLoadStartedOn", m.FullLoadStartedOn)
	populate(objectMap, "fullLoadTotalRows", m.FullLoadTotalRows)
	populate(objectMap, "id", m.ID)
	populateTimeRFC3339(objectMap, "lastModifiedTime", m.LastModifiedTime)
	objectMap["resultType"] = "TableLevelOutput"
	populate(objectMap, "state", m.State)
	populate(objectMap, "tableName", m.TableName)
	populate(objectMap, "totalChangesApplied", m.TotalChangesApplied)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputTableLevel.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutputTableLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cdcDeleteCounter":
			err = unpopulate(val, &m.CdcDeleteCounter)
			delete(rawMsg, key)
		case "cdcInsertCounter":
			err = unpopulate(val, &m.CdcInsertCounter)
			delete(rawMsg, key)
		case "cdcUpdateCounter":
			err = unpopulate(val, &m.CdcUpdateCounter)
			delete(rawMsg, key)
		case "dataErrorsCounter":
			err = unpopulate(val, &m.DataErrorsCounter)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "fullLoadEndedOn":
			err = unpopulateTimeRFC3339(val, &m.FullLoadEndedOn)
			delete(rawMsg, key)
		case "fullLoadEstFinishTime":
			err = unpopulateTimeRFC3339(val, &m.FullLoadEstFinishTime)
			delete(rawMsg, key)
		case "fullLoadStartedOn":
			err = unpopulateTimeRFC3339(val, &m.FullLoadStartedOn)
			delete(rawMsg, key)
		case "fullLoadTotalRows":
			err = unpopulate(val, &m.FullLoadTotalRows)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, &m.LastModifiedTime)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, &m.TableName)
			delete(rawMsg, key)
		case "totalChangesApplied":
			err = unpopulate(val, &m.TotalChangesApplied)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateMySQLAzureDbForMySQLSyncTaskProperties - Properties for the task that migrates MySQL databases to Azure Database
// for MySQL for online migrations
type MigrateMySQLAzureDbForMySQLSyncTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *MigrateMySQLAzureDbForMySQLSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateMySQLAzureDbForMySQLSyncTaskOutputClassification `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type MigrateMySQLAzureDbForMySQLSyncTaskProperties.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   m.TaskType,
		Errors:     m.Errors,
		State:      m.State,
		Commands:   m.Commands,
		ClientData: m.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskProperties.
func (m MigrateMySQLAzureDbForMySQLSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", m.ClientData)
	populate(objectMap, "commands", m.Commands)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	populate(objectMap, "state", m.State)
	objectMap["taskType"] = TaskTypeMigrateMySQLAzureDbForMySQLSync
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskProperties.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &m.ClientData)
			delete(rawMsg, key)
		case "commands":
			m.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateMySQLAzureDbForMySQLSyncTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &m.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateOracleAzureDbForPostgreSQLSyncTaskProperties - Properties for the task that migrates Oracle to Azure Database for
// PostgreSQL for online migrations
type MigrateOracleAzureDbForPostgreSQLSyncTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *MigrateOracleAzureDbPostgreSQLSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateOracleAzureDbPostgreSQLSyncTaskOutputClassification `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type MigrateOracleAzureDbForPostgreSQLSyncTaskProperties.
func (m *MigrateOracleAzureDbForPostgreSQLSyncTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   m.TaskType,
		Errors:     m.Errors,
		State:      m.State,
		Commands:   m.Commands,
		ClientData: m.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateOracleAzureDbForPostgreSQLSyncTaskProperties.
func (m MigrateOracleAzureDbForPostgreSQLSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", m.ClientData)
	populate(objectMap, "commands", m.Commands)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	populate(objectMap, "state", m.State)
	objectMap["taskType"] = TaskTypeMigrateOracleAzureDbForPostgreSQLSync
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateOracleAzureDbForPostgreSQLSyncTaskProperties.
func (m *MigrateOracleAzureDbForPostgreSQLSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &m.ClientData)
			delete(rawMsg, key)
		case "commands":
			m.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateOracleAzureDbPostgreSQLSyncTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &m.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateOracleAzureDbPostgreSQLSyncDatabaseInput - Database specific information for Oracle to Azure Database for PostgreSQL
// migration task inputs
type MigrateOracleAzureDbPostgreSQLSyncDatabaseInput struct {
	// How to handle object name casing: either Preserve or ToLower
	CaseManipulation *string `json:"caseManipulation,omitempty"`

	// Migration settings which tune the migration behavior
	MigrationSetting map[string]*string `json:"migrationSetting,omitempty"`

	// Name of the migration pipeline
	Name *string `json:"name,omitempty"`

	// Name of the source schema
	SchemaName *string `json:"schemaName,omitempty"`

	// Source settings to tune source endpoint migration behavior
	SourceSetting map[string]*string `json:"sourceSetting,omitempty"`

	// Mapping of source to target tables
	TableMap map[string]*string `json:"tableMap,omitempty"`

	// Name of target database. Note: Target database will be truncated before starting migration.
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty"`

	// Target settings to tune target endpoint migration behavior
	TargetSetting map[string]*string `json:"targetSetting,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateOracleAzureDbPostgreSQLSyncDatabaseInput.
func (m MigrateOracleAzureDbPostgreSQLSyncDatabaseInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "caseManipulation", m.CaseManipulation)
	populate(objectMap, "migrationSetting", m.MigrationSetting)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "schemaName", m.SchemaName)
	populate(objectMap, "sourceSetting", m.SourceSetting)
	populate(objectMap, "tableMap", m.TableMap)
	populate(objectMap, "targetDatabaseName", m.TargetDatabaseName)
	populate(objectMap, "targetSetting", m.TargetSetting)
	return json.Marshal(objectMap)
}

// MigrateOracleAzureDbPostgreSQLSyncTaskInput - Input for the task that migrates Oracle databases to Azure Database for PostgreSQL
// for online migrations
type MigrateOracleAzureDbPostgreSQLSyncTaskInput struct {
	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateOracleAzureDbPostgreSQLSyncDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Connection information for source Oracle
	SourceConnectionInfo *OracleConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Connection information for target Azure Database for PostgreSQL
	TargetConnectionInfo *PostgreSQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskInput.
func (m MigrateOracleAzureDbPostgreSQLSyncTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "selectedDatabases", m.SelectedDatabases)
	populate(objectMap, "sourceConnectionInfo", m.SourceConnectionInfo)
	populate(objectMap, "targetConnectionInfo", m.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// MigrateOracleAzureDbPostgreSQLSyncTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateOracleAzureDbPostgreSQLSyncTaskOutput, *MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseError, *MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseLevel,
// - *MigrateOracleAzureDbPostgreSQLSyncTaskOutputError, *MigrateOracleAzureDbPostgreSQLSyncTaskOutputMigrationLevel, *MigrateOracleAzureDbPostgreSQLSyncTaskOutputTableLevel
type MigrateOracleAzureDbPostgreSQLSyncTaskOutputClassification interface {
	// GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput returns the MigrateOracleAzureDbPostgreSQLSyncTaskOutput content of the underlying type.
	GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput() *MigrateOracleAzureDbPostgreSQLSyncTaskOutput
}

// MigrateOracleAzureDbPostgreSQLSyncTaskOutput - Output for the task that migrates Oracle databases to Azure Database for
// PostgreSQL for online migrations
type MigrateOracleAzureDbPostgreSQLSyncTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput implements the MigrateOracleAzureDbPostgreSQLSyncTaskOutputClassification
// interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutput.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutput) GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput() *MigrateOracleAzureDbPostgreSQLSyncTaskOutput {
	return m
}

type MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseError struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// Error message
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// List of error events.
	Events []*SyncMigrationDatabaseErrorEvent `json:"events,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput implements the MigrateOracleAzureDbPostgreSQLSyncTaskOutputClassification
// interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseError.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseError) GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput() *MigrateOracleAzureDbPostgreSQLSyncTaskOutput {
	return &MigrateOracleAzureDbPostgreSQLSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseError.
func (m MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errorMessage", m.ErrorMessage)
	populate(objectMap, "events", m.Events)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "DatabaseLevelErrorOutput"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseError.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorMessage":
			err = unpopulate(val, &m.ErrorMessage)
			delete(rawMsg, key)
		case "events":
			err = unpopulate(val, &m.Events)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Number of applied changes
	AppliedChanges *int64 `json:"appliedChanges,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc deletes
	CdcDeleteCounter *int64 `json:"cdcDeleteCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc inserts
	CdcInsertCounter *int64 `json:"cdcInsertCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc updates
	CdcUpdateCounter *int64 `json:"cdcUpdateCounter,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables completed in full load
	FullLoadCompletedTables *int64 `json:"fullLoadCompletedTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables errored in full load
	FullLoadErroredTables *int64 `json:"fullLoadErroredTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables loading in full load
	FullLoadLoadingTables *int64 `json:"fullLoadLoadingTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables queued in full load
	FullLoadQueuedTables *int64 `json:"fullLoadQueuedTables,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Number of incoming changes
	IncomingChanges *int64 `json:"incomingChanges,omitempty" azure:"ro"`

	// READ-ONLY; Indicates if initial load (full load) has been completed
	InitializationCompleted *bool `json:"initializationCompleted,omitempty" azure:"ro"`

	// READ-ONLY; CDC apply latency
	Latency *int64 `json:"latency,omitempty" azure:"ro"`

	// READ-ONLY; Migration state that this database is in
	MigrationState *SyncDatabaseMigrationReportingState `json:"migrationState,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`
}

// GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput implements the MigrateOracleAzureDbPostgreSQLSyncTaskOutputClassification
// interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseLevel.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseLevel) GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput() *MigrateOracleAzureDbPostgreSQLSyncTaskOutput {
	return &MigrateOracleAzureDbPostgreSQLSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseLevel.
func (m MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "appliedChanges", m.AppliedChanges)
	populate(objectMap, "cdcDeleteCounter", m.CdcDeleteCounter)
	populate(objectMap, "cdcInsertCounter", m.CdcInsertCounter)
	populate(objectMap, "cdcUpdateCounter", m.CdcUpdateCounter)
	populate(objectMap, "databaseName", m.DatabaseName)
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "fullLoadCompletedTables", m.FullLoadCompletedTables)
	populate(objectMap, "fullLoadErroredTables", m.FullLoadErroredTables)
	populate(objectMap, "fullLoadLoadingTables", m.FullLoadLoadingTables)
	populate(objectMap, "fullLoadQueuedTables", m.FullLoadQueuedTables)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "incomingChanges", m.IncomingChanges)
	populate(objectMap, "initializationCompleted", m.InitializationCompleted)
	populate(objectMap, "latency", m.Latency)
	populate(objectMap, "migrationState", m.MigrationState)
	objectMap["resultType"] = "DatabaseLevelOutput"
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseLevel.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appliedChanges":
			err = unpopulate(val, &m.AppliedChanges)
			delete(rawMsg, key)
		case "cdcDeleteCounter":
			err = unpopulate(val, &m.CdcDeleteCounter)
			delete(rawMsg, key)
		case "cdcInsertCounter":
			err = unpopulate(val, &m.CdcInsertCounter)
			delete(rawMsg, key)
		case "cdcUpdateCounter":
			err = unpopulate(val, &m.CdcUpdateCounter)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "fullLoadCompletedTables":
			err = unpopulate(val, &m.FullLoadCompletedTables)
			delete(rawMsg, key)
		case "fullLoadErroredTables":
			err = unpopulate(val, &m.FullLoadErroredTables)
			delete(rawMsg, key)
		case "fullLoadLoadingTables":
			err = unpopulate(val, &m.FullLoadLoadingTables)
			delete(rawMsg, key)
		case "fullLoadQueuedTables":
			err = unpopulate(val, &m.FullLoadQueuedTables)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "incomingChanges":
			err = unpopulate(val, &m.IncomingChanges)
			delete(rawMsg, key)
		case "initializationCompleted":
			err = unpopulate(val, &m.InitializationCompleted)
			delete(rawMsg, key)
		case "latency":
			err = unpopulate(val, &m.Latency)
			delete(rawMsg, key)
		case "migrationState":
			err = unpopulate(val, &m.MigrationState)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateOracleAzureDbPostgreSQLSyncTaskOutputError struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Migration error
	Error *ReportableException `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput implements the MigrateOracleAzureDbPostgreSQLSyncTaskOutputClassification
// interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputError.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutputError) GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput() *MigrateOracleAzureDbPostgreSQLSyncTaskOutput {
	return &MigrateOracleAzureDbPostgreSQLSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputError.
func (m MigrateOracleAzureDbPostgreSQLSyncTaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", m.Error)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "ErrorOutput"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputError.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &m.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateOracleAzureDbPostgreSQLSyncTaskOutputMigrationLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Source server name
	SourceServer *string `json:"sourceServer,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Target server name
	TargetServer *string `json:"targetServer,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput implements the MigrateOracleAzureDbPostgreSQLSyncTaskOutputClassification
// interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputMigrationLevel.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutputMigrationLevel) GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput() *MigrateOracleAzureDbPostgreSQLSyncTaskOutput {
	return &MigrateOracleAzureDbPostgreSQLSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputMigrationLevel.
func (m MigrateOracleAzureDbPostgreSQLSyncTaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "MigrationLevelOutput"
	populate(objectMap, "sourceServer", m.SourceServer)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "targetServer", m.TargetServer)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputMigrationLevel.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "sourceServer":
			err = unpopulate(val, &m.SourceServer)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "targetServer":
			err = unpopulate(val, &m.TargetServer)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateOracleAzureDbPostgreSQLSyncTaskOutputTableLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Number of applied deletes
	CdcDeleteCounter *int64 `json:"cdcDeleteCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of applied inserts
	CdcInsertCounter *int64 `json:"cdcInsertCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of applied updates
	CdcUpdateCounter *int64 `json:"cdcUpdateCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of data errors occurred
	DataErrorsCounter *int64 `json:"dataErrorsCounter,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Full load end time
	FullLoadEndedOn *time.Time `json:"fullLoadEndedOn,omitempty" azure:"ro"`

	// READ-ONLY; Estimate to finish full load
	FullLoadEstFinishTime *time.Time `json:"fullLoadEstFinishTime,omitempty" azure:"ro"`

	// READ-ONLY; Full load start time
	FullLoadStartedOn *time.Time `json:"fullLoadStartedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of rows applied in full load
	FullLoadTotalRows *int64 `json:"fullLoadTotalRows,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Last modified time on target
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty" azure:"ro"`

	// READ-ONLY; Current state of the table migration
	State *SyncTableMigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Name of the table
	TableName *string `json:"tableName,omitempty" azure:"ro"`

	// READ-ONLY; Total number of applied changes
	TotalChangesApplied *int64 `json:"totalChangesApplied,omitempty" azure:"ro"`
}

// GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput implements the MigrateOracleAzureDbPostgreSQLSyncTaskOutputClassification
// interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputTableLevel.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutputTableLevel) GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput() *MigrateOracleAzureDbPostgreSQLSyncTaskOutput {
	return &MigrateOracleAzureDbPostgreSQLSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputTableLevel.
func (m MigrateOracleAzureDbPostgreSQLSyncTaskOutputTableLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cdcDeleteCounter", m.CdcDeleteCounter)
	populate(objectMap, "cdcInsertCounter", m.CdcInsertCounter)
	populate(objectMap, "cdcUpdateCounter", m.CdcUpdateCounter)
	populate(objectMap, "dataErrorsCounter", m.DataErrorsCounter)
	populate(objectMap, "databaseName", m.DatabaseName)
	populateTimeRFC3339(objectMap, "fullLoadEndedOn", m.FullLoadEndedOn)
	populateTimeRFC3339(objectMap, "fullLoadEstFinishTime", m.FullLoadEstFinishTime)
	populateTimeRFC3339(objectMap, "fullLoadStartedOn", m.FullLoadStartedOn)
	populate(objectMap, "fullLoadTotalRows", m.FullLoadTotalRows)
	populate(objectMap, "id", m.ID)
	populateTimeRFC3339(objectMap, "lastModifiedTime", m.LastModifiedTime)
	objectMap["resultType"] = "TableLevelOutput"
	populate(objectMap, "state", m.State)
	populate(objectMap, "tableName", m.TableName)
	populate(objectMap, "totalChangesApplied", m.TotalChangesApplied)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputTableLevel.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutputTableLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cdcDeleteCounter":
			err = unpopulate(val, &m.CdcDeleteCounter)
			delete(rawMsg, key)
		case "cdcInsertCounter":
			err = unpopulate(val, &m.CdcInsertCounter)
			delete(rawMsg, key)
		case "cdcUpdateCounter":
			err = unpopulate(val, &m.CdcUpdateCounter)
			delete(rawMsg, key)
		case "dataErrorsCounter":
			err = unpopulate(val, &m.DataErrorsCounter)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "fullLoadEndedOn":
			err = unpopulateTimeRFC3339(val, &m.FullLoadEndedOn)
			delete(rawMsg, key)
		case "fullLoadEstFinishTime":
			err = unpopulateTimeRFC3339(val, &m.FullLoadEstFinishTime)
			delete(rawMsg, key)
		case "fullLoadStartedOn":
			err = unpopulateTimeRFC3339(val, &m.FullLoadStartedOn)
			delete(rawMsg, key)
		case "fullLoadTotalRows":
			err = unpopulate(val, &m.FullLoadTotalRows)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, &m.LastModifiedTime)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, &m.TableName)
			delete(rawMsg, key)
		case "totalChangesApplied":
			err = unpopulate(val, &m.TotalChangesApplied)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigratePostgreSQLAzureDbForPostgreSQLSyncDatabaseInput - Database specific information for PostgreSQL to Azure Database
// for PostgreSQL migration task inputs
type MigratePostgreSQLAzureDbForPostgreSQLSyncDatabaseInput struct {
	// Migration settings which tune the migration behavior
	MigrationSetting map[string]interface{} `json:"migrationSetting,omitempty"`

	// Name of the database
	Name *string `json:"name,omitempty"`

	// Tables selected for migration
	SelectedTables []*MigratePostgreSQLAzureDbForPostgreSQLSyncDatabaseTableInput `json:"selectedTables,omitempty"`

	// Source settings to tune source endpoint migration behavior
	SourceSetting map[string]*string `json:"sourceSetting,omitempty"`

	// Name of target database. Note: Target database will be truncated before starting migration.
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty"`

	// Target settings to tune target endpoint migration behavior
	TargetSetting map[string]*string `json:"targetSetting,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncDatabaseInput.
func (m MigratePostgreSQLAzureDbForPostgreSQLSyncDatabaseInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	populate(objectMap, "migrationSetting", m.MigrationSetting)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "selectedTables", m.SelectedTables)
	populate(objectMap, "sourceSetting", m.SourceSetting)
	populate(objectMap, "targetDatabaseName", m.TargetDatabaseName)
	populate(objectMap, "targetSetting", m.TargetSetting)
	return json.Marshal(objectMap)
}

// MigratePostgreSQLAzureDbForPostgreSQLSyncDatabaseTableInput - Selected tables for the migration
type MigratePostgreSQLAzureDbForPostgreSQLSyncDatabaseTableInput struct {
	// Name of the table to migrate
	Name *string `json:"name,omitempty"`
}

// MigratePostgreSQLAzureDbForPostgreSQLSyncTaskInput - Input for the task that migrates PostgreSQL databases to Azure Database
// for PostgreSQL for online migrations
type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskInput struct {
	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigratePostgreSQLAzureDbForPostgreSQLSyncDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Connection information for source PostgreSQL
	SourceConnectionInfo *PostgreSQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Connection information for target Azure Database for PostgreSQL
	TargetConnectionInfo *PostgreSQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// encrypted key for secure fields
	EncryptedKeyForSecureFields *string `json:"encryptedKeyForSecureFields,omitempty"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskInput.
func (m MigratePostgreSQLAzureDbForPostgreSQLSyncTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptedKeyForSecureFields", m.EncryptedKeyForSecureFields)
	populate(objectMap, "selectedDatabases", m.SelectedDatabases)
	populate(objectMap, "sourceConnectionInfo", m.SourceConnectionInfo)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "targetConnectionInfo", m.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskInput.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptedKeyForSecureFields":
			err = unpopulate(val, &m.EncryptedKeyForSecureFields)
			delete(rawMsg, key)
		case "selectedDatabases":
			err = unpopulate(val, &m.SelectedDatabases)
			delete(rawMsg, key)
		case "sourceConnectionInfo":
			err = unpopulate(val, &m.SourceConnectionInfo)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "targetConnectionInfo":
			err = unpopulate(val, &m.TargetConnectionInfo)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput, *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseError,
// - *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseLevel, *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputError,
// - *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputMigrationLevel, *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputTableLevel
type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputClassification interface {
	// GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput returns the MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput content of the underlying type.
	GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput() *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput
}

// MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput - Output for the task that migrates PostgreSQL databases to Azure Database
// for PostgreSQL for online migrations
type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput implements the MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputClassification
// interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput) GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput() *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput {
	return m
}

type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseError struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// Error message
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// List of error events.
	Events []*SyncMigrationDatabaseErrorEvent `json:"events,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput implements the MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputClassification
// interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseError.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseError) GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput() *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput {
	return &MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseError.
func (m MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errorMessage", m.ErrorMessage)
	populate(objectMap, "events", m.Events)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "DatabaseLevelErrorOutput"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseError.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorMessage":
			err = unpopulate(val, &m.ErrorMessage)
			delete(rawMsg, key)
		case "events":
			err = unpopulate(val, &m.Events)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Number of applied changes
	AppliedChanges *int64 `json:"appliedChanges,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc deletes
	CdcDeleteCounter *int64 `json:"cdcDeleteCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc inserts
	CdcInsertCounter *int64 `json:"cdcInsertCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc updates
	CdcUpdateCounter *int64 `json:"cdcUpdateCounter,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables completed in full load
	FullLoadCompletedTables *int64 `json:"fullLoadCompletedTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables errored in full load
	FullLoadErroredTables *int64 `json:"fullLoadErroredTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables loading in full load
	FullLoadLoadingTables *int64 `json:"fullLoadLoadingTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables queued in full load
	FullLoadQueuedTables *int64 `json:"fullLoadQueuedTables,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Number of incoming changes
	IncomingChanges *int64 `json:"incomingChanges,omitempty" azure:"ro"`

	// READ-ONLY; Indicates if initial load (full load) has been completed
	InitializationCompleted *bool `json:"initializationCompleted,omitempty" azure:"ro"`

	// READ-ONLY; CDC apply latency
	Latency *int64 `json:"latency,omitempty" azure:"ro"`

	// READ-ONLY; Migration state that this database is in
	MigrationState *SyncDatabaseMigrationReportingState `json:"migrationState,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`
}

// GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput implements the MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputClassification
// interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseLevel.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseLevel) GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput() *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput {
	return &MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseLevel.
func (m MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "appliedChanges", m.AppliedChanges)
	populate(objectMap, "cdcDeleteCounter", m.CdcDeleteCounter)
	populate(objectMap, "cdcInsertCounter", m.CdcInsertCounter)
	populate(objectMap, "cdcUpdateCounter", m.CdcUpdateCounter)
	populate(objectMap, "databaseName", m.DatabaseName)
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "fullLoadCompletedTables", m.FullLoadCompletedTables)
	populate(objectMap, "fullLoadErroredTables", m.FullLoadErroredTables)
	populate(objectMap, "fullLoadLoadingTables", m.FullLoadLoadingTables)
	populate(objectMap, "fullLoadQueuedTables", m.FullLoadQueuedTables)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "incomingChanges", m.IncomingChanges)
	populate(objectMap, "initializationCompleted", m.InitializationCompleted)
	populate(objectMap, "latency", m.Latency)
	populate(objectMap, "migrationState", m.MigrationState)
	objectMap["resultType"] = "DatabaseLevelOutput"
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseLevel.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appliedChanges":
			err = unpopulate(val, &m.AppliedChanges)
			delete(rawMsg, key)
		case "cdcDeleteCounter":
			err = unpopulate(val, &m.CdcDeleteCounter)
			delete(rawMsg, key)
		case "cdcInsertCounter":
			err = unpopulate(val, &m.CdcInsertCounter)
			delete(rawMsg, key)
		case "cdcUpdateCounter":
			err = unpopulate(val, &m.CdcUpdateCounter)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "fullLoadCompletedTables":
			err = unpopulate(val, &m.FullLoadCompletedTables)
			delete(rawMsg, key)
		case "fullLoadErroredTables":
			err = unpopulate(val, &m.FullLoadErroredTables)
			delete(rawMsg, key)
		case "fullLoadLoadingTables":
			err = unpopulate(val, &m.FullLoadLoadingTables)
			delete(rawMsg, key)
		case "fullLoadQueuedTables":
			err = unpopulate(val, &m.FullLoadQueuedTables)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "incomingChanges":
			err = unpopulate(val, &m.IncomingChanges)
			delete(rawMsg, key)
		case "initializationCompleted":
			err = unpopulate(val, &m.InitializationCompleted)
			delete(rawMsg, key)
		case "latency":
			err = unpopulate(val, &m.Latency)
			delete(rawMsg, key)
		case "migrationState":
			err = unpopulate(val, &m.MigrationState)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputError struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// List of error events
	Events []*SyncMigrationDatabaseErrorEvent `json:"events,omitempty"`

	// READ-ONLY; Migration error
	Error *ReportableException `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput implements the MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputClassification
// interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputError.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputError) GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput() *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput {
	return &MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputError.
func (m MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", m.Error)
	populate(objectMap, "events", m.Events)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "ErrorOutput"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputError.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &m.Error)
			delete(rawMsg, key)
		case "events":
			err = unpopulate(val, &m.Events)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputMigrationLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// Number of databases to include
	DatabaseCount *float32 `json:"databaseCount,omitempty"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Source server name
	SourceServer *string `json:"sourceServer,omitempty" azure:"ro"`

	// READ-ONLY; Source server type.
	SourceServerType *ScenarioSource `json:"sourceServerType,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Migration status
	State *ReplicateMigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Target server name
	TargetServer *string `json:"targetServer,omitempty" azure:"ro"`

	// READ-ONLY; Target server type.
	TargetServerType *ScenarioTarget `json:"targetServerType,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput implements the MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputClassification
// interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputMigrationLevel.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputMigrationLevel) GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput() *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput {
	return &MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputMigrationLevel.
func (m MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databaseCount", m.DatabaseCount)
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "MigrationLevelOutput"
	populate(objectMap, "sourceServer", m.SourceServer)
	populate(objectMap, "sourceServerType", m.SourceServerType)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "state", m.State)
	populate(objectMap, "targetServer", m.TargetServer)
	populate(objectMap, "targetServerType", m.TargetServerType)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputMigrationLevel.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseCount":
			err = unpopulate(val, &m.DatabaseCount)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "sourceServer":
			err = unpopulate(val, &m.SourceServer)
			delete(rawMsg, key)
		case "sourceServerType":
			err = unpopulate(val, &m.SourceServerType)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "targetServer":
			err = unpopulate(val, &m.TargetServer)
			delete(rawMsg, key)
		case "targetServerType":
			err = unpopulate(val, &m.TargetServerType)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputTableLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Number of applied deletes
	CdcDeleteCounter *int64 `json:"cdcDeleteCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of applied inserts
	CdcInsertCounter *int64 `json:"cdcInsertCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of applied updates
	CdcUpdateCounter *int64 `json:"cdcUpdateCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of data errors occurred
	DataErrorsCounter *int64 `json:"dataErrorsCounter,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Full load end time
	FullLoadEndedOn *time.Time `json:"fullLoadEndedOn,omitempty" azure:"ro"`

	// READ-ONLY; Estimate to finish full load
	FullLoadEstFinishTime *time.Time `json:"fullLoadEstFinishTime,omitempty" azure:"ro"`

	// READ-ONLY; Full load start time
	FullLoadStartedOn *time.Time `json:"fullLoadStartedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of rows applied in full load
	FullLoadTotalRows *int64 `json:"fullLoadTotalRows,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Last modified time on target
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty" azure:"ro"`

	// READ-ONLY; Current state of the table migration
	State *SyncTableMigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Name of the table
	TableName *string `json:"tableName,omitempty" azure:"ro"`

	// READ-ONLY; Total number of applied changes
	TotalChangesApplied *int64 `json:"totalChangesApplied,omitempty" azure:"ro"`
}

// GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput implements the MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputClassification
// interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputTableLevel.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputTableLevel) GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput() *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput {
	return &MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputTableLevel.
func (m MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputTableLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cdcDeleteCounter", m.CdcDeleteCounter)
	populate(objectMap, "cdcInsertCounter", m.CdcInsertCounter)
	populate(objectMap, "cdcUpdateCounter", m.CdcUpdateCounter)
	populate(objectMap, "dataErrorsCounter", m.DataErrorsCounter)
	populate(objectMap, "databaseName", m.DatabaseName)
	populateTimeRFC3339(objectMap, "fullLoadEndedOn", m.FullLoadEndedOn)
	populateTimeRFC3339(objectMap, "fullLoadEstFinishTime", m.FullLoadEstFinishTime)
	populateTimeRFC3339(objectMap, "fullLoadStartedOn", m.FullLoadStartedOn)
	populate(objectMap, "fullLoadTotalRows", m.FullLoadTotalRows)
	populate(objectMap, "id", m.ID)
	populateTimeRFC3339(objectMap, "lastModifiedTime", m.LastModifiedTime)
	objectMap["resultType"] = "TableLevelOutput"
	populate(objectMap, "state", m.State)
	populate(objectMap, "tableName", m.TableName)
	populate(objectMap, "totalChangesApplied", m.TotalChangesApplied)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputTableLevel.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputTableLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cdcDeleteCounter":
			err = unpopulate(val, &m.CdcDeleteCounter)
			delete(rawMsg, key)
		case "cdcInsertCounter":
			err = unpopulate(val, &m.CdcInsertCounter)
			delete(rawMsg, key)
		case "cdcUpdateCounter":
			err = unpopulate(val, &m.CdcUpdateCounter)
			delete(rawMsg, key)
		case "dataErrorsCounter":
			err = unpopulate(val, &m.DataErrorsCounter)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "fullLoadEndedOn":
			err = unpopulateTimeRFC3339(val, &m.FullLoadEndedOn)
			delete(rawMsg, key)
		case "fullLoadEstFinishTime":
			err = unpopulateTimeRFC3339(val, &m.FullLoadEstFinishTime)
			delete(rawMsg, key)
		case "fullLoadStartedOn":
			err = unpopulateTimeRFC3339(val, &m.FullLoadStartedOn)
			delete(rawMsg, key)
		case "fullLoadTotalRows":
			err = unpopulate(val, &m.FullLoadTotalRows)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, &m.LastModifiedTime)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, &m.TableName)
			delete(rawMsg, key)
		case "totalChangesApplied":
			err = unpopulate(val, &m.TotalChangesApplied)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigratePostgreSQLAzureDbForPostgreSQLSyncTaskProperties - Properties for the task that migrates PostgreSQL databases to
// Azure Database for PostgreSQL for online migrations
type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// DateTime in UTC when the task was created
	CreatedOn *string `json:"createdOn,omitempty"`

	// Task input
	Input *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskInput `json:"input,omitempty"`

	// whether the task can be cloned or not
	IsCloneable *bool `json:"isCloneable,omitempty"`

	// task id
	TaskID *string `json:"taskId,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputClassification `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskProperties.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   m.TaskType,
		Errors:     m.Errors,
		State:      m.State,
		Commands:   m.Commands,
		ClientData: m.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskProperties.
func (m MigratePostgreSQLAzureDbForPostgreSQLSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", m.ClientData)
	populate(objectMap, "commands", m.Commands)
	populate(objectMap, "createdOn", m.CreatedOn)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "input", m.Input)
	populate(objectMap, "isCloneable", m.IsCloneable)
	populate(objectMap, "output", m.Output)
	populate(objectMap, "state", m.State)
	populate(objectMap, "taskId", m.TaskID)
	objectMap["taskType"] = TaskTypeMigratePostgreSQLAzureDbForPostgreSQLSyncV2
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskProperties.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &m.ClientData)
			delete(rawMsg, key)
		case "commands":
			m.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulate(val, &m.CreatedOn)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "isCloneable":
			err = unpopulate(val, &m.IsCloneable)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "taskId":
			err = unpopulate(val, &m.TaskID)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &m.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateSQLServerDatabaseInput - Database specific information for SQL to SQL migration task inputs
type MigrateSQLServerDatabaseInput struct {
	// The backup and restore folder
	BackupAndRestoreFolder *string `json:"backupAndRestoreFolder,omitempty"`

	// The list of database files
	DatabaseFiles []*DatabaseFileInput `json:"databaseFiles,omitempty"`

	// Name of the database
	Name *string `json:"name,omitempty"`

	// Name of the database at destination
	RestoreDatabaseName *string `json:"restoreDatabaseName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerDatabaseInput.
func (m MigrateSQLServerDatabaseInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupAndRestoreFolder", m.BackupAndRestoreFolder)
	populate(objectMap, "databaseFiles", m.DatabaseFiles)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "restoreDatabaseName", m.RestoreDatabaseName)
	return json.Marshal(objectMap)
}

// MigrateSQLServerSQLDbDatabaseInput - Database specific information for SQL to Azure SQL DB migration task inputs
type MigrateSQLServerSQLDbDatabaseInput struct {
	// id of the database
	ID *string `json:"id,omitempty"`

	// Whether to set database read only before migration
	MakeSourceDbReadOnly *bool `json:"makeSourceDbReadOnly,omitempty"`

	// Name of the database
	Name *string `json:"name,omitempty"`

	// Settings selected for DB schema migration.
	SchemaSetting map[string]interface{} `json:"schemaSetting,omitempty"`

	// Mapping of source to target tables
	TableMap map[string]*string `json:"tableMap,omitempty"`

	// Name of target database. Note: Target database will be truncated before starting migration.
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbDatabaseInput.
func (m MigrateSQLServerSQLDbDatabaseInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	populate(objectMap, "makeSourceDbReadOnly", m.MakeSourceDbReadOnly)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "schemaSetting", m.SchemaSetting)
	populate(objectMap, "tableMap", m.TableMap)
	populate(objectMap, "targetDatabaseName", m.TargetDatabaseName)
	return json.Marshal(objectMap)
}

// MigrateSQLServerSQLDbSyncDatabaseInput - Database specific information for SQL to Azure SQL DB sync migration task inputs
type MigrateSQLServerSQLDbSyncDatabaseInput struct {
	// Unique identifier for database
	ID *string `json:"id,omitempty"`

	// Migration settings which tune the migration behavior
	MigrationSetting map[string]*string `json:"migrationSetting,omitempty"`

	// Name of database
	Name *string `json:"name,omitempty"`

	// Schema name to be migrated
	SchemaName *string `json:"schemaName,omitempty"`

	// Source settings to tune source endpoint migration behavior
	SourceSetting map[string]*string `json:"sourceSetting,omitempty"`

	// Mapping of source to target tables
	TableMap map[string]*string `json:"tableMap,omitempty"`

	// Target database name
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty"`

	// Target settings to tune target endpoint migration behavior
	TargetSetting map[string]*string `json:"targetSetting,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbSyncDatabaseInput.
func (m MigrateSQLServerSQLDbSyncDatabaseInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	populate(objectMap, "migrationSetting", m.MigrationSetting)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "schemaName", m.SchemaName)
	populate(objectMap, "sourceSetting", m.SourceSetting)
	populate(objectMap, "tableMap", m.TableMap)
	populate(objectMap, "targetDatabaseName", m.TargetDatabaseName)
	populate(objectMap, "targetSetting", m.TargetSetting)
	return json.Marshal(objectMap)
}

// MigrateSQLServerSQLDbSyncTaskInput - Input for the task that migrates on-prem SQL Server databases to Azure SQL Database
// for online migrations
type MigrateSQLServerSQLDbSyncTaskInput struct {
	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateSQLServerSQLDbSyncDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Information for connecting to source
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Information for connecting to target
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// Validation options
	ValidationOptions *MigrationValidationOptions `json:"validationOptions,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbSyncTaskInput.
func (m MigrateSQLServerSQLDbSyncTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "selectedDatabases", m.SelectedDatabases)
	populate(objectMap, "sourceConnectionInfo", m.SourceConnectionInfo)
	populate(objectMap, "targetConnectionInfo", m.TargetConnectionInfo)
	populate(objectMap, "validationOptions", m.ValidationOptions)
	return json.Marshal(objectMap)
}

// MigrateSQLServerSQLDbSyncTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateSQLServerSQLDbSyncTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateSQLServerSQLDbSyncTaskOutput, *MigrateSQLServerSQLDbSyncTaskOutputDatabaseError, *MigrateSQLServerSQLDbSyncTaskOutputDatabaseLevel,
// - *MigrateSQLServerSQLDbSyncTaskOutputError, *MigrateSQLServerSQLDbSyncTaskOutputMigrationLevel, *MigrateSQLServerSQLDbSyncTaskOutputTableLevel
type MigrateSQLServerSQLDbSyncTaskOutputClassification interface {
	// GetMigrateSQLServerSQLDbSyncTaskOutput returns the MigrateSQLServerSQLDbSyncTaskOutput content of the underlying type.
	GetMigrateSQLServerSQLDbSyncTaskOutput() *MigrateSQLServerSQLDbSyncTaskOutput
}

// MigrateSQLServerSQLDbSyncTaskOutput - Output for the task that migrates on-prem SQL Server databases to Azure SQL Database
// for online migrations
type MigrateSQLServerSQLDbSyncTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLDbSyncTaskOutput implements the MigrateSQLServerSQLDbSyncTaskOutputClassification interface for type
// MigrateSQLServerSQLDbSyncTaskOutput.
func (m *MigrateSQLServerSQLDbSyncTaskOutput) GetMigrateSQLServerSQLDbSyncTaskOutput() *MigrateSQLServerSQLDbSyncTaskOutput {
	return m
}

type MigrateSQLServerSQLDbSyncTaskOutputDatabaseError struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// Error message
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// List of error events.
	Events []*SyncMigrationDatabaseErrorEvent `json:"events,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLDbSyncTaskOutput implements the MigrateSQLServerSQLDbSyncTaskOutputClassification interface for type
// MigrateSQLServerSQLDbSyncTaskOutputDatabaseError.
func (m *MigrateSQLServerSQLDbSyncTaskOutputDatabaseError) GetMigrateSQLServerSQLDbSyncTaskOutput() *MigrateSQLServerSQLDbSyncTaskOutput {
	return &MigrateSQLServerSQLDbSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputDatabaseError.
func (m MigrateSQLServerSQLDbSyncTaskOutputDatabaseError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errorMessage", m.ErrorMessage)
	populate(objectMap, "events", m.Events)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "DatabaseLevelErrorOutput"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputDatabaseError.
func (m *MigrateSQLServerSQLDbSyncTaskOutputDatabaseError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorMessage":
			err = unpopulate(val, &m.ErrorMessage)
			delete(rawMsg, key)
		case "events":
			err = unpopulate(val, &m.Events)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLDbSyncTaskOutputDatabaseLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Number of applied changes
	AppliedChanges *int64 `json:"appliedChanges,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc deletes
	CdcDeleteCounter *int64 `json:"cdcDeleteCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc inserts
	CdcInsertCounter *int64 `json:"cdcInsertCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc updates
	CdcUpdateCounter *int64 `json:"cdcUpdateCounter,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables completed in full load
	FullLoadCompletedTables *int64 `json:"fullLoadCompletedTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables errored in full load
	FullLoadErroredTables *int64 `json:"fullLoadErroredTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables loading in full load
	FullLoadLoadingTables *int64 `json:"fullLoadLoadingTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables queued in full load
	FullLoadQueuedTables *int64 `json:"fullLoadQueuedTables,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Number of incoming changes
	IncomingChanges *int64 `json:"incomingChanges,omitempty" azure:"ro"`

	// READ-ONLY; Indicates if initial load (full load) has been completed
	InitializationCompleted *bool `json:"initializationCompleted,omitempty" azure:"ro"`

	// READ-ONLY; CDC apply latency
	Latency *int64 `json:"latency,omitempty" azure:"ro"`

	// READ-ONLY; Migration state that this database is in
	MigrationState *SyncDatabaseMigrationReportingState `json:"migrationState,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLDbSyncTaskOutput implements the MigrateSQLServerSQLDbSyncTaskOutputClassification interface for type
// MigrateSQLServerSQLDbSyncTaskOutputDatabaseLevel.
func (m *MigrateSQLServerSQLDbSyncTaskOutputDatabaseLevel) GetMigrateSQLServerSQLDbSyncTaskOutput() *MigrateSQLServerSQLDbSyncTaskOutput {
	return &MigrateSQLServerSQLDbSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputDatabaseLevel.
func (m MigrateSQLServerSQLDbSyncTaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "appliedChanges", m.AppliedChanges)
	populate(objectMap, "cdcDeleteCounter", m.CdcDeleteCounter)
	populate(objectMap, "cdcInsertCounter", m.CdcInsertCounter)
	populate(objectMap, "cdcUpdateCounter", m.CdcUpdateCounter)
	populate(objectMap, "databaseName", m.DatabaseName)
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "fullLoadCompletedTables", m.FullLoadCompletedTables)
	populate(objectMap, "fullLoadErroredTables", m.FullLoadErroredTables)
	populate(objectMap, "fullLoadLoadingTables", m.FullLoadLoadingTables)
	populate(objectMap, "fullLoadQueuedTables", m.FullLoadQueuedTables)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "incomingChanges", m.IncomingChanges)
	populate(objectMap, "initializationCompleted", m.InitializationCompleted)
	populate(objectMap, "latency", m.Latency)
	populate(objectMap, "migrationState", m.MigrationState)
	objectMap["resultType"] = "DatabaseLevelOutput"
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputDatabaseLevel.
func (m *MigrateSQLServerSQLDbSyncTaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appliedChanges":
			err = unpopulate(val, &m.AppliedChanges)
			delete(rawMsg, key)
		case "cdcDeleteCounter":
			err = unpopulate(val, &m.CdcDeleteCounter)
			delete(rawMsg, key)
		case "cdcInsertCounter":
			err = unpopulate(val, &m.CdcInsertCounter)
			delete(rawMsg, key)
		case "cdcUpdateCounter":
			err = unpopulate(val, &m.CdcUpdateCounter)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "fullLoadCompletedTables":
			err = unpopulate(val, &m.FullLoadCompletedTables)
			delete(rawMsg, key)
		case "fullLoadErroredTables":
			err = unpopulate(val, &m.FullLoadErroredTables)
			delete(rawMsg, key)
		case "fullLoadLoadingTables":
			err = unpopulate(val, &m.FullLoadLoadingTables)
			delete(rawMsg, key)
		case "fullLoadQueuedTables":
			err = unpopulate(val, &m.FullLoadQueuedTables)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "incomingChanges":
			err = unpopulate(val, &m.IncomingChanges)
			delete(rawMsg, key)
		case "initializationCompleted":
			err = unpopulate(val, &m.InitializationCompleted)
			delete(rawMsg, key)
		case "latency":
			err = unpopulate(val, &m.Latency)
			delete(rawMsg, key)
		case "migrationState":
			err = unpopulate(val, &m.MigrationState)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLDbSyncTaskOutputError struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Migration error
	Error *ReportableException `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLDbSyncTaskOutput implements the MigrateSQLServerSQLDbSyncTaskOutputClassification interface for type
// MigrateSQLServerSQLDbSyncTaskOutputError.
func (m *MigrateSQLServerSQLDbSyncTaskOutputError) GetMigrateSQLServerSQLDbSyncTaskOutput() *MigrateSQLServerSQLDbSyncTaskOutput {
	return &MigrateSQLServerSQLDbSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputError.
func (m MigrateSQLServerSQLDbSyncTaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", m.Error)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "ErrorOutput"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputError.
func (m *MigrateSQLServerSQLDbSyncTaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &m.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLDbSyncTaskOutputMigrationLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Count of databases
	DatabaseCount *int32 `json:"databaseCount,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Source server name
	SourceServer *string `json:"sourceServer,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Target server name
	TargetServer *string `json:"targetServer,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLDbSyncTaskOutput implements the MigrateSQLServerSQLDbSyncTaskOutputClassification interface for type
// MigrateSQLServerSQLDbSyncTaskOutputMigrationLevel.
func (m *MigrateSQLServerSQLDbSyncTaskOutputMigrationLevel) GetMigrateSQLServerSQLDbSyncTaskOutput() *MigrateSQLServerSQLDbSyncTaskOutput {
	return &MigrateSQLServerSQLDbSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputMigrationLevel.
func (m MigrateSQLServerSQLDbSyncTaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databaseCount", m.DatabaseCount)
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "MigrationLevelOutput"
	populate(objectMap, "sourceServer", m.SourceServer)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "targetServer", m.TargetServer)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputMigrationLevel.
func (m *MigrateSQLServerSQLDbSyncTaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseCount":
			err = unpopulate(val, &m.DatabaseCount)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "sourceServer":
			err = unpopulate(val, &m.SourceServer)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "targetServer":
			err = unpopulate(val, &m.TargetServer)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLDbSyncTaskOutputTableLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Number of applied deletes
	CdcDeleteCounter *int64 `json:"cdcDeleteCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of applied inserts
	CdcInsertCounter *int64 `json:"cdcInsertCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of applied updates
	CdcUpdateCounter *int64 `json:"cdcUpdateCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of data errors occurred
	DataErrorsCounter *int64 `json:"dataErrorsCounter,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Full load end time
	FullLoadEndedOn *time.Time `json:"fullLoadEndedOn,omitempty" azure:"ro"`

	// READ-ONLY; Estimate to finish full load
	FullLoadEstFinishTime *time.Time `json:"fullLoadEstFinishTime,omitempty" azure:"ro"`

	// READ-ONLY; Full load start time
	FullLoadStartedOn *time.Time `json:"fullLoadStartedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of rows applied in full load
	FullLoadTotalRows *int64 `json:"fullLoadTotalRows,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Last modified time on target
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty" azure:"ro"`

	// READ-ONLY; Current state of the table migration
	State *SyncTableMigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Name of the table
	TableName *string `json:"tableName,omitempty" azure:"ro"`

	// READ-ONLY; Total number of applied changes
	TotalChangesApplied *int64 `json:"totalChangesApplied,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLDbSyncTaskOutput implements the MigrateSQLServerSQLDbSyncTaskOutputClassification interface for type
// MigrateSQLServerSQLDbSyncTaskOutputTableLevel.
func (m *MigrateSQLServerSQLDbSyncTaskOutputTableLevel) GetMigrateSQLServerSQLDbSyncTaskOutput() *MigrateSQLServerSQLDbSyncTaskOutput {
	return &MigrateSQLServerSQLDbSyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputTableLevel.
func (m MigrateSQLServerSQLDbSyncTaskOutputTableLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cdcDeleteCounter", m.CdcDeleteCounter)
	populate(objectMap, "cdcInsertCounter", m.CdcInsertCounter)
	populate(objectMap, "cdcUpdateCounter", m.CdcUpdateCounter)
	populate(objectMap, "dataErrorsCounter", m.DataErrorsCounter)
	populate(objectMap, "databaseName", m.DatabaseName)
	populateTimeRFC3339(objectMap, "fullLoadEndedOn", m.FullLoadEndedOn)
	populateTimeRFC3339(objectMap, "fullLoadEstFinishTime", m.FullLoadEstFinishTime)
	populateTimeRFC3339(objectMap, "fullLoadStartedOn", m.FullLoadStartedOn)
	populate(objectMap, "fullLoadTotalRows", m.FullLoadTotalRows)
	populate(objectMap, "id", m.ID)
	populateTimeRFC3339(objectMap, "lastModifiedTime", m.LastModifiedTime)
	objectMap["resultType"] = "TableLevelOutput"
	populate(objectMap, "state", m.State)
	populate(objectMap, "tableName", m.TableName)
	populate(objectMap, "totalChangesApplied", m.TotalChangesApplied)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputTableLevel.
func (m *MigrateSQLServerSQLDbSyncTaskOutputTableLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cdcDeleteCounter":
			err = unpopulate(val, &m.CdcDeleteCounter)
			delete(rawMsg, key)
		case "cdcInsertCounter":
			err = unpopulate(val, &m.CdcInsertCounter)
			delete(rawMsg, key)
		case "cdcUpdateCounter":
			err = unpopulate(val, &m.CdcUpdateCounter)
			delete(rawMsg, key)
		case "dataErrorsCounter":
			err = unpopulate(val, &m.DataErrorsCounter)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "fullLoadEndedOn":
			err = unpopulateTimeRFC3339(val, &m.FullLoadEndedOn)
			delete(rawMsg, key)
		case "fullLoadEstFinishTime":
			err = unpopulateTimeRFC3339(val, &m.FullLoadEstFinishTime)
			delete(rawMsg, key)
		case "fullLoadStartedOn":
			err = unpopulateTimeRFC3339(val, &m.FullLoadStartedOn)
			delete(rawMsg, key)
		case "fullLoadTotalRows":
			err = unpopulate(val, &m.FullLoadTotalRows)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, &m.LastModifiedTime)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, &m.TableName)
			delete(rawMsg, key)
		case "totalChangesApplied":
			err = unpopulate(val, &m.TotalChangesApplied)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateSQLServerSQLDbSyncTaskProperties - Properties for the task that migrates on-prem SQL Server databases to Azure SQL
// Database for online migrations
type MigrateSQLServerSQLDbSyncTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *MigrateSQLServerSQLDbSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateSQLServerSQLDbSyncTaskOutputClassification `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type MigrateSQLServerSQLDbSyncTaskProperties.
func (m *MigrateSQLServerSQLDbSyncTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   m.TaskType,
		Errors:     m.Errors,
		State:      m.State,
		Commands:   m.Commands,
		ClientData: m.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbSyncTaskProperties.
func (m MigrateSQLServerSQLDbSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", m.ClientData)
	populate(objectMap, "commands", m.Commands)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	populate(objectMap, "state", m.State)
	objectMap["taskType"] = TaskTypeMigrateSQLServerAzureSQLDbSync
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbSyncTaskProperties.
func (m *MigrateSQLServerSQLDbSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &m.ClientData)
			delete(rawMsg, key)
		case "commands":
			m.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateSQLServerSQLDbSyncTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &m.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateSQLServerSQLDbTaskInput - Input for the task that migrates on-prem SQL Server databases to Azure SQL Database
type MigrateSQLServerSQLDbTaskInput struct {
	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateSQLServerSQLDbDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Information for connecting to source
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Information for connecting to target
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// encrypted key for secure fields
	EncryptedKeyForSecureFields *string `json:"encryptedKeyForSecureFields,omitempty"`

	// Date and time relative to UTC when the migration was started on
	StartedOn *string `json:"startedOn,omitempty"`

	// Options for enabling various post migration validations. Available options, 1.) Data Integrity Check: Performs a checksum
	// based comparison on source and target tables after the migration to ensure the
	// correctness of the data. 2.) Schema Validation: Performs a thorough schema comparison between the source and target tables
	// and provides a list of differences between the source and target database,
	// 3.) Query Analysis: Executes a set of queries picked up automatically either from the Query Plan Cache or Query Store and
	// execute them and compares the execution time between the source and target
	// database.
	ValidationOptions *MigrationValidationOptions `json:"validationOptions,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbTaskInput.
func (m MigrateSQLServerSQLDbTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptedKeyForSecureFields", m.EncryptedKeyForSecureFields)
	populate(objectMap, "selectedDatabases", m.SelectedDatabases)
	populate(objectMap, "sourceConnectionInfo", m.SourceConnectionInfo)
	populate(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "targetConnectionInfo", m.TargetConnectionInfo)
	populate(objectMap, "validationOptions", m.ValidationOptions)
	return json.Marshal(objectMap)
}

// MigrateSQLServerSQLDbTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateSQLServerSQLDbTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateSQLServerSQLDbTaskOutput, *MigrateSQLServerSQLDbTaskOutputDatabaseLevel, *MigrateSQLServerSQLDbTaskOutputDatabaseLevelValidationResult,
// - *MigrateSQLServerSQLDbTaskOutputError, *MigrateSQLServerSQLDbTaskOutputMigrationLevel, *MigrateSQLServerSQLDbTaskOutputTableLevel,
// - *MigrateSQLServerSQLDbTaskOutputValidationResult
type MigrateSQLServerSQLDbTaskOutputClassification interface {
	// GetMigrateSQLServerSQLDbTaskOutput returns the MigrateSQLServerSQLDbTaskOutput content of the underlying type.
	GetMigrateSQLServerSQLDbTaskOutput() *MigrateSQLServerSQLDbTaskOutput
}

// MigrateSQLServerSQLDbTaskOutput - Output for the task that migrates on-prem SQL Server databases to Azure SQL Database
type MigrateSQLServerSQLDbTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLDbTaskOutput implements the MigrateSQLServerSQLDbTaskOutputClassification interface for type MigrateSQLServerSQLDbTaskOutput.
func (m *MigrateSQLServerSQLDbTaskOutput) GetMigrateSQLServerSQLDbTaskOutput() *MigrateSQLServerSQLDbTaskOutput {
	return m
}

type MigrateSQLServerSQLDbTaskOutputDatabaseLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Name of the item
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of database/object errors.
	ErrorCount *int64 `json:"errorCount,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all errors of the item
	ErrorPrefix *string `json:"errorPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Migration exceptions and warnings.
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Number of objects
	NumberOfObjects *int64 `json:"numberOfObjects,omitempty" azure:"ro"`

	// READ-ONLY; Number of successfully completed objects
	NumberOfObjectsCompleted *int64 `json:"numberOfObjectsCompleted,omitempty" azure:"ro"`

	// READ-ONLY; Summary of object results in the migration
	ObjectSummary *string `json:"objectSummary,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all sub-tem results of the item
	ResultPrefix *string `json:"resultPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Migration stage that this database is in
	Stage *DatabaseMigrationStage `json:"stage,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Status message
	StatusMessage *string `json:"statusMessage,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLDbTaskOutput implements the MigrateSQLServerSQLDbTaskOutputClassification interface for type MigrateSQLServerSQLDbTaskOutputDatabaseLevel.
func (m *MigrateSQLServerSQLDbTaskOutputDatabaseLevel) GetMigrateSQLServerSQLDbTaskOutput() *MigrateSQLServerSQLDbTaskOutput {
	return &MigrateSQLServerSQLDbTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbTaskOutputDatabaseLevel.
func (m MigrateSQLServerSQLDbTaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databaseName", m.DatabaseName)
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "errorCount", m.ErrorCount)
	populate(objectMap, "errorPrefix", m.ErrorPrefix)
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "numberOfObjects", m.NumberOfObjects)
	populate(objectMap, "numberOfObjectsCompleted", m.NumberOfObjectsCompleted)
	populate(objectMap, "objectSummary", m.ObjectSummary)
	populate(objectMap, "resultPrefix", m.ResultPrefix)
	objectMap["resultType"] = "DatabaseLevelOutput"
	populate(objectMap, "stage", m.Stage)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "state", m.State)
	populate(objectMap, "statusMessage", m.StatusMessage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbTaskOutputDatabaseLevel.
func (m *MigrateSQLServerSQLDbTaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "errorCount":
			err = unpopulate(val, &m.ErrorCount)
			delete(rawMsg, key)
		case "errorPrefix":
			err = unpopulate(val, &m.ErrorPrefix)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "numberOfObjects":
			err = unpopulate(val, &m.NumberOfObjects)
			delete(rawMsg, key)
		case "numberOfObjectsCompleted":
			err = unpopulate(val, &m.NumberOfObjectsCompleted)
			delete(rawMsg, key)
		case "objectSummary":
			err = unpopulate(val, &m.ObjectSummary)
			delete(rawMsg, key)
		case "resultPrefix":
			err = unpopulate(val, &m.ResultPrefix)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "stage":
			err = unpopulate(val, &m.Stage)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "statusMessage":
			err = unpopulate(val, &m.StatusMessage)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLDbTaskOutputDatabaseLevelValidationResult struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Provides data integrity validation result between the source and target tables that are migrated.
	DataIntegrityValidationResult *DataIntegrityValidationResult `json:"dataIntegrityValidationResult,omitempty" azure:"ro"`

	// READ-ONLY; Validation end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Migration Identifier
	MigrationID *string `json:"migrationId,omitempty" azure:"ro"`

	// READ-ONLY; Results of some of the query execution result between source and target database
	QueryAnalysisValidationResult *QueryAnalysisValidationResult `json:"queryAnalysisValidationResult,omitempty" azure:"ro"`

	// READ-ONLY; Provides schema comparison result between source and target database
	SchemaValidationResult *SchemaComparisonValidationResult `json:"schemaValidationResult,omitempty" azure:"ro"`

	// READ-ONLY; Name of the source database
	SourceDatabaseName *string `json:"sourceDatabaseName,omitempty" azure:"ro"`

	// READ-ONLY; Validation start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current status of validation at the database level
	Status *ValidationStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Name of the target database
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLDbTaskOutput implements the MigrateSQLServerSQLDbTaskOutputClassification interface for type MigrateSQLServerSQLDbTaskOutputDatabaseLevelValidationResult.
func (m *MigrateSQLServerSQLDbTaskOutputDatabaseLevelValidationResult) GetMigrateSQLServerSQLDbTaskOutput() *MigrateSQLServerSQLDbTaskOutput {
	return &MigrateSQLServerSQLDbTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbTaskOutputDatabaseLevelValidationResult.
func (m MigrateSQLServerSQLDbTaskOutputDatabaseLevelValidationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataIntegrityValidationResult", m.DataIntegrityValidationResult)
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "migrationId", m.MigrationID)
	populate(objectMap, "queryAnalysisValidationResult", m.QueryAnalysisValidationResult)
	objectMap["resultType"] = "MigrationDatabaseLevelValidationOutput"
	populate(objectMap, "schemaValidationResult", m.SchemaValidationResult)
	populate(objectMap, "sourceDatabaseName", m.SourceDatabaseName)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "status", m.Status)
	populate(objectMap, "targetDatabaseName", m.TargetDatabaseName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbTaskOutputDatabaseLevelValidationResult.
func (m *MigrateSQLServerSQLDbTaskOutputDatabaseLevelValidationResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataIntegrityValidationResult":
			err = unpopulate(val, &m.DataIntegrityValidationResult)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "migrationId":
			err = unpopulate(val, &m.MigrationID)
			delete(rawMsg, key)
		case "queryAnalysisValidationResult":
			err = unpopulate(val, &m.QueryAnalysisValidationResult)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "schemaValidationResult":
			err = unpopulate(val, &m.SchemaValidationResult)
			delete(rawMsg, key)
		case "sourceDatabaseName":
			err = unpopulate(val, &m.SourceDatabaseName)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		case "targetDatabaseName":
			err = unpopulate(val, &m.TargetDatabaseName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLDbTaskOutputError struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Migration error
	Error *ReportableException `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLDbTaskOutput implements the MigrateSQLServerSQLDbTaskOutputClassification interface for type MigrateSQLServerSQLDbTaskOutputError.
func (m *MigrateSQLServerSQLDbTaskOutputError) GetMigrateSQLServerSQLDbTaskOutput() *MigrateSQLServerSQLDbTaskOutput {
	return &MigrateSQLServerSQLDbTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbTaskOutputError.
func (m MigrateSQLServerSQLDbTaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", m.Error)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "ErrorOutput"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbTaskOutputError.
func (m *MigrateSQLServerSQLDbTaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &m.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLDbTaskOutputMigrationLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// Migration Report Result, provides unique url for downloading your migration report.
	MigrationReportResult *MigrationReportResult `json:"migrationReportResult,omitempty"`

	// Migration Validation Results
	MigrationValidationResult *MigrationValidationResult `json:"migrationValidationResult,omitempty"`

	// READ-ONLY; Summary of database results in the migration
	DatabaseSummary *string `json:"databaseSummary,omitempty" azure:"ro"`

	// READ-ONLY; Selected databases as a map from database name to database id
	Databases *string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Duration of task execution in seconds.
	DurationInSeconds *int64 `json:"durationInSeconds,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Migration exceptions and warnings.
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Source server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current status of migration
	Status *MigrationStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Migration status message
	StatusMessage *string `json:"statusMessage,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLDbTaskOutput implements the MigrateSQLServerSQLDbTaskOutputClassification interface for type MigrateSQLServerSQLDbTaskOutputMigrationLevel.
func (m *MigrateSQLServerSQLDbTaskOutputMigrationLevel) GetMigrateSQLServerSQLDbTaskOutput() *MigrateSQLServerSQLDbTaskOutput {
	return &MigrateSQLServerSQLDbTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbTaskOutputMigrationLevel.
func (m MigrateSQLServerSQLDbTaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databaseSummary", m.DatabaseSummary)
	populate(objectMap, "databases", m.Databases)
	populate(objectMap, "durationInSeconds", m.DurationInSeconds)
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "migrationReportResult", m.MigrationReportResult)
	populate(objectMap, "migrationValidationResult", m.MigrationValidationResult)
	objectMap["resultType"] = "MigrationLevelOutput"
	populate(objectMap, "sourceServerBrandVersion", m.SourceServerBrandVersion)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "status", m.Status)
	populate(objectMap, "statusMessage", m.StatusMessage)
	populate(objectMap, "targetServerBrandVersion", m.TargetServerBrandVersion)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbTaskOutputMigrationLevel.
func (m *MigrateSQLServerSQLDbTaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseSummary":
			err = unpopulate(val, &m.DatabaseSummary)
			delete(rawMsg, key)
		case "databases":
			err = unpopulate(val, &m.Databases)
			delete(rawMsg, key)
		case "durationInSeconds":
			err = unpopulate(val, &m.DurationInSeconds)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "migrationReportResult":
			err = unpopulate(val, &m.MigrationReportResult)
			delete(rawMsg, key)
		case "migrationValidationResult":
			err = unpopulate(val, &m.MigrationValidationResult)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "sourceServerBrandVersion":
			err = unpopulate(val, &m.SourceServerBrandVersion)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		case "statusMessage":
			err = unpopulate(val, &m.StatusMessage)
			delete(rawMsg, key)
		case "targetServerBrandVersion":
			err = unpopulate(val, &m.TargetServerBrandVersion)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLDbTaskOutputTableLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all errors of the item
	ErrorPrefix *string `json:"errorPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Number of successfully completed items
	ItemsCompletedCount *int64 `json:"itemsCompletedCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of items
	ItemsCount *int64 `json:"itemsCount,omitempty" azure:"ro"`

	// READ-ONLY; Name of the item
	ObjectName *string `json:"objectName,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all sub-tem results of the item
	ResultPrefix *string `json:"resultPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Status message
	StatusMessage *string `json:"statusMessage,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLDbTaskOutput implements the MigrateSQLServerSQLDbTaskOutputClassification interface for type MigrateSQLServerSQLDbTaskOutputTableLevel.
func (m *MigrateSQLServerSQLDbTaskOutputTableLevel) GetMigrateSQLServerSQLDbTaskOutput() *MigrateSQLServerSQLDbTaskOutput {
	return &MigrateSQLServerSQLDbTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbTaskOutputTableLevel.
func (m MigrateSQLServerSQLDbTaskOutputTableLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "errorPrefix", m.ErrorPrefix)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "itemsCompletedCount", m.ItemsCompletedCount)
	populate(objectMap, "itemsCount", m.ItemsCount)
	populate(objectMap, "objectName", m.ObjectName)
	populate(objectMap, "resultPrefix", m.ResultPrefix)
	objectMap["resultType"] = "TableLevelOutput"
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "state", m.State)
	populate(objectMap, "statusMessage", m.StatusMessage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbTaskOutputTableLevel.
func (m *MigrateSQLServerSQLDbTaskOutputTableLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "errorPrefix":
			err = unpopulate(val, &m.ErrorPrefix)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "itemsCompletedCount":
			err = unpopulate(val, &m.ItemsCompletedCount)
			delete(rawMsg, key)
		case "itemsCount":
			err = unpopulate(val, &m.ItemsCount)
			delete(rawMsg, key)
		case "objectName":
			err = unpopulate(val, &m.ObjectName)
			delete(rawMsg, key)
		case "resultPrefix":
			err = unpopulate(val, &m.ResultPrefix)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "statusMessage":
			err = unpopulate(val, &m.StatusMessage)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLDbTaskOutputValidationResult struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// Validation summary results for each database
	SummaryResults map[string]*MigrationValidationDatabaseSummaryResult `json:"summaryResults,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Migration Identifier
	MigrationID *string `json:"migrationId,omitempty" azure:"ro"`

	// READ-ONLY; Current status of validation at the migration level. Status from the database validation result status will
	// be aggregated here.
	Status *ValidationStatus `json:"status,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLDbTaskOutput implements the MigrateSQLServerSQLDbTaskOutputClassification interface for type MigrateSQLServerSQLDbTaskOutputValidationResult.
func (m *MigrateSQLServerSQLDbTaskOutputValidationResult) GetMigrateSQLServerSQLDbTaskOutput() *MigrateSQLServerSQLDbTaskOutput {
	return &MigrateSQLServerSQLDbTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbTaskOutputValidationResult.
func (m MigrateSQLServerSQLDbTaskOutputValidationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	populate(objectMap, "migrationId", m.MigrationID)
	objectMap["resultType"] = "MigrationValidationOutput"
	populate(objectMap, "status", m.Status)
	populate(objectMap, "summaryResults", m.SummaryResults)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbTaskOutputValidationResult.
func (m *MigrateSQLServerSQLDbTaskOutputValidationResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "migrationId":
			err = unpopulate(val, &m.MigrationID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		case "summaryResults":
			err = unpopulate(val, &m.SummaryResults)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateSQLServerSQLDbTaskProperties - Properties for the task that migrates on-prem SQL Server databases to Azure SQL Database
type MigrateSQLServerSQLDbTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// DateTime in UTC when the task was created
	CreatedOn *string `json:"createdOn,omitempty"`

	// Task input
	Input *MigrateSQLServerSQLDbTaskInput `json:"input,omitempty"`

	// whether the task can be cloned or not
	IsCloneable *bool `json:"isCloneable,omitempty"`

	// task id
	TaskID *string `json:"taskId,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateSQLServerSQLDbTaskOutputClassification `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type MigrateSQLServerSQLDbTaskProperties.
func (m *MigrateSQLServerSQLDbTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   m.TaskType,
		Errors:     m.Errors,
		State:      m.State,
		Commands:   m.Commands,
		ClientData: m.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbTaskProperties.
func (m MigrateSQLServerSQLDbTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", m.ClientData)
	populate(objectMap, "commands", m.Commands)
	populate(objectMap, "createdOn", m.CreatedOn)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "input", m.Input)
	populate(objectMap, "isCloneable", m.IsCloneable)
	populate(objectMap, "output", m.Output)
	populate(objectMap, "state", m.State)
	populate(objectMap, "taskId", m.TaskID)
	objectMap["taskType"] = TaskTypeMigrateSQLServerSQLDb
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbTaskProperties.
func (m *MigrateSQLServerSQLDbTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &m.ClientData)
			delete(rawMsg, key)
		case "commands":
			m.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulate(val, &m.CreatedOn)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "isCloneable":
			err = unpopulate(val, &m.IsCloneable)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateSQLServerSQLDbTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "taskId":
			err = unpopulate(val, &m.TaskID)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &m.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateSQLServerSQLMIDatabaseInput - Database specific information for SQL to Azure SQL DB Managed Instance migration task
// inputs
type MigrateSQLServerSQLMIDatabaseInput struct {
	// REQUIRED; Name of the database
	Name *string `json:"name,omitempty"`

	// REQUIRED; Name of the database at destination
	RestoreDatabaseName *string `json:"restoreDatabaseName,omitempty"`

	// The list of backup files to be used in case of existing backups.
	BackupFilePaths []*string `json:"backupFilePaths,omitempty"`

	// Backup file share information for backing up this database.
	BackupFileShare *FileShare `json:"backupFileShare,omitempty"`

	// id of the database
	ID *string `json:"id,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMIDatabaseInput.
func (m MigrateSQLServerSQLMIDatabaseInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupFilePaths", m.BackupFilePaths)
	populate(objectMap, "backupFileShare", m.BackupFileShare)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "restoreDatabaseName", m.RestoreDatabaseName)
	return json.Marshal(objectMap)
}

// MigrateSQLServerSQLMISyncTaskInput - Input for task that migrates SQL Server databases to Azure SQL Database Managed Instance
// online scenario.
type MigrateSQLServerSQLMISyncTaskInput struct {
	// REQUIRED; Azure Active Directory Application the DMS instance will use to connect to the target instance of Azure SQL Database
	// Managed Instance and the Azure Storage Account
	AzureApp *AzureActiveDirectoryApp `json:"azureApp,omitempty"`

	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateSQLServerSQLMIDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Connection information for source SQL Server
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Fully qualified resourceId of storage
	StorageResourceID *string `json:"storageResourceId,omitempty"`

	// REQUIRED; Connection information for Azure SQL Database Managed Instance
	TargetConnectionInfo *MiSQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// Backup file share information for all selected databases.
	BackupFileShare *FileShare `json:"backupFileShare,omitempty"`

	// Number of database migrations to start in parallel
	NumberOfParallelDatabaseMigrations *float32 `json:"numberOfParallelDatabaseMigrations,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMISyncTaskInput.
func (m MigrateSQLServerSQLMISyncTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureApp", m.AzureApp)
	populate(objectMap, "backupFileShare", m.BackupFileShare)
	populate(objectMap, "numberOfParallelDatabaseMigrations", m.NumberOfParallelDatabaseMigrations)
	populate(objectMap, "selectedDatabases", m.SelectedDatabases)
	populate(objectMap, "sourceConnectionInfo", m.SourceConnectionInfo)
	populate(objectMap, "storageResourceId", m.StorageResourceID)
	populate(objectMap, "targetConnectionInfo", m.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// MigrateSQLServerSQLMISyncTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateSQLServerSQLMISyncTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateSQLServerSQLMISyncTaskOutput, *MigrateSQLServerSQLMISyncTaskOutputDatabaseLevel, *MigrateSQLServerSQLMISyncTaskOutputError,
// - *MigrateSQLServerSQLMISyncTaskOutputMigrationLevel
type MigrateSQLServerSQLMISyncTaskOutputClassification interface {
	// GetMigrateSQLServerSQLMISyncTaskOutput returns the MigrateSQLServerSQLMISyncTaskOutput content of the underlying type.
	GetMigrateSQLServerSQLMISyncTaskOutput() *MigrateSQLServerSQLMISyncTaskOutput
}

// MigrateSQLServerSQLMISyncTaskOutput - Output for task that migrates SQL Server databases to Azure SQL Database Managed
// Instance using Log Replay Service.
type MigrateSQLServerSQLMISyncTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLMISyncTaskOutput implements the MigrateSQLServerSQLMISyncTaskOutputClassification interface for type
// MigrateSQLServerSQLMISyncTaskOutput.
func (m *MigrateSQLServerSQLMISyncTaskOutput) GetMigrateSQLServerSQLMISyncTaskOutput() *MigrateSQLServerSQLMISyncTaskOutput {
	return m
}

type MigrateSQLServerSQLMISyncTaskOutputDatabaseLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Backup sets that are currently active (Either being uploaded or getting restored)
	ActiveBackupSets []*BackupSetInfo `json:"activeBackupSets,omitempty" azure:"ro"`

	// READ-ONLY; Name of container created in the Azure Storage account where backups are copied to
	ContainerName *string `json:"containerName,omitempty" azure:"ro"`

	// READ-ONLY; Database migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; prefix string to use for querying errors for this database
	ErrorPrefix *string `json:"errorPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Migration exceptions and warnings
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Details of full backup set
	FullBackupSetInfo *BackupSetInfo `json:"fullBackupSetInfo,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Whether full backup has been applied to the target database or not
	IsFullBackupRestored *bool `json:"isFullBackupRestored,omitempty" azure:"ro"`

	// READ-ONLY; Last applied backup set information
	LastRestoredBackupSetInfo *BackupSetInfo `json:"lastRestoredBackupSetInfo,omitempty" azure:"ro"`

	// READ-ONLY; Current state of database
	MigrationState *DatabaseMigrationState `json:"migrationState,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	SourceDatabaseName *string `json:"sourceDatabaseName,omitempty" azure:"ro"`

	// READ-ONLY; Database migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLMISyncTaskOutput implements the MigrateSQLServerSQLMISyncTaskOutputClassification interface for type
// MigrateSQLServerSQLMISyncTaskOutputDatabaseLevel.
func (m *MigrateSQLServerSQLMISyncTaskOutputDatabaseLevel) GetMigrateSQLServerSQLMISyncTaskOutput() *MigrateSQLServerSQLMISyncTaskOutput {
	return &MigrateSQLServerSQLMISyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMISyncTaskOutputDatabaseLevel.
func (m MigrateSQLServerSQLMISyncTaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activeBackupSets", m.ActiveBackupSets)
	populate(objectMap, "containerName", m.ContainerName)
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "errorPrefix", m.ErrorPrefix)
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "fullBackupSetInfo", m.FullBackupSetInfo)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "isFullBackupRestored", m.IsFullBackupRestored)
	populate(objectMap, "lastRestoredBackupSetInfo", m.LastRestoredBackupSetInfo)
	populate(objectMap, "migrationState", m.MigrationState)
	objectMap["resultType"] = "DatabaseLevelOutput"
	populate(objectMap, "sourceDatabaseName", m.SourceDatabaseName)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMISyncTaskOutputDatabaseLevel.
func (m *MigrateSQLServerSQLMISyncTaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activeBackupSets":
			err = unpopulate(val, &m.ActiveBackupSets)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, &m.ContainerName)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "errorPrefix":
			err = unpopulate(val, &m.ErrorPrefix)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "fullBackupSetInfo":
			err = unpopulate(val, &m.FullBackupSetInfo)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "isFullBackupRestored":
			err = unpopulate(val, &m.IsFullBackupRestored)
			delete(rawMsg, key)
		case "lastRestoredBackupSetInfo":
			err = unpopulate(val, &m.LastRestoredBackupSetInfo)
			delete(rawMsg, key)
		case "migrationState":
			err = unpopulate(val, &m.MigrationState)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "sourceDatabaseName":
			err = unpopulate(val, &m.SourceDatabaseName)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLMISyncTaskOutputError struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Migration error
	Error *ReportableException `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLMISyncTaskOutput implements the MigrateSQLServerSQLMISyncTaskOutputClassification interface for type
// MigrateSQLServerSQLMISyncTaskOutputError.
func (m *MigrateSQLServerSQLMISyncTaskOutputError) GetMigrateSQLServerSQLMISyncTaskOutput() *MigrateSQLServerSQLMISyncTaskOutput {
	return &MigrateSQLServerSQLMISyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMISyncTaskOutputError.
func (m MigrateSQLServerSQLMISyncTaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", m.Error)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "ErrorOutput"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMISyncTaskOutputError.
func (m *MigrateSQLServerSQLMISyncTaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &m.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLMISyncTaskOutputMigrationLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Count of databases
	DatabaseCount *int32 `json:"databaseCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of database level errors
	DatabaseErrorCount *int32 `json:"databaseErrorCount,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Source server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Source server name
	SourceServerName *string `json:"sourceServerName,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Target server name
	TargetServerName *string `json:"targetServerName,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLMISyncTaskOutput implements the MigrateSQLServerSQLMISyncTaskOutputClassification interface for type
// MigrateSQLServerSQLMISyncTaskOutputMigrationLevel.
func (m *MigrateSQLServerSQLMISyncTaskOutputMigrationLevel) GetMigrateSQLServerSQLMISyncTaskOutput() *MigrateSQLServerSQLMISyncTaskOutput {
	return &MigrateSQLServerSQLMISyncTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMISyncTaskOutputMigrationLevel.
func (m MigrateSQLServerSQLMISyncTaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databaseCount", m.DatabaseCount)
	populate(objectMap, "databaseErrorCount", m.DatabaseErrorCount)
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "MigrationLevelOutput"
	populate(objectMap, "sourceServerBrandVersion", m.SourceServerBrandVersion)
	populate(objectMap, "sourceServerName", m.SourceServerName)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "state", m.State)
	populate(objectMap, "targetServerBrandVersion", m.TargetServerBrandVersion)
	populate(objectMap, "targetServerName", m.TargetServerName)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMISyncTaskOutputMigrationLevel.
func (m *MigrateSQLServerSQLMISyncTaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseCount":
			err = unpopulate(val, &m.DatabaseCount)
			delete(rawMsg, key)
		case "databaseErrorCount":
			err = unpopulate(val, &m.DatabaseErrorCount)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "sourceServerBrandVersion":
			err = unpopulate(val, &m.SourceServerBrandVersion)
			delete(rawMsg, key)
		case "sourceServerName":
			err = unpopulate(val, &m.SourceServerName)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "targetServerBrandVersion":
			err = unpopulate(val, &m.TargetServerBrandVersion)
			delete(rawMsg, key)
		case "targetServerName":
			err = unpopulate(val, &m.TargetServerName)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateSQLServerSQLMISyncTaskProperties - Properties for task that migrates SQL Server databases to Azure SQL Database
// Managed Instance sync scenario
type MigrateSQLServerSQLMISyncTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// DateTime in UTC when the task was created
	CreatedOn *string `json:"createdOn,omitempty"`

	// Task input
	Input *MigrateSQLServerSQLMISyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateSQLServerSQLMISyncTaskOutputClassification `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type MigrateSQLServerSQLMISyncTaskProperties.
func (m *MigrateSQLServerSQLMISyncTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   m.TaskType,
		Errors:     m.Errors,
		State:      m.State,
		Commands:   m.Commands,
		ClientData: m.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMISyncTaskProperties.
func (m MigrateSQLServerSQLMISyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", m.ClientData)
	populate(objectMap, "commands", m.Commands)
	populate(objectMap, "createdOn", m.CreatedOn)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	populate(objectMap, "state", m.State)
	objectMap["taskType"] = TaskTypeMigrateSQLServerAzureSQLDbMISyncLRS
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMISyncTaskProperties.
func (m *MigrateSQLServerSQLMISyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &m.ClientData)
			delete(rawMsg, key)
		case "commands":
			m.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulate(val, &m.CreatedOn)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateSQLServerSQLMISyncTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &m.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateSQLServerSQLMITaskInput - Input for task that migrates SQL Server databases to Azure SQL Database Managed Instance.
type MigrateSQLServerSQLMITaskInput struct {
	// REQUIRED; SAS URI of Azure Storage Account Container to be used for storing backup files.
	BackupBlobShare *BlobShare `json:"backupBlobShare,omitempty"`

	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateSQLServerSQLMIDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Information for connecting to source
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Information for connecting to target
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// Azure Active Directory domain name in the format of 'contoso.com' for federated Azure AD or 'contoso.onmicrosoft.com' for
	// managed domain, required if and only if Windows logins are selected
	AADDomainName *string `json:"aadDomainName,omitempty"`

	// Backup file share information for all selected databases.
	BackupFileShare *FileShare `json:"backupFileShare,omitempty"`

	// Backup Mode to specify whether to use existing backup or create new backup. If using existing backups, backup file paths
	// are required to be provided in selectedDatabases.
	BackupMode *BackupMode `json:"backupMode,omitempty"`

	// encrypted key for secure fields
	EncryptedKeyForSecureFields *string `json:"encryptedKeyForSecureFields,omitempty"`

	// Agent Jobs to migrate.
	SelectedAgentJobs []*string `json:"selectedAgentJobs,omitempty"`

	// Logins to migrate.
	SelectedLogins []*string `json:"selectedLogins,omitempty"`

	// Date and time relative to UTC when the migration was started on
	StartedOn *string `json:"startedOn,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMITaskInput.
func (m MigrateSQLServerSQLMITaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "aadDomainName", m.AADDomainName)
	populate(objectMap, "backupBlobShare", m.BackupBlobShare)
	populate(objectMap, "backupFileShare", m.BackupFileShare)
	populate(objectMap, "backupMode", m.BackupMode)
	populate(objectMap, "encryptedKeyForSecureFields", m.EncryptedKeyForSecureFields)
	populate(objectMap, "selectedAgentJobs", m.SelectedAgentJobs)
	populate(objectMap, "selectedDatabases", m.SelectedDatabases)
	populate(objectMap, "selectedLogins", m.SelectedLogins)
	populate(objectMap, "sourceConnectionInfo", m.SourceConnectionInfo)
	populate(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "targetConnectionInfo", m.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// MigrateSQLServerSQLMITaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateSQLServerSQLMITaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateSQLServerSQLMITaskOutput, *MigrateSQLServerSQLMITaskOutputAgentJobLevel, *MigrateSQLServerSQLMITaskOutputDatabaseLevel,
// - *MigrateSQLServerSQLMITaskOutputError, *MigrateSQLServerSQLMITaskOutputLoginLevel, *MigrateSQLServerSQLMITaskOutputMigrationLevel
type MigrateSQLServerSQLMITaskOutputClassification interface {
	// GetMigrateSQLServerSQLMITaskOutput returns the MigrateSQLServerSQLMITaskOutput content of the underlying type.
	GetMigrateSQLServerSQLMITaskOutput() *MigrateSQLServerSQLMITaskOutput
}

// MigrateSQLServerSQLMITaskOutput - Output for task that migrates SQL Server databases to Azure SQL Database Managed Instance.
type MigrateSQLServerSQLMITaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLMITaskOutput implements the MigrateSQLServerSQLMITaskOutputClassification interface for type MigrateSQLServerSQLMITaskOutput.
func (m *MigrateSQLServerSQLMITaskOutput) GetMigrateSQLServerSQLMITaskOutput() *MigrateSQLServerSQLMITaskOutput {
	return m
}

type MigrateSQLServerSQLMITaskOutputAgentJobLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Migration errors and warnings per job
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The state of the original Agent Job.
	IsEnabled *bool `json:"isEnabled,omitempty" azure:"ro"`

	// READ-ONLY; Migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Agent Job name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLMITaskOutput implements the MigrateSQLServerSQLMITaskOutputClassification interface for type MigrateSQLServerSQLMITaskOutputAgentJobLevel.
func (m *MigrateSQLServerSQLMITaskOutputAgentJobLevel) GetMigrateSQLServerSQLMITaskOutput() *MigrateSQLServerSQLMITaskOutput {
	return &MigrateSQLServerSQLMITaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMITaskOutputAgentJobLevel.
func (m MigrateSQLServerSQLMITaskOutputAgentJobLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "isEnabled", m.IsEnabled)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "name", m.Name)
	objectMap["resultType"] = "AgentJobLevelOutput"
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "state", m.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMITaskOutputAgentJobLevel.
func (m *MigrateSQLServerSQLMITaskOutputAgentJobLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, &m.IsEnabled)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLMITaskOutputDatabaseLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Migration exceptions and warnings
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Size of the database in megabytes
	SizeMB *float64 `json:"sizeMB,omitempty" azure:"ro"`

	// READ-ONLY; Current stage of migration
	Stage *DatabaseMigrationStage `json:"stage,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLMITaskOutput implements the MigrateSQLServerSQLMITaskOutputClassification interface for type MigrateSQLServerSQLMITaskOutputDatabaseLevel.
func (m *MigrateSQLServerSQLMITaskOutputDatabaseLevel) GetMigrateSQLServerSQLMITaskOutput() *MigrateSQLServerSQLMITaskOutput {
	return &MigrateSQLServerSQLMITaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMITaskOutputDatabaseLevel.
func (m MigrateSQLServerSQLMITaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databaseName", m.DatabaseName)
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "message", m.Message)
	objectMap["resultType"] = "DatabaseLevelOutput"
	populate(objectMap, "sizeMB", m.SizeMB)
	populate(objectMap, "stage", m.Stage)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "state", m.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMITaskOutputDatabaseLevel.
func (m *MigrateSQLServerSQLMITaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "sizeMB":
			err = unpopulate(val, &m.SizeMB)
			delete(rawMsg, key)
		case "stage":
			err = unpopulate(val, &m.Stage)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLMITaskOutputError struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Migration error
	Error *ReportableException `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLMITaskOutput implements the MigrateSQLServerSQLMITaskOutputClassification interface for type MigrateSQLServerSQLMITaskOutputError.
func (m *MigrateSQLServerSQLMITaskOutputError) GetMigrateSQLServerSQLMITaskOutput() *MigrateSQLServerSQLMITaskOutput {
	return &MigrateSQLServerSQLMITaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMITaskOutputError.
func (m MigrateSQLServerSQLMITaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", m.Error)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "ErrorOutput"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMITaskOutputError.
func (m *MigrateSQLServerSQLMITaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &m.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLMITaskOutputLoginLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Login migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Login migration errors and warnings per login
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Login name.
	LoginName *string `json:"loginName,omitempty" azure:"ro"`

	// READ-ONLY; Login migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Current stage of login
	Stage *LoginMigrationStage `json:"stage,omitempty" azure:"ro"`

	// READ-ONLY; Login migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of login
	State *MigrationState `json:"state,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLMITaskOutput implements the MigrateSQLServerSQLMITaskOutputClassification interface for type MigrateSQLServerSQLMITaskOutputLoginLevel.
func (m *MigrateSQLServerSQLMITaskOutputLoginLevel) GetMigrateSQLServerSQLMITaskOutput() *MigrateSQLServerSQLMITaskOutput {
	return &MigrateSQLServerSQLMITaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMITaskOutputLoginLevel.
func (m MigrateSQLServerSQLMITaskOutputLoginLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "loginName", m.LoginName)
	populate(objectMap, "message", m.Message)
	objectMap["resultType"] = "LoginLevelOutput"
	populate(objectMap, "stage", m.Stage)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "state", m.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMITaskOutputLoginLevel.
func (m *MigrateSQLServerSQLMITaskOutputLoginLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "loginName":
			err = unpopulate(val, &m.LoginName)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "stage":
			err = unpopulate(val, &m.Stage)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLMITaskOutputMigrationLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Selected agent jobs as a map from name to id
	AgentJobs *string `json:"agentJobs,omitempty" azure:"ro"`

	// READ-ONLY; Selected databases as a map from database name to database id
	Databases *string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Migration exceptions and warnings.
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Selected logins as a map from name to id
	Logins *string `json:"logins,omitempty" azure:"ro"`

	// READ-ONLY; Migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; List of orphaned users.
	OrphanedUsersInfo []*OrphanedUserInfo `json:"orphanedUsersInfo,omitempty" azure:"ro"`

	// READ-ONLY; Map of server role migration results.
	ServerRoleResults *string `json:"serverRoleResults,omitempty" azure:"ro"`

	// READ-ONLY; Source server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Current status of migration
	Status *MigrationStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLMITaskOutput implements the MigrateSQLServerSQLMITaskOutputClassification interface for type MigrateSQLServerSQLMITaskOutputMigrationLevel.
func (m *MigrateSQLServerSQLMITaskOutputMigrationLevel) GetMigrateSQLServerSQLMITaskOutput() *MigrateSQLServerSQLMITaskOutput {
	return &MigrateSQLServerSQLMITaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMITaskOutputMigrationLevel.
func (m MigrateSQLServerSQLMITaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentJobs", m.AgentJobs)
	populate(objectMap, "databases", m.Databases)
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "logins", m.Logins)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "orphanedUsersInfo", m.OrphanedUsersInfo)
	objectMap["resultType"] = "MigrationLevelOutput"
	populate(objectMap, "serverRoleResults", m.ServerRoleResults)
	populate(objectMap, "sourceServerBrandVersion", m.SourceServerBrandVersion)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "state", m.State)
	populate(objectMap, "status", m.Status)
	populate(objectMap, "targetServerBrandVersion", m.TargetServerBrandVersion)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMITaskOutputMigrationLevel.
func (m *MigrateSQLServerSQLMITaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentJobs":
			err = unpopulate(val, &m.AgentJobs)
			delete(rawMsg, key)
		case "databases":
			err = unpopulate(val, &m.Databases)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "logins":
			err = unpopulate(val, &m.Logins)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "orphanedUsersInfo":
			err = unpopulate(val, &m.OrphanedUsersInfo)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "serverRoleResults":
			err = unpopulate(val, &m.ServerRoleResults)
			delete(rawMsg, key)
		case "sourceServerBrandVersion":
			err = unpopulate(val, &m.SourceServerBrandVersion)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		case "targetServerBrandVersion":
			err = unpopulate(val, &m.TargetServerBrandVersion)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateSQLServerSQLMITaskProperties - Properties for task that migrates SQL Server databases to Azure SQL Database Managed
// Instance
type MigrateSQLServerSQLMITaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// DateTime in UTC when the task was created
	CreatedOn *string `json:"createdOn,omitempty"`

	// Task input
	Input *MigrateSQLServerSQLMITaskInput `json:"input,omitempty"`

	// whether the task can be cloned or not
	IsCloneable *bool `json:"isCloneable,omitempty"`

	// parent task id
	ParentTaskID *string `json:"parentTaskId,omitempty"`

	// task id
	TaskID *string `json:"taskId,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateSQLServerSQLMITaskOutputClassification `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type MigrateSQLServerSQLMITaskProperties.
func (m *MigrateSQLServerSQLMITaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   m.TaskType,
		Errors:     m.Errors,
		State:      m.State,
		Commands:   m.Commands,
		ClientData: m.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMITaskProperties.
func (m MigrateSQLServerSQLMITaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", m.ClientData)
	populate(objectMap, "commands", m.Commands)
	populate(objectMap, "createdOn", m.CreatedOn)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "input", m.Input)
	populate(objectMap, "isCloneable", m.IsCloneable)
	populate(objectMap, "output", m.Output)
	populate(objectMap, "parentTaskId", m.ParentTaskID)
	populate(objectMap, "state", m.State)
	populate(objectMap, "taskId", m.TaskID)
	objectMap["taskType"] = TaskTypeMigrateSQLServerAzureSQLDbMI
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMITaskProperties.
func (m *MigrateSQLServerSQLMITaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &m.ClientData)
			delete(rawMsg, key)
		case "commands":
			m.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulate(val, &m.CreatedOn)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "isCloneable":
			err = unpopulate(val, &m.IsCloneable)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateSQLServerSQLMITaskOutputClassificationArray(val)
			delete(rawMsg, key)
		case "parentTaskId":
			err = unpopulate(val, &m.ParentTaskID)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "taskId":
			err = unpopulate(val, &m.TaskID)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &m.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateSchemaSQLServerSQLDbDatabaseInput - Database input for migrate schema Sql Server to Azure SQL Server scenario
type MigrateSchemaSQLServerSQLDbDatabaseInput struct {
	// Id of the source database
	ID *string `json:"id,omitempty"`

	// Name of source database
	Name *string `json:"name,omitempty"`

	// Database schema migration settings
	SchemaSetting *SchemaMigrationSetting `json:"schemaSetting,omitempty"`

	// Name of target database
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty"`
}

// MigrateSchemaSQLServerSQLDbTaskInput - Input for task that migrates Schema for SQL Server databases to Azure SQL databases
type MigrateSchemaSQLServerSQLDbTaskInput struct {
	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateSchemaSQLServerSQLDbDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Information for connecting to source
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Information for connecting to target
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// encrypted key for secure fields
	EncryptedKeyForSecureFields *string `json:"encryptedKeyForSecureFields,omitempty"`

	// Migration start time
	StartedOn *string `json:"startedOn,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSchemaSQLServerSQLDbTaskInput.
func (m MigrateSchemaSQLServerSQLDbTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptedKeyForSecureFields", m.EncryptedKeyForSecureFields)
	populate(objectMap, "selectedDatabases", m.SelectedDatabases)
	populate(objectMap, "sourceConnectionInfo", m.SourceConnectionInfo)
	populate(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "targetConnectionInfo", m.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// MigrateSchemaSQLServerSQLDbTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateSchemaSQLServerSQLDbTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateSchemaSQLServerSQLDbTaskOutput, *MigrateSchemaSQLServerSQLDbTaskOutputDatabaseLevel, *MigrateSchemaSQLServerSQLDbTaskOutputError,
// - *MigrateSchemaSQLServerSQLDbTaskOutputMigrationLevel, *MigrateSchemaSQLTaskOutputError
type MigrateSchemaSQLServerSQLDbTaskOutputClassification interface {
	// GetMigrateSchemaSQLServerSQLDbTaskOutput returns the MigrateSchemaSQLServerSQLDbTaskOutput content of the underlying type.
	GetMigrateSchemaSQLServerSQLDbTaskOutput() *MigrateSchemaSQLServerSQLDbTaskOutput
}

// MigrateSchemaSQLServerSQLDbTaskOutput - Output for the task that migrates Schema for SQL Server databases to Azure SQL
// databases
type MigrateSchemaSQLServerSQLDbTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSchemaSQLServerSQLDbTaskOutput implements the MigrateSchemaSQLServerSQLDbTaskOutputClassification interface for
// type MigrateSchemaSQLServerSQLDbTaskOutput.
func (m *MigrateSchemaSQLServerSQLDbTaskOutput) GetMigrateSchemaSQLServerSQLDbTaskOutput() *MigrateSchemaSQLServerSQLDbTaskOutput {
	return m
}

type MigrateSchemaSQLServerSQLDbTaskOutputDatabaseLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Prefix string to use for querying errors for this database
	DatabaseErrorResultPrefix *string `json:"databaseErrorResultPrefix,omitempty" azure:"ro"`

	// READ-ONLY; The name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Identifier for the file resource containing the schema of this database
	FileID *string `json:"fileId,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Number of failed operations for this database
	NumberOfFailedOperations *int64 `json:"numberOfFailedOperations,omitempty" azure:"ro"`

	// READ-ONLY; Number of successful operations for this database
	NumberOfSuccessfulOperations *int64 `json:"numberOfSuccessfulOperations,omitempty" azure:"ro"`

	// READ-ONLY; Prefix string to use for querying schema errors for this database
	SchemaErrorResultPrefix *string `json:"schemaErrorResultPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Schema migration stage for this database
	Stage *SchemaMigrationStage `json:"stage,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; State of the schema migration for this database
	State *MigrationState `json:"state,omitempty" azure:"ro"`
}

// GetMigrateSchemaSQLServerSQLDbTaskOutput implements the MigrateSchemaSQLServerSQLDbTaskOutputClassification interface for
// type MigrateSchemaSQLServerSQLDbTaskOutputDatabaseLevel.
func (m *MigrateSchemaSQLServerSQLDbTaskOutputDatabaseLevel) GetMigrateSchemaSQLServerSQLDbTaskOutput() *MigrateSchemaSQLServerSQLDbTaskOutput {
	return &MigrateSchemaSQLServerSQLDbTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSchemaSQLServerSQLDbTaskOutputDatabaseLevel.
func (m MigrateSchemaSQLServerSQLDbTaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databaseErrorResultPrefix", m.DatabaseErrorResultPrefix)
	populate(objectMap, "databaseName", m.DatabaseName)
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "fileId", m.FileID)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "numberOfFailedOperations", m.NumberOfFailedOperations)
	populate(objectMap, "numberOfSuccessfulOperations", m.NumberOfSuccessfulOperations)
	objectMap["resultType"] = "DatabaseLevelOutput"
	populate(objectMap, "schemaErrorResultPrefix", m.SchemaErrorResultPrefix)
	populate(objectMap, "stage", m.Stage)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "state", m.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSchemaSQLServerSQLDbTaskOutputDatabaseLevel.
func (m *MigrateSchemaSQLServerSQLDbTaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseErrorResultPrefix":
			err = unpopulate(val, &m.DatabaseErrorResultPrefix)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "fileId":
			err = unpopulate(val, &m.FileID)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "numberOfFailedOperations":
			err = unpopulate(val, &m.NumberOfFailedOperations)
			delete(rawMsg, key)
		case "numberOfSuccessfulOperations":
			err = unpopulate(val, &m.NumberOfSuccessfulOperations)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "schemaErrorResultPrefix":
			err = unpopulate(val, &m.SchemaErrorResultPrefix)
			delete(rawMsg, key)
		case "stage":
			err = unpopulate(val, &m.Stage)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSchemaSQLServerSQLDbTaskOutputError struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Schema command which failed
	CommandText *string `json:"commandText,omitempty" azure:"ro"`

	// READ-ONLY; Reason of failure
	ErrorText *string `json:"errorText,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSchemaSQLServerSQLDbTaskOutput implements the MigrateSchemaSQLServerSQLDbTaskOutputClassification interface for
// type MigrateSchemaSQLServerSQLDbTaskOutputError.
func (m *MigrateSchemaSQLServerSQLDbTaskOutputError) GetMigrateSchemaSQLServerSQLDbTaskOutput() *MigrateSchemaSQLServerSQLDbTaskOutput {
	return &MigrateSchemaSQLServerSQLDbTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSchemaSQLServerSQLDbTaskOutputError.
func (m MigrateSchemaSQLServerSQLDbTaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "commandText", m.CommandText)
	populate(objectMap, "errorText", m.ErrorText)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "SchemaErrorOutput"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSchemaSQLServerSQLDbTaskOutputError.
func (m *MigrateSchemaSQLServerSQLDbTaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commandText":
			err = unpopulate(val, &m.CommandText)
			delete(rawMsg, key)
		case "errorText":
			err = unpopulate(val, &m.ErrorText)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSchemaSQLServerSQLDbTaskOutputMigrationLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Source server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Overall state of the schema migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// GetMigrateSchemaSQLServerSQLDbTaskOutput implements the MigrateSchemaSQLServerSQLDbTaskOutputClassification interface for
// type MigrateSchemaSQLServerSQLDbTaskOutputMigrationLevel.
func (m *MigrateSchemaSQLServerSQLDbTaskOutputMigrationLevel) GetMigrateSchemaSQLServerSQLDbTaskOutput() *MigrateSchemaSQLServerSQLDbTaskOutput {
	return &MigrateSchemaSQLServerSQLDbTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSchemaSQLServerSQLDbTaskOutputMigrationLevel.
func (m MigrateSchemaSQLServerSQLDbTaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "MigrationLevelOutput"
	populate(objectMap, "sourceServerBrandVersion", m.SourceServerBrandVersion)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "state", m.State)
	populate(objectMap, "targetServerBrandVersion", m.TargetServerBrandVersion)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSchemaSQLServerSQLDbTaskOutputMigrationLevel.
func (m *MigrateSchemaSQLServerSQLDbTaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "sourceServerBrandVersion":
			err = unpopulate(val, &m.SourceServerBrandVersion)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "targetServerBrandVersion":
			err = unpopulate(val, &m.TargetServerBrandVersion)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateSchemaSQLServerSQLDbTaskProperties - Properties for task that migrates Schema for SQL Server databases to Azure
// SQL databases
type MigrateSchemaSQLServerSQLDbTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// DateTime in UTC when the task was created
	CreatedOn *string `json:"createdOn,omitempty"`

	// Task input
	Input *MigrateSchemaSQLServerSQLDbTaskInput `json:"input,omitempty"`

	// whether the task can be cloned or not
	IsCloneable *bool `json:"isCloneable,omitempty"`

	// Task id
	TaskID *string `json:"taskId,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateSchemaSQLServerSQLDbTaskOutputClassification `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type MigrateSchemaSQLServerSQLDbTaskProperties.
func (m *MigrateSchemaSQLServerSQLDbTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   m.TaskType,
		Errors:     m.Errors,
		State:      m.State,
		Commands:   m.Commands,
		ClientData: m.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSchemaSQLServerSQLDbTaskProperties.
func (m MigrateSchemaSQLServerSQLDbTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", m.ClientData)
	populate(objectMap, "commands", m.Commands)
	populate(objectMap, "createdOn", m.CreatedOn)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "input", m.Input)
	populate(objectMap, "isCloneable", m.IsCloneable)
	populate(objectMap, "output", m.Output)
	populate(objectMap, "state", m.State)
	populate(objectMap, "taskId", m.TaskID)
	objectMap["taskType"] = TaskTypeMigrateSchemaSQLServerSQLDb
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSchemaSQLServerSQLDbTaskProperties.
func (m *MigrateSchemaSQLServerSQLDbTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &m.ClientData)
			delete(rawMsg, key)
		case "commands":
			m.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "createdOn":
			err = unpopulate(val, &m.CreatedOn)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "isCloneable":
			err = unpopulate(val, &m.IsCloneable)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateSchemaSQLServerSQLDbTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "taskId":
			err = unpopulate(val, &m.TaskID)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &m.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSchemaSQLTaskOutputError struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Migration error
	Error *ReportableException `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSchemaSQLServerSQLDbTaskOutput implements the MigrateSchemaSQLServerSQLDbTaskOutputClassification interface for
// type MigrateSchemaSQLTaskOutputError.
func (m *MigrateSchemaSQLTaskOutputError) GetMigrateSchemaSQLServerSQLDbTaskOutput() *MigrateSchemaSQLServerSQLDbTaskOutput {
	return &MigrateSchemaSQLServerSQLDbTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSchemaSQLTaskOutputError.
func (m MigrateSchemaSQLTaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", m.Error)
	populate(objectMap, "id", m.ID)
	objectMap["resultType"] = "ErrorOutput"
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSchemaSQLTaskOutputError.
func (m *MigrateSchemaSQLTaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &m.Error)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateSsisTaskInput - Input for task that migrates SSIS packages from SQL Server to Azure SQL Database Managed Instance.
type MigrateSsisTaskInput struct {
	// REQUIRED; Information for connecting to source
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; SSIS package migration information.
	SsisMigrationInfo *SsisMigrationInfo `json:"ssisMigrationInfo,omitempty"`

	// REQUIRED; Information for connecting to target
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// MigrateSsisTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateSsisTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateSsisTaskOutput, *MigrateSsisTaskOutputMigrationLevel, *MigrateSsisTaskOutputProjectLevel
type MigrateSsisTaskOutputClassification interface {
	// GetMigrateSsisTaskOutput returns the MigrateSsisTaskOutput content of the underlying type.
	GetMigrateSsisTaskOutput() *MigrateSsisTaskOutput
}

// MigrateSsisTaskOutput - Output for task that migrates SSIS packages from SQL Server to Azure SQL Database Managed Instance.
type MigrateSsisTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSsisTaskOutput implements the MigrateSsisTaskOutputClassification interface for type MigrateSsisTaskOutput.
func (m *MigrateSsisTaskOutput) GetMigrateSsisTaskOutput() *MigrateSsisTaskOutput { return m }

type MigrateSsisTaskOutputMigrationLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Migration exceptions and warnings.
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Source server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Stage of SSIS migration.
	Stage *SsisMigrationStage `json:"stage,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current status of migration
	Status *MigrationStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// GetMigrateSsisTaskOutput implements the MigrateSsisTaskOutputClassification interface for type MigrateSsisTaskOutputMigrationLevel.
func (m *MigrateSsisTaskOutputMigrationLevel) GetMigrateSsisTaskOutput() *MigrateSsisTaskOutput {
	return &MigrateSsisTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSsisTaskOutputMigrationLevel.
func (m MigrateSsisTaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "message", m.Message)
	objectMap["resultType"] = "MigrationLevelOutput"
	populate(objectMap, "sourceServerBrandVersion", m.SourceServerBrandVersion)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populate(objectMap, "stage", m.Stage)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "status", m.Status)
	populate(objectMap, "targetServerBrandVersion", m.TargetServerBrandVersion)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSsisTaskOutputMigrationLevel.
func (m *MigrateSsisTaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "sourceServerBrandVersion":
			err = unpopulate(val, &m.SourceServerBrandVersion)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "stage":
			err = unpopulate(val, &m.Stage)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		case "targetServerBrandVersion":
			err = unpopulate(val, &m.TargetServerBrandVersion)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSsisTaskOutputProjectLevel struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Migration exceptions and warnings
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Name of the folder
	FolderName *string `json:"folderName,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Name of the project
	ProjectName *string `json:"projectName,omitempty" azure:"ro"`

	// READ-ONLY; Stage of SSIS migration.
	Stage *SsisMigrationStage `json:"stage,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`
}

// GetMigrateSsisTaskOutput implements the MigrateSsisTaskOutputClassification interface for type MigrateSsisTaskOutputProjectLevel.
func (m *MigrateSsisTaskOutputProjectLevel) GetMigrateSsisTaskOutput() *MigrateSsisTaskOutput {
	return &MigrateSsisTaskOutput{
		ID:         m.ID,
		ResultType: m.ResultType,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSsisTaskOutputProjectLevel.
func (m MigrateSsisTaskOutputProjectLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "folderName", m.FolderName)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "projectName", m.ProjectName)
	objectMap["resultType"] = "SsisProjectLevelOutput"
	populate(objectMap, "stage", m.Stage)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "state", m.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSsisTaskOutputProjectLevel.
func (m *MigrateSsisTaskOutputProjectLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "folderName":
			err = unpopulate(val, &m.FolderName)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "projectName":
			err = unpopulate(val, &m.ProjectName)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "stage":
			err = unpopulate(val, &m.Stage)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateSsisTaskProperties - Properties for task that migrates SSIS packages from SQL Server databases to Azure SQL Database
// Managed Instance.
type MigrateSsisTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *MigrateSsisTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateSsisTaskOutputClassification `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type MigrateSsisTaskProperties.
func (m *MigrateSsisTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   m.TaskType,
		Errors:     m.Errors,
		State:      m.State,
		Commands:   m.Commands,
		ClientData: m.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSsisTaskProperties.
func (m MigrateSsisTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", m.ClientData)
	populate(objectMap, "commands", m.Commands)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	populate(objectMap, "state", m.State)
	objectMap["taskType"] = TaskTypeMigrateSsis
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSsisTaskProperties.
func (m *MigrateSsisTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &m.ClientData)
			delete(rawMsg, key)
		case "commands":
			m.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateSsisTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &m.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateSyncCompleteCommandInput - Input for command that completes sync migration for a database.
type MigrateSyncCompleteCommandInput struct {
	// REQUIRED; Name of database
	DatabaseName *string `json:"databaseName,omitempty"`

	// Time stamp to complete
	CommitTimeStamp *time.Time `json:"commitTimeStamp,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSyncCompleteCommandInput.
func (m MigrateSyncCompleteCommandInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "commitTimeStamp", m.CommitTimeStamp)
	populate(objectMap, "databaseName", m.DatabaseName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSyncCompleteCommandInput.
func (m *MigrateSyncCompleteCommandInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commitTimeStamp":
			err = unpopulateTimeRFC3339(val, &m.CommitTimeStamp)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateSyncCompleteCommandOutput - Output for command that completes sync migration for a database.
type MigrateSyncCompleteCommandOutput struct {
	// READ-ONLY; List of errors that happened during the command execution
	Errors []*ReportableException `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSyncCompleteCommandOutput.
func (m MigrateSyncCompleteCommandOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "id", m.ID)
	return json.Marshal(objectMap)
}

// MigrateSyncCompleteCommandProperties - Properties for the command that completes sync migration for a database.
type MigrateSyncCompleteCommandProperties struct {
	// REQUIRED; Command type.
	CommandType *CommandType `json:"commandType,omitempty"`

	// Command id
	CommandID *string `json:"commandId,omitempty"`

	// Command input
	Input *MigrateSyncCompleteCommandInput `json:"input,omitempty"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Command output. This is ignored if submitted.
	Output *MigrateSyncCompleteCommandOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the command. This is ignored if submitted.
	State *CommandState `json:"state,omitempty" azure:"ro"`
}

// GetCommandProperties implements the CommandPropertiesClassification interface for type MigrateSyncCompleteCommandProperties.
func (m *MigrateSyncCompleteCommandProperties) GetCommandProperties() *CommandProperties {
	return &CommandProperties{
		CommandType: m.CommandType,
		Errors:      m.Errors,
		State:       m.State,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSyncCompleteCommandProperties.
func (m MigrateSyncCompleteCommandProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "commandId", m.CommandID)
	objectMap["commandType"] = CommandTypeMigrateSyncCompleteDatabase
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	populate(objectMap, "state", m.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSyncCompleteCommandProperties.
func (m *MigrateSyncCompleteCommandProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commandId":
			err = unpopulate(val, &m.CommandID)
			delete(rawMsg, key)
		case "commandType":
			err = unpopulate(val, &m.CommandType)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &m.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrationEligibilityInfo - Information about migration eligibility of a server object
type MigrationEligibilityInfo struct {
	// READ-ONLY; Whether object is eligible for migration or not.
	IsEligibleForMigration *bool `json:"isEligibleForMigration,omitempty" azure:"ro"`

	// READ-ONLY; Information about eligibility failure for the server object.
	ValidationMessages []*string `json:"validationMessages,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrationEligibilityInfo.
func (m MigrationEligibilityInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "isEligibleForMigration", m.IsEligibleForMigration)
	populate(objectMap, "validationMessages", m.ValidationMessages)
	return json.Marshal(objectMap)
}

// MigrationOperationInput - Migration Operation Input
type MigrationOperationInput struct {
	// ID tracking migration operation.
	MigrationOperationID *string `json:"migrationOperationId,omitempty"`
}

// MigrationReportResult - Migration validation report result, contains the url for downloading the generated report.
type MigrationReportResult struct {
	// Migration validation result identifier
	ID *string `json:"id,omitempty"`

	// The url of the report.
	ReportURL *string `json:"reportUrl,omitempty"`
}

// MigrationStatusDetails - Detailed status of current migration.
type MigrationStatusDetails struct {
	// READ-ONLY; Backup sets that are currently active.
	ActiveBackupSets []*SQLBackupSetInfo `json:"activeBackupSets,omitempty" azure:"ro"`

	// READ-ONLY; Name of blob container.
	BlobContainerName *string `json:"blobContainerName,omitempty" azure:"ro"`

	// READ-ONLY; Complete restore error message, if any
	CompleteRestoreErrorMessage *string `json:"completeRestoreErrorMessage,omitempty" azure:"ro"`

	// READ-ONLY; File name that is currently being restored.
	CurrentRestoringFilename *string `json:"currentRestoringFilename,omitempty" azure:"ro"`

	// READ-ONLY; File upload blocking errors, if any.
	FileUploadBlockingErrors []*string `json:"fileUploadBlockingErrors,omitempty" azure:"ro"`

	// READ-ONLY; Details of full backup set.
	FullBackupSetInfo *SQLBackupSetInfo `json:"fullBackupSetInfo,omitempty" azure:"ro"`

	// READ-ONLY; Files that are not valid backup files.
	InvalidFiles []*string `json:"invalidFiles,omitempty" azure:"ro"`

	// READ-ONLY; Whether full backup has been applied to the target database or not.
	IsFullBackupRestored *bool `json:"isFullBackupRestored,omitempty" azure:"ro"`

	// READ-ONLY; Last applied backup set information.
	LastRestoredBackupSetInfo *SQLBackupSetInfo `json:"lastRestoredBackupSetInfo,omitempty" azure:"ro"`

	// READ-ONLY; Last restored file name.
	LastRestoredFilename *string `json:"lastRestoredFilename,omitempty" azure:"ro"`

	// READ-ONLY; Current State of Migration.
	MigrationState *string `json:"migrationState,omitempty" azure:"ro"`

	// READ-ONLY; Total pending log backups.
	PendingLogBackupsCount *int32 `json:"pendingLogBackupsCount,omitempty" azure:"ro"`

	// READ-ONLY; Restore blocking reason, if any
	RestoreBlockingReason *string `json:"restoreBlockingReason,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrationStatusDetails.
func (m MigrationStatusDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activeBackupSets", m.ActiveBackupSets)
	populate(objectMap, "blobContainerName", m.BlobContainerName)
	populate(objectMap, "completeRestoreErrorMessage", m.CompleteRestoreErrorMessage)
	populate(objectMap, "currentRestoringFilename", m.CurrentRestoringFilename)
	populate(objectMap, "fileUploadBlockingErrors", m.FileUploadBlockingErrors)
	populate(objectMap, "fullBackupSetInfo", m.FullBackupSetInfo)
	populate(objectMap, "invalidFiles", m.InvalidFiles)
	populate(objectMap, "isFullBackupRestored", m.IsFullBackupRestored)
	populate(objectMap, "lastRestoredBackupSetInfo", m.LastRestoredBackupSetInfo)
	populate(objectMap, "lastRestoredFilename", m.LastRestoredFilename)
	populate(objectMap, "migrationState", m.MigrationState)
	populate(objectMap, "pendingLogBackupsCount", m.PendingLogBackupsCount)
	populate(objectMap, "restoreBlockingReason", m.RestoreBlockingReason)
	return json.Marshal(objectMap)
}

// MigrationTableMetadata - Metadata for tables selected in migration project
type MigrationTableMetadata struct {
	// READ-ONLY; Source table name
	SourceTableName *string `json:"sourceTableName,omitempty" azure:"ro"`

	// READ-ONLY; Target table name
	TargetTableName *string `json:"targetTableName,omitempty" azure:"ro"`
}

// MigrationValidationDatabaseLevelResult - Database level validation results
type MigrationValidationDatabaseLevelResult struct {
	// READ-ONLY; Provides data integrity validation result between the source and target tables that are migrated.
	DataIntegrityValidationResult *DataIntegrityValidationResult `json:"dataIntegrityValidationResult,omitempty" azure:"ro"`

	// READ-ONLY; Validation end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Migration Identifier
	MigrationID *string `json:"migrationId,omitempty" azure:"ro"`

	// READ-ONLY; Results of some of the query execution result between source and target database
	QueryAnalysisValidationResult *QueryAnalysisValidationResult `json:"queryAnalysisValidationResult,omitempty" azure:"ro"`

	// READ-ONLY; Provides schema comparison result between source and target database
	SchemaValidationResult *SchemaComparisonValidationResult `json:"schemaValidationResult,omitempty" azure:"ro"`

	// READ-ONLY; Name of the source database
	SourceDatabaseName *string `json:"sourceDatabaseName,omitempty" azure:"ro"`

	// READ-ONLY; Validation start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current status of validation at the database level
	Status *ValidationStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Name of the target database
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrationValidationDatabaseLevelResult.
func (m MigrationValidationDatabaseLevelResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataIntegrityValidationResult", m.DataIntegrityValidationResult)
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "migrationId", m.MigrationID)
	populate(objectMap, "queryAnalysisValidationResult", m.QueryAnalysisValidationResult)
	populate(objectMap, "schemaValidationResult", m.SchemaValidationResult)
	populate(objectMap, "sourceDatabaseName", m.SourceDatabaseName)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "status", m.Status)
	populate(objectMap, "targetDatabaseName", m.TargetDatabaseName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrationValidationDatabaseLevelResult.
func (m *MigrationValidationDatabaseLevelResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataIntegrityValidationResult":
			err = unpopulate(val, &m.DataIntegrityValidationResult)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "migrationId":
			err = unpopulate(val, &m.MigrationID)
			delete(rawMsg, key)
		case "queryAnalysisValidationResult":
			err = unpopulate(val, &m.QueryAnalysisValidationResult)
			delete(rawMsg, key)
		case "schemaValidationResult":
			err = unpopulate(val, &m.SchemaValidationResult)
			delete(rawMsg, key)
		case "sourceDatabaseName":
			err = unpopulate(val, &m.SourceDatabaseName)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		case "targetDatabaseName":
			err = unpopulate(val, &m.TargetDatabaseName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrationValidationDatabaseSummaryResult - Migration Validation Database level summary result
type MigrationValidationDatabaseSummaryResult struct {
	// READ-ONLY; Validation end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Migration Identifier
	MigrationID *string `json:"migrationId,omitempty" azure:"ro"`

	// READ-ONLY; Name of the source database
	SourceDatabaseName *string `json:"sourceDatabaseName,omitempty" azure:"ro"`

	// READ-ONLY; Validation start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current status of validation at the database level
	Status *ValidationStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Name of the target database
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrationValidationDatabaseSummaryResult.
func (m MigrationValidationDatabaseSummaryResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endedOn", m.EndedOn)
	populate(objectMap, "id", m.ID)
	populate(objectMap, "migrationId", m.MigrationID)
	populate(objectMap, "sourceDatabaseName", m.SourceDatabaseName)
	populateTimeRFC3339(objectMap, "startedOn", m.StartedOn)
	populate(objectMap, "status", m.Status)
	populate(objectMap, "targetDatabaseName", m.TargetDatabaseName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrationValidationDatabaseSummaryResult.
func (m *MigrationValidationDatabaseSummaryResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &m.EndedOn)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "migrationId":
			err = unpopulate(val, &m.MigrationID)
			delete(rawMsg, key)
		case "sourceDatabaseName":
			err = unpopulate(val, &m.SourceDatabaseName)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &m.StartedOn)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		case "targetDatabaseName":
			err = unpopulate(val, &m.TargetDatabaseName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrationValidationOptions - Types of validations to run after the migration
type MigrationValidationOptions struct {
	// Allows to perform a checksum based data integrity validation between source and target for the selected database / tables
	// .
	EnableDataIntegrityValidation *bool `json:"enableDataIntegrityValidation,omitempty"`

	// Allows to perform a quick and intelligent query analysis by retrieving queries from the source database and executes them
	// in the target. The result will have execution statistics for executions in
	// source and target databases for the extracted queries.
	EnableQueryAnalysisValidation *bool `json:"enableQueryAnalysisValidation,omitempty"`

	// Allows to compare the schema information between source and target.
	EnableSchemaValidation *bool `json:"enableSchemaValidation,omitempty"`
}

// MigrationValidationResult - Migration Validation Result
type MigrationValidationResult struct {
	// Validation summary results for each database
	SummaryResults map[string]*MigrationValidationDatabaseSummaryResult `json:"summaryResults,omitempty"`

	// READ-ONLY; Migration validation result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Migration Identifier
	MigrationID *string `json:"migrationId,omitempty" azure:"ro"`

	// READ-ONLY; Current status of validation at the migration level. Status from the database validation result status will
	// be aggregated here.
	Status *ValidationStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrationValidationResult.
func (m MigrationValidationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	populate(objectMap, "migrationId", m.MigrationID)
	populate(objectMap, "status", m.Status)
	populate(objectMap, "summaryResults", m.SummaryResults)
	return json.Marshal(objectMap)
}

// MongoDbCancelCommand - Properties for the command that cancels a migration in whole or in part
type MongoDbCancelCommand struct {
	// REQUIRED; Command type.
	CommandType *CommandType `json:"commandType,omitempty"`

	// Command input
	Input *MongoDbCommandInput `json:"input,omitempty"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; The state of the command. This is ignored if submitted.
	State *CommandState `json:"state,omitempty" azure:"ro"`
}

// GetCommandProperties implements the CommandPropertiesClassification interface for type MongoDbCancelCommand.
func (m *MongoDbCancelCommand) GetCommandProperties() *CommandProperties {
	return &CommandProperties{
		CommandType: m.CommandType,
		Errors:      m.Errors,
		State:       m.State,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbCancelCommand.
func (m MongoDbCancelCommand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["commandType"] = CommandTypeCancel
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "input", m.Input)
	populate(objectMap, "state", m.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbCancelCommand.
func (m *MongoDbCancelCommand) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commandType":
			err = unpopulate(val, &m.CommandType)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbClusterInfo - Describes a MongoDB data source
type MongoDbClusterInfo struct {
	// REQUIRED; A list of non-system databases in the cluster
	Databases []*MongoDbDatabaseInfo `json:"databases,omitempty"`

	// REQUIRED; Whether the cluster supports sharded collections
	SupportsSharding *bool `json:"supportsSharding,omitempty"`

	// REQUIRED; The type of data source
	Type *MongoDbClusterType `json:"type,omitempty"`

	// REQUIRED; The version of the data source in the form x.y.z (e.g. 3.6.7). Not used if Type is BlobContainer.
	Version *string `json:"version,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbClusterInfo.
func (m MongoDbClusterInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databases", m.Databases)
	populate(objectMap, "supportsSharding", m.SupportsSharding)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "version", m.Version)
	return json.Marshal(objectMap)
}

// MongoDbCollectionInfo - Describes a supported collection within a MongoDB database
type MongoDbCollectionInfo struct {
	// REQUIRED; The average document size, or -1 if the average size is unknown
	AverageDocumentSize *int64 `json:"averageDocumentSize,omitempty"`

	// REQUIRED; The estimated total data size, in bytes, or -1 if the size is unknown.
	DataSize *int64 `json:"dataSize,omitempty"`

	// REQUIRED; The name of the database containing the collection
	DatabaseName *string `json:"databaseName,omitempty"`

	// REQUIRED; The estimated total number of documents, or -1 if the document count is unknown
	DocumentCount *int64 `json:"documentCount,omitempty"`

	// REQUIRED; Whether the collection is a capped collection (i.e. whether it has a fixed size and acts like a circular buffer)
	IsCapped *bool `json:"isCapped,omitempty"`

	// REQUIRED; Whether the collection is system collection
	IsSystemCollection *bool `json:"isSystemCollection,omitempty"`

	// REQUIRED; Whether the collection is a view of another collection
	IsView *bool `json:"isView,omitempty"`

	// REQUIRED; The unqualified name of the database or collection
	Name *string `json:"name,omitempty"`

	// REQUIRED; The qualified name of the database or collection. For a collection, this is the database-qualified name.
	QualifiedName *string `json:"qualifiedName,omitempty"`

	// REQUIRED; Whether the database has sharding enabled. Note that the migration task will enable sharding on the target if
	// necessary.
	SupportsSharding *bool `json:"supportsSharding,omitempty"`

	// The shard key on the collection, or null if the collection is not sharded
	ShardKey *MongoDbShardKeyInfo `json:"shardKey,omitempty"`

	// The name of the collection that this is a view of, if IsView is true
	ViewOf *string `json:"viewOf,omitempty"`
}

// MongoDbCollectionProgress - Describes the progress of a collection
type MongoDbCollectionProgress struct {
	// REQUIRED; The number of document bytes copied during the Copying stage
	BytesCopied *int64 `json:"bytesCopied,omitempty"`

	// REQUIRED; The number of documents copied during the Copying stage
	DocumentsCopied *int64 `json:"documentsCopied,omitempty"`

	// REQUIRED; The elapsed time in the format [ddd.]hh:mm:ss[.fffffff] (i.e. TimeSpan format)
	ElapsedTime *string `json:"elapsedTime,omitempty"`

	// REQUIRED; The errors and warnings that have occurred for the current object. The keys are the error codes.
	Errors map[string]*MongoDbError `json:"errors,omitempty"`

	// REQUIRED; The number of oplog events awaiting replay
	EventsPending *int64 `json:"eventsPending,omitempty"`

	// REQUIRED; The number of oplog events replayed so far
	EventsReplayed *int64 `json:"eventsReplayed,omitempty"`

	// REQUIRED; The type of progress object
	ResultType *MongoDbProgressResultType `json:"resultType,omitempty"`

	// REQUIRED
	State *MongoDbMigrationState `json:"state,omitempty"`

	// REQUIRED; The total number of document bytes on the source at the beginning of the Copying stage, or -1 if the total size
	// was unknown
	TotalBytes *int64 `json:"totalBytes,omitempty"`

	// REQUIRED; The total number of documents on the source at the beginning of the Copying stage, or -1 if the total count was
	// unknown
	TotalDocuments *int64 `json:"totalDocuments,omitempty"`

	// The timestamp of the last oplog event received, or null if no oplog event has been received yet
	LastEventTime *time.Time `json:"lastEventTime,omitempty"`

	// The timestamp of the last oplog event replayed, or null if no oplog event has been replayed yet
	LastReplayTime *time.Time `json:"lastReplayTime,omitempty"`

	// The name of the progress object. For a collection, this is the unqualified collection name. For a database, this is the
	// database name. For the overall migration, this is null.
	Name *string `json:"name,omitempty"`

	// The qualified name of the progress object. For a collection, this is the database-qualified name. For a database, this
	// is the database name. For the overall migration, this is null.
	QualifiedName *string `json:"qualifiedName,omitempty"`
}

// GetMongoDbProgress implements the MongoDbProgressClassification interface for type MongoDbCollectionProgress.
func (m *MongoDbCollectionProgress) GetMongoDbProgress() *MongoDbProgress {
	return &MongoDbProgress{
		BytesCopied:     m.BytesCopied,
		DocumentsCopied: m.DocumentsCopied,
		ElapsedTime:     m.ElapsedTime,
		Errors:          m.Errors,
		EventsPending:   m.EventsPending,
		EventsReplayed:  m.EventsReplayed,
		LastEventTime:   m.LastEventTime,
		LastReplayTime:  m.LastReplayTime,
		Name:            m.Name,
		QualifiedName:   m.QualifiedName,
		ResultType:      m.ResultType,
		State:           m.State,
		TotalBytes:      m.TotalBytes,
		TotalDocuments:  m.TotalDocuments,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbCollectionProgress.
func (m MongoDbCollectionProgress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bytesCopied", m.BytesCopied)
	populate(objectMap, "documentsCopied", m.DocumentsCopied)
	populate(objectMap, "elapsedTime", m.ElapsedTime)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "eventsPending", m.EventsPending)
	populate(objectMap, "eventsReplayed", m.EventsReplayed)
	populateTimeRFC3339(objectMap, "lastEventTime", m.LastEventTime)
	populateTimeRFC3339(objectMap, "lastReplayTime", m.LastReplayTime)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "qualifiedName", m.QualifiedName)
	objectMap["resultType"] = MongoDbProgressResultTypeCollection
	populate(objectMap, "state", m.State)
	populate(objectMap, "totalBytes", m.TotalBytes)
	populate(objectMap, "totalDocuments", m.TotalDocuments)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbCollectionProgress.
func (m *MongoDbCollectionProgress) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bytesCopied":
			err = unpopulate(val, &m.BytesCopied)
			delete(rawMsg, key)
		case "documentsCopied":
			err = unpopulate(val, &m.DocumentsCopied)
			delete(rawMsg, key)
		case "elapsedTime":
			err = unpopulate(val, &m.ElapsedTime)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "eventsPending":
			err = unpopulate(val, &m.EventsPending)
			delete(rawMsg, key)
		case "eventsReplayed":
			err = unpopulate(val, &m.EventsReplayed)
			delete(rawMsg, key)
		case "lastEventTime":
			err = unpopulateTimeRFC3339(val, &m.LastEventTime)
			delete(rawMsg, key)
		case "lastReplayTime":
			err = unpopulateTimeRFC3339(val, &m.LastReplayTime)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "qualifiedName":
			err = unpopulate(val, &m.QualifiedName)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "totalBytes":
			err = unpopulate(val, &m.TotalBytes)
			delete(rawMsg, key)
		case "totalDocuments":
			err = unpopulate(val, &m.TotalDocuments)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbCollectionSettings - Describes how an individual MongoDB collection should be migrated
type MongoDbCollectionSettings struct {
	// Whether the migrator is allowed to drop the target collection in the course of performing a migration. The default is true.
	CanDelete *bool `json:"canDelete,omitempty"`

	// Describes a MongoDB shard key
	ShardKey *MongoDbShardKeySetting `json:"shardKey,omitempty"`

	// The RUs that should be configured on a CosmosDB target, or null to use the default. This has no effect on non-CosmosDB
	// targets.
	TargetRUs *int32 `json:"targetRUs,omitempty"`
}

// MongoDbCommandInput - Describes the input to the 'cancel' and 'restart' MongoDB migration commands
type MongoDbCommandInput struct {
	// The qualified name of a database or collection to act upon, or null to act upon the entire migration
	ObjectName *string `json:"objectName,omitempty"`
}

// MongoDbConnectionInfo - Describes a connection to a MongoDB data source
type MongoDbConnectionInfo struct {
	// REQUIRED; A MongoDB connection string or blob container URL. The user name and password can be specified here or in the
	// userName and password properties
	ConnectionString *string `json:"connectionString,omitempty"`

	// REQUIRED; Type of connection info
	Type *string `json:"type,omitempty"`

	// Additional connection settings
	AdditionalSettings *string `json:"additionalSettings,omitempty"`

	// Authentication type to use for connection
	Authentication *AuthenticationType `json:"authentication,omitempty"`

	// Data source
	DataSource *string `json:"dataSource,omitempty"`

	// Whether to encrypt the connection
	EncryptConnection *bool `json:"encryptConnection,omitempty"`
	EnforceSSL        *bool `json:"enforceSSL,omitempty"`

	// Password credential.
	Password *string `json:"password,omitempty"`

	// port for server
	Port *int32 `json:"port,omitempty"`

	// server brand version
	ServerBrandVersion *string `json:"serverBrandVersion,omitempty"`

	// name of the server
	ServerName *string `json:"serverName,omitempty"`

	// server version
	ServerVersion *string `json:"serverVersion,omitempty"`

	// Whether to trust the server certificate
	TrustServerCertificate *bool `json:"trustServerCertificate,omitempty"`

	// User name
	UserName *string `json:"userName,omitempty"`
}

// GetConnectionInfo implements the ConnectionInfoClassification interface for type MongoDbConnectionInfo.
func (m *MongoDbConnectionInfo) GetConnectionInfo() *ConnectionInfo {
	return &ConnectionInfo{
		Type:     m.Type,
		UserName: m.UserName,
		Password: m.Password,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbConnectionInfo.
func (m MongoDbConnectionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalSettings", m.AdditionalSettings)
	populate(objectMap, "authentication", m.Authentication)
	populate(objectMap, "connectionString", m.ConnectionString)
	populate(objectMap, "dataSource", m.DataSource)
	populate(objectMap, "encryptConnection", m.EncryptConnection)
	populate(objectMap, "enforceSSL", m.EnforceSSL)
	populate(objectMap, "password", m.Password)
	populate(objectMap, "port", m.Port)
	populate(objectMap, "serverBrandVersion", m.ServerBrandVersion)
	populate(objectMap, "serverName", m.ServerName)
	populate(objectMap, "serverVersion", m.ServerVersion)
	populate(objectMap, "trustServerCertificate", m.TrustServerCertificate)
	objectMap["type"] = "MongoDbConnectionInfo"
	populate(objectMap, "userName", m.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbConnectionInfo.
func (m *MongoDbConnectionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalSettings":
			err = unpopulate(val, &m.AdditionalSettings)
			delete(rawMsg, key)
		case "authentication":
			err = unpopulate(val, &m.Authentication)
			delete(rawMsg, key)
		case "connectionString":
			err = unpopulate(val, &m.ConnectionString)
			delete(rawMsg, key)
		case "dataSource":
			err = unpopulate(val, &m.DataSource)
			delete(rawMsg, key)
		case "encryptConnection":
			err = unpopulate(val, &m.EncryptConnection)
			delete(rawMsg, key)
		case "enforceSSL":
			err = unpopulate(val, &m.EnforceSSL)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, &m.Password)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &m.Port)
			delete(rawMsg, key)
		case "serverBrandVersion":
			err = unpopulate(val, &m.ServerBrandVersion)
			delete(rawMsg, key)
		case "serverName":
			err = unpopulate(val, &m.ServerName)
			delete(rawMsg, key)
		case "serverVersion":
			err = unpopulate(val, &m.ServerVersion)
			delete(rawMsg, key)
		case "trustServerCertificate":
			err = unpopulate(val, &m.TrustServerCertificate)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &m.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbDatabaseInfo - Describes a database within a MongoDB data source
type MongoDbDatabaseInfo struct {
	// REQUIRED; The average document size, or -1 if the average size is unknown
	AverageDocumentSize *int64 `json:"averageDocumentSize,omitempty"`

	// REQUIRED; A list of supported collections in a MongoDB database
	Collections []*MongoDbCollectionInfo `json:"collections,omitempty"`

	// REQUIRED; The estimated total data size, in bytes, or -1 if the size is unknown.
	DataSize *int64 `json:"dataSize,omitempty"`

	// REQUIRED; The estimated total number of documents, or -1 if the document count is unknown
	DocumentCount *int64 `json:"documentCount,omitempty"`

	// REQUIRED; The unqualified name of the database or collection
	Name *string `json:"name,omitempty"`

	// REQUIRED; The qualified name of the database or collection. For a collection, this is the database-qualified name.
	QualifiedName *string `json:"qualifiedName,omitempty"`

	// REQUIRED; Whether the database has sharding enabled. Note that the migration task will enable sharding on the target if
	// necessary.
	SupportsSharding *bool `json:"supportsSharding,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbDatabaseInfo.
func (m MongoDbDatabaseInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "averageDocumentSize", m.AverageDocumentSize)
	populate(objectMap, "collections", m.Collections)
	populate(objectMap, "dataSize", m.DataSize)
	populate(objectMap, "documentCount", m.DocumentCount)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "qualifiedName", m.QualifiedName)
	populate(objectMap, "supportsSharding", m.SupportsSharding)
	return json.Marshal(objectMap)
}

// MongoDbDatabaseProgress - Describes the progress of a database
type MongoDbDatabaseProgress struct {
	// REQUIRED; The number of document bytes copied during the Copying stage
	BytesCopied *int64 `json:"bytesCopied,omitempty"`

	// REQUIRED; The number of documents copied during the Copying stage
	DocumentsCopied *int64 `json:"documentsCopied,omitempty"`

	// REQUIRED; The elapsed time in the format [ddd.]hh:mm:ss[.fffffff] (i.e. TimeSpan format)
	ElapsedTime *string `json:"elapsedTime,omitempty"`

	// REQUIRED; The errors and warnings that have occurred for the current object. The keys are the error codes.
	Errors map[string]*MongoDbError `json:"errors,omitempty"`

	// REQUIRED; The number of oplog events awaiting replay
	EventsPending *int64 `json:"eventsPending,omitempty"`

	// REQUIRED; The number of oplog events replayed so far
	EventsReplayed *int64 `json:"eventsReplayed,omitempty"`

	// REQUIRED; The type of progress object
	ResultType *MongoDbProgressResultType `json:"resultType,omitempty"`

	// REQUIRED
	State *MongoDbMigrationState `json:"state,omitempty"`

	// REQUIRED; The total number of document bytes on the source at the beginning of the Copying stage, or -1 if the total size
	// was unknown
	TotalBytes *int64 `json:"totalBytes,omitempty"`

	// REQUIRED; The total number of documents on the source at the beginning of the Copying stage, or -1 if the total count was
	// unknown
	TotalDocuments *int64 `json:"totalDocuments,omitempty"`

	// The progress of the collections in the database. The keys are the unqualified names of the collections
	Collections map[string]*MongoDbCollectionProgress `json:"collections,omitempty"`

	// The timestamp of the last oplog event received, or null if no oplog event has been received yet
	LastEventTime *time.Time `json:"lastEventTime,omitempty"`

	// The timestamp of the last oplog event replayed, or null if no oplog event has been replayed yet
	LastReplayTime *time.Time `json:"lastReplayTime,omitempty"`

	// The name of the progress object. For a collection, this is the unqualified collection name. For a database, this is the
	// database name. For the overall migration, this is null.
	Name *string `json:"name,omitempty"`

	// The qualified name of the progress object. For a collection, this is the database-qualified name. For a database, this
	// is the database name. For the overall migration, this is null.
	QualifiedName *string `json:"qualifiedName,omitempty"`
}

// GetMongoDbProgress implements the MongoDbProgressClassification interface for type MongoDbDatabaseProgress.
func (m *MongoDbDatabaseProgress) GetMongoDbProgress() *MongoDbProgress {
	return &MongoDbProgress{
		BytesCopied:     m.BytesCopied,
		DocumentsCopied: m.DocumentsCopied,
		ElapsedTime:     m.ElapsedTime,
		Errors:          m.Errors,
		EventsPending:   m.EventsPending,
		EventsReplayed:  m.EventsReplayed,
		LastEventTime:   m.LastEventTime,
		LastReplayTime:  m.LastReplayTime,
		Name:            m.Name,
		QualifiedName:   m.QualifiedName,
		ResultType:      m.ResultType,
		State:           m.State,
		TotalBytes:      m.TotalBytes,
		TotalDocuments:  m.TotalDocuments,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbDatabaseProgress.
func (m MongoDbDatabaseProgress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bytesCopied", m.BytesCopied)
	populate(objectMap, "collections", m.Collections)
	populate(objectMap, "documentsCopied", m.DocumentsCopied)
	populate(objectMap, "elapsedTime", m.ElapsedTime)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "eventsPending", m.EventsPending)
	populate(objectMap, "eventsReplayed", m.EventsReplayed)
	populateTimeRFC3339(objectMap, "lastEventTime", m.LastEventTime)
	populateTimeRFC3339(objectMap, "lastReplayTime", m.LastReplayTime)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "qualifiedName", m.QualifiedName)
	objectMap["resultType"] = MongoDbProgressResultTypeDatabase
	populate(objectMap, "state", m.State)
	populate(objectMap, "totalBytes", m.TotalBytes)
	populate(objectMap, "totalDocuments", m.TotalDocuments)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbDatabaseProgress.
func (m *MongoDbDatabaseProgress) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bytesCopied":
			err = unpopulate(val, &m.BytesCopied)
			delete(rawMsg, key)
		case "collections":
			err = unpopulate(val, &m.Collections)
			delete(rawMsg, key)
		case "documentsCopied":
			err = unpopulate(val, &m.DocumentsCopied)
			delete(rawMsg, key)
		case "elapsedTime":
			err = unpopulate(val, &m.ElapsedTime)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "eventsPending":
			err = unpopulate(val, &m.EventsPending)
			delete(rawMsg, key)
		case "eventsReplayed":
			err = unpopulate(val, &m.EventsReplayed)
			delete(rawMsg, key)
		case "lastEventTime":
			err = unpopulateTimeRFC3339(val, &m.LastEventTime)
			delete(rawMsg, key)
		case "lastReplayTime":
			err = unpopulateTimeRFC3339(val, &m.LastReplayTime)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "qualifiedName":
			err = unpopulate(val, &m.QualifiedName)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "totalBytes":
			err = unpopulate(val, &m.TotalBytes)
			delete(rawMsg, key)
		case "totalDocuments":
			err = unpopulate(val, &m.TotalDocuments)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbDatabaseSettings - Describes how an individual MongoDB database should be migrated
type MongoDbDatabaseSettings struct {
	// REQUIRED; The collections on the source database to migrate to the target. The keys are the unqualified names of the collections.
	Collections map[string]*MongoDbCollectionSettings `json:"collections,omitempty"`

	// The RUs that should be configured on a CosmosDB target, or null to use the default, or 0 if throughput should not be provisioned
	// for the database. This has no effect on non-CosmosDB targets.
	TargetRUs *int32 `json:"targetRUs,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbDatabaseSettings.
func (m MongoDbDatabaseSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "collections", m.Collections)
	populate(objectMap, "targetRUs", m.TargetRUs)
	return json.Marshal(objectMap)
}

// MongoDbError - Describes an error or warning that occurred during a MongoDB migration
type MongoDbError struct {
	// The non-localized, machine-readable code that describes the error or warning
	Code *string `json:"code,omitempty"`

	// The number of times the error or warning has occurred
	Count *int32 `json:"count,omitempty"`

	// The localized, human-readable message that describes the error or warning
	Message *string `json:"message,omitempty"`

	// The type of error or warning
	Type *MongoDbErrorType `json:"type,omitempty"`
}

// MongoDbFinishCommand - Properties for the command that finishes a migration in whole or in part
type MongoDbFinishCommand struct {
	// REQUIRED; Command type.
	CommandType *CommandType `json:"commandType,omitempty"`

	// Command input
	Input *MongoDbFinishCommandInput `json:"input,omitempty"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; The state of the command. This is ignored if submitted.
	State *CommandState `json:"state,omitempty" azure:"ro"`
}

// GetCommandProperties implements the CommandPropertiesClassification interface for type MongoDbFinishCommand.
func (m *MongoDbFinishCommand) GetCommandProperties() *CommandProperties {
	return &CommandProperties{
		CommandType: m.CommandType,
		Errors:      m.Errors,
		State:       m.State,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbFinishCommand.
func (m MongoDbFinishCommand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["commandType"] = CommandTypeFinish
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "input", m.Input)
	populate(objectMap, "state", m.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbFinishCommand.
func (m *MongoDbFinishCommand) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commandType":
			err = unpopulate(val, &m.CommandType)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbFinishCommandInput - Describes the input to the 'finish' MongoDB migration command
type MongoDbFinishCommandInput struct {
	// REQUIRED; If true, replication for the affected objects will be stopped immediately. If false, the migrator will finish
	// replaying queued events before finishing the replication.
	Immediate *bool `json:"immediate,omitempty"`

	// The qualified name of a database or collection to act upon, or null to act upon the entire migration
	ObjectName *string `json:"objectName,omitempty"`
}

// MongoDbMigrationProgress - Describes the progress of the overall migration
type MongoDbMigrationProgress struct {
	// REQUIRED; The number of document bytes copied during the Copying stage
	BytesCopied *int64 `json:"bytesCopied,omitempty"`

	// REQUIRED; The number of documents copied during the Copying stage
	DocumentsCopied *int64 `json:"documentsCopied,omitempty"`

	// REQUIRED; The elapsed time in the format [ddd.]hh:mm:ss[.fffffff] (i.e. TimeSpan format)
	ElapsedTime *string `json:"elapsedTime,omitempty"`

	// REQUIRED; The errors and warnings that have occurred for the current object. The keys are the error codes.
	Errors map[string]*MongoDbError `json:"errors,omitempty"`

	// REQUIRED; The number of oplog events awaiting replay
	EventsPending *int64 `json:"eventsPending,omitempty"`

	// REQUIRED; The number of oplog events replayed so far
	EventsReplayed *int64 `json:"eventsReplayed,omitempty"`

	// REQUIRED; The type of progress object
	ResultType *MongoDbProgressResultType `json:"resultType,omitempty"`

	// REQUIRED
	State *MongoDbMigrationState `json:"state,omitempty"`

	// REQUIRED; The total number of document bytes on the source at the beginning of the Copying stage, or -1 if the total size
	// was unknown
	TotalBytes *int64 `json:"totalBytes,omitempty"`

	// REQUIRED; The total number of documents on the source at the beginning of the Copying stage, or -1 if the total count was
	// unknown
	TotalDocuments *int64 `json:"totalDocuments,omitempty"`

	// The progress of the databases in the migration. The keys are the names of the databases
	Databases map[string]*MongoDbDatabaseProgress `json:"databases,omitempty"`

	// The timestamp of the last oplog event received, or null if no oplog event has been received yet
	LastEventTime *time.Time `json:"lastEventTime,omitempty"`

	// The timestamp of the last oplog event replayed, or null if no oplog event has been replayed yet
	LastReplayTime *time.Time `json:"lastReplayTime,omitempty"`

	// The name of the progress object. For a collection, this is the unqualified collection name. For a database, this is the
	// database name. For the overall migration, this is null.
	Name *string `json:"name,omitempty"`

	// The qualified name of the progress object. For a collection, this is the database-qualified name. For a database, this
	// is the database name. For the overall migration, this is null.
	QualifiedName *string `json:"qualifiedName,omitempty"`
}

// GetMongoDbProgress implements the MongoDbProgressClassification interface for type MongoDbMigrationProgress.
func (m *MongoDbMigrationProgress) GetMongoDbProgress() *MongoDbProgress {
	return &MongoDbProgress{
		BytesCopied:     m.BytesCopied,
		DocumentsCopied: m.DocumentsCopied,
		ElapsedTime:     m.ElapsedTime,
		Errors:          m.Errors,
		EventsPending:   m.EventsPending,
		EventsReplayed:  m.EventsReplayed,
		LastEventTime:   m.LastEventTime,
		LastReplayTime:  m.LastReplayTime,
		Name:            m.Name,
		QualifiedName:   m.QualifiedName,
		ResultType:      m.ResultType,
		State:           m.State,
		TotalBytes:      m.TotalBytes,
		TotalDocuments:  m.TotalDocuments,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbMigrationProgress.
func (m MongoDbMigrationProgress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bytesCopied", m.BytesCopied)
	populate(objectMap, "databases", m.Databases)
	populate(objectMap, "documentsCopied", m.DocumentsCopied)
	populate(objectMap, "elapsedTime", m.ElapsedTime)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "eventsPending", m.EventsPending)
	populate(objectMap, "eventsReplayed", m.EventsReplayed)
	populateTimeRFC3339(objectMap, "lastEventTime", m.LastEventTime)
	populateTimeRFC3339(objectMap, "lastReplayTime", m.LastReplayTime)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "qualifiedName", m.QualifiedName)
	objectMap["resultType"] = MongoDbProgressResultTypeMigration
	populate(objectMap, "state", m.State)
	populate(objectMap, "totalBytes", m.TotalBytes)
	populate(objectMap, "totalDocuments", m.TotalDocuments)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbMigrationProgress.
func (m *MongoDbMigrationProgress) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bytesCopied":
			err = unpopulate(val, &m.BytesCopied)
			delete(rawMsg, key)
		case "databases":
			err = unpopulate(val, &m.Databases)
			delete(rawMsg, key)
		case "documentsCopied":
			err = unpopulate(val, &m.DocumentsCopied)
			delete(rawMsg, key)
		case "elapsedTime":
			err = unpopulate(val, &m.ElapsedTime)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "eventsPending":
			err = unpopulate(val, &m.EventsPending)
			delete(rawMsg, key)
		case "eventsReplayed":
			err = unpopulate(val, &m.EventsReplayed)
			delete(rawMsg, key)
		case "lastEventTime":
			err = unpopulateTimeRFC3339(val, &m.LastEventTime)
			delete(rawMsg, key)
		case "lastReplayTime":
			err = unpopulateTimeRFC3339(val, &m.LastReplayTime)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "qualifiedName":
			err = unpopulate(val, &m.QualifiedName)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "totalBytes":
			err = unpopulate(val, &m.TotalBytes)
			delete(rawMsg, key)
		case "totalDocuments":
			err = unpopulate(val, &m.TotalDocuments)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbMigrationSettings - Describes how a MongoDB data migration should be performed
type MongoDbMigrationSettings struct {
	// REQUIRED; The databases on the source cluster to migrate to the target. The keys are the names of the databases.
	Databases map[string]*MongoDbDatabaseSettings `json:"databases,omitempty"`

	// REQUIRED; Settings used to connect to the source cluster
	Source *MongoDbConnectionInfo `json:"source,omitempty"`

	// REQUIRED; Settings used to connect to the target cluster
	Target *MongoDbConnectionInfo `json:"target,omitempty"`

	// The RU limit on a CosmosDB target that collections will be temporarily increased to (if lower) during the initial copy
	// of a migration, from 10,000 to 1,000,000, or 0 to use the default boost (which is
	// generally the maximum), or null to not boost the RUs. This setting has no effect on non-CosmosDB targets.
	BoostRUs *int32 `json:"boostRUs,omitempty"`

	// Describes how changes will be replicated from the source to the target. The default is OneTime.
	Replication *MongoDbReplication `json:"replication,omitempty"`

	// Settings used to limit the resource usage of the migration
	Throttling *MongoDbThrottlingSettings `json:"throttling,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbMigrationSettings.
func (m MongoDbMigrationSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "boostRUs", m.BoostRUs)
	populate(objectMap, "databases", m.Databases)
	populate(objectMap, "replication", m.Replication)
	populate(objectMap, "source", m.Source)
	populate(objectMap, "target", m.Target)
	populate(objectMap, "throttling", m.Throttling)
	return json.Marshal(objectMap)
}

// MongoDbObjectInfo - Describes a database or collection within a MongoDB data source
type MongoDbObjectInfo struct {
	// REQUIRED; The average document size, or -1 if the average size is unknown
	AverageDocumentSize *int64 `json:"averageDocumentSize,omitempty"`

	// REQUIRED; The estimated total data size, in bytes, or -1 if the size is unknown.
	DataSize *int64 `json:"dataSize,omitempty"`

	// REQUIRED; The estimated total number of documents, or -1 if the document count is unknown
	DocumentCount *int64 `json:"documentCount,omitempty"`

	// REQUIRED; The unqualified name of the database or collection
	Name *string `json:"name,omitempty"`

	// REQUIRED; The qualified name of the database or collection. For a collection, this is the database-qualified name.
	QualifiedName *string `json:"qualifiedName,omitempty"`
}

// MongoDbProgressClassification provides polymorphic access to related types.
// Call the interface's GetMongoDbProgress() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MongoDbCollectionProgress, *MongoDbDatabaseProgress, *MongoDbMigrationProgress, *MongoDbProgress
type MongoDbProgressClassification interface {
	// GetMongoDbProgress returns the MongoDbProgress content of the underlying type.
	GetMongoDbProgress() *MongoDbProgress
}

// MongoDbProgress - Base class for MongoDB migration outputs
type MongoDbProgress struct {
	// REQUIRED; The number of document bytes copied during the Copying stage
	BytesCopied *int64 `json:"bytesCopied,omitempty"`

	// REQUIRED; The number of documents copied during the Copying stage
	DocumentsCopied *int64 `json:"documentsCopied,omitempty"`

	// REQUIRED; The elapsed time in the format [ddd.]hh:mm:ss[.fffffff] (i.e. TimeSpan format)
	ElapsedTime *string `json:"elapsedTime,omitempty"`

	// REQUIRED; The errors and warnings that have occurred for the current object. The keys are the error codes.
	Errors map[string]*MongoDbError `json:"errors,omitempty"`

	// REQUIRED; The number of oplog events awaiting replay
	EventsPending *int64 `json:"eventsPending,omitempty"`

	// REQUIRED; The number of oplog events replayed so far
	EventsReplayed *int64 `json:"eventsReplayed,omitempty"`

	// REQUIRED; The type of progress object
	ResultType *MongoDbProgressResultType `json:"resultType,omitempty"`

	// REQUIRED
	State *MongoDbMigrationState `json:"state,omitempty"`

	// REQUIRED; The total number of document bytes on the source at the beginning of the Copying stage, or -1 if the total size
	// was unknown
	TotalBytes *int64 `json:"totalBytes,omitempty"`

	// REQUIRED; The total number of documents on the source at the beginning of the Copying stage, or -1 if the total count was
	// unknown
	TotalDocuments *int64 `json:"totalDocuments,omitempty"`

	// The timestamp of the last oplog event received, or null if no oplog event has been received yet
	LastEventTime *time.Time `json:"lastEventTime,omitempty"`

	// The timestamp of the last oplog event replayed, or null if no oplog event has been replayed yet
	LastReplayTime *time.Time `json:"lastReplayTime,omitempty"`

	// The name of the progress object. For a collection, this is the unqualified collection name. For a database, this is the
	// database name. For the overall migration, this is null.
	Name *string `json:"name,omitempty"`

	// The qualified name of the progress object. For a collection, this is the database-qualified name. For a database, this
	// is the database name. For the overall migration, this is null.
	QualifiedName *string `json:"qualifiedName,omitempty"`
}

// GetMongoDbProgress implements the MongoDbProgressClassification interface for type MongoDbProgress.
func (m *MongoDbProgress) GetMongoDbProgress() *MongoDbProgress { return m }

// MarshalJSON implements the json.Marshaller interface for type MongoDbProgress.
func (m MongoDbProgress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "bytesCopied", m.BytesCopied)
	populate(objectMap, "documentsCopied", m.DocumentsCopied)
	populate(objectMap, "elapsedTime", m.ElapsedTime)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "eventsPending", m.EventsPending)
	populate(objectMap, "eventsReplayed", m.EventsReplayed)
	populateTimeRFC3339(objectMap, "lastEventTime", m.LastEventTime)
	populateTimeRFC3339(objectMap, "lastReplayTime", m.LastReplayTime)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "qualifiedName", m.QualifiedName)
	objectMap["resultType"] = m.ResultType
	populate(objectMap, "state", m.State)
	populate(objectMap, "totalBytes", m.TotalBytes)
	populate(objectMap, "totalDocuments", m.TotalDocuments)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbProgress.
func (m *MongoDbProgress) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bytesCopied":
			err = unpopulate(val, &m.BytesCopied)
			delete(rawMsg, key)
		case "documentsCopied":
			err = unpopulate(val, &m.DocumentsCopied)
			delete(rawMsg, key)
		case "elapsedTime":
			err = unpopulate(val, &m.ElapsedTime)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "eventsPending":
			err = unpopulate(val, &m.EventsPending)
			delete(rawMsg, key)
		case "eventsReplayed":
			err = unpopulate(val, &m.EventsReplayed)
			delete(rawMsg, key)
		case "lastEventTime":
			err = unpopulateTimeRFC3339(val, &m.LastEventTime)
			delete(rawMsg, key)
		case "lastReplayTime":
			err = unpopulateTimeRFC3339(val, &m.LastReplayTime)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "qualifiedName":
			err = unpopulate(val, &m.QualifiedName)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "totalBytes":
			err = unpopulate(val, &m.TotalBytes)
			delete(rawMsg, key)
		case "totalDocuments":
			err = unpopulate(val, &m.TotalDocuments)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbRestartCommand - Properties for the command that restarts a migration in whole or in part
type MongoDbRestartCommand struct {
	// REQUIRED; Command type.
	CommandType *CommandType `json:"commandType,omitempty"`

	// Command input
	Input *MongoDbCommandInput `json:"input,omitempty"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; The state of the command. This is ignored if submitted.
	State *CommandState `json:"state,omitempty" azure:"ro"`
}

// GetCommandProperties implements the CommandPropertiesClassification interface for type MongoDbRestartCommand.
func (m *MongoDbRestartCommand) GetCommandProperties() *CommandProperties {
	return &CommandProperties{
		CommandType: m.CommandType,
		Errors:      m.Errors,
		State:       m.State,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbRestartCommand.
func (m MongoDbRestartCommand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["commandType"] = CommandTypeRestart
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "input", m.Input)
	populate(objectMap, "state", m.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbRestartCommand.
func (m *MongoDbRestartCommand) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commandType":
			err = unpopulate(val, &m.CommandType)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbShardKeyField - Describes a field reference within a MongoDB shard key
type MongoDbShardKeyField struct {
	// REQUIRED; The name of the field
	Name *string `json:"name,omitempty"`

	// REQUIRED; The field ordering
	Order *MongoDbShardKeyOrder `json:"order,omitempty"`
}

// MongoDbShardKeyInfo - Describes a MongoDB shard key
type MongoDbShardKeyInfo struct {
	// REQUIRED; The fields within the shard key
	Fields []*MongoDbShardKeyField `json:"fields,omitempty"`

	// REQUIRED; Whether the shard key is unique
	IsUnique *bool `json:"isUnique,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbShardKeyInfo.
func (m MongoDbShardKeyInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fields", m.Fields)
	populate(objectMap, "isUnique", m.IsUnique)
	return json.Marshal(objectMap)
}

// MongoDbShardKeySetting - Describes a MongoDB shard key
type MongoDbShardKeySetting struct {
	// REQUIRED; The fields within the shard key
	Fields []*MongoDbShardKeyField `json:"fields,omitempty"`

	// Whether the shard key is unique
	IsUnique *bool `json:"isUnique,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbShardKeySetting.
func (m MongoDbShardKeySetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fields", m.Fields)
	populate(objectMap, "isUnique", m.IsUnique)
	return json.Marshal(objectMap)
}

// MongoDbThrottlingSettings - Specifies resource limits for the migration
type MongoDbThrottlingSettings struct {
	// The maximum number of work items (e.g. collection copies) that will be processed in parallel
	MaxParallelism *int32 `json:"maxParallelism,omitempty"`

	// The percentage of CPU time that the migrator will try to avoid using, from 0 to 100
	MinFreeCPU *int32 `json:"minFreeCpu,omitempty"`

	// The number of megabytes of RAM that the migrator will try to avoid using
	MinFreeMemoryMb *int32 `json:"minFreeMemoryMb,omitempty"`
}

// MySQLConnectionInfo - Information for connecting to MySQL server
type MySQLConnectionInfo struct {
	// REQUIRED; Port for Server
	Port *int32 `json:"port,omitempty"`

	// REQUIRED; Name of the server
	ServerName *string `json:"serverName,omitempty"`

	// REQUIRED; Type of connection info
	Type *string `json:"type,omitempty"`

	// Additional connection settings
	AdditionalSettings *string `json:"additionalSettings,omitempty"`

	// Authentication type to use for connection
	Authentication *AuthenticationType `json:"authentication,omitempty"`

	// Data source
	DataSource *string `json:"dataSource,omitempty"`

	// Whether to encrypt the connection
	EncryptConnection *bool `json:"encryptConnection,omitempty"`

	// Password credential.
	Password *string `json:"password,omitempty"`

	// User name
	UserName *string `json:"userName,omitempty"`
}

// GetConnectionInfo implements the ConnectionInfoClassification interface for type MySQLConnectionInfo.
func (m *MySQLConnectionInfo) GetConnectionInfo() *ConnectionInfo {
	return &ConnectionInfo{
		Type:     m.Type,
		UserName: m.UserName,
		Password: m.Password,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MySQLConnectionInfo.
func (m MySQLConnectionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalSettings", m.AdditionalSettings)
	populate(objectMap, "authentication", m.Authentication)
	populate(objectMap, "dataSource", m.DataSource)
	populate(objectMap, "encryptConnection", m.EncryptConnection)
	populate(objectMap, "password", m.Password)
	populate(objectMap, "port", m.Port)
	populate(objectMap, "serverName", m.ServerName)
	objectMap["type"] = "MySqlConnectionInfo"
	populate(objectMap, "userName", m.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MySQLConnectionInfo.
func (m *MySQLConnectionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalSettings":
			err = unpopulate(val, &m.AdditionalSettings)
			delete(rawMsg, key)
		case "authentication":
			err = unpopulate(val, &m.Authentication)
			delete(rawMsg, key)
		case "dataSource":
			err = unpopulate(val, &m.DataSource)
			delete(rawMsg, key)
		case "encryptConnection":
			err = unpopulate(val, &m.EncryptConnection)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, &m.Password)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &m.Port)
			delete(rawMsg, key)
		case "serverName":
			err = unpopulate(val, &m.ServerName)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &m.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// NameAvailabilityRequest - A resource type and proposed name
type NameAvailabilityRequest struct {
	// The proposed resource name
	Name *string `json:"name,omitempty"`

	// The resource type chain (e.g. virtualMachines/extensions)
	Type *string `json:"type,omitempty"`
}

// NameAvailabilityResponse - Indicates whether a proposed resource name is available
type NameAvailabilityResponse struct {
	// The localized reason why the name is not available, if nameAvailable is false
	Message *string `json:"message,omitempty"`

	// If true, the name is valid and available. If false, 'reason' describes why not.
	NameAvailable *bool `json:"nameAvailable,omitempty"`

	// The reason why the name is not available, if nameAvailable is false
	Reason *NameCheckFailureReason `json:"reason,omitempty"`
}

type NodeMonitoringData struct {
	// READ-ONLY; Unmatched properties from the message are deserialized in this collection.
	AdditionalProperties map[string]map[string]interface{} `json:"additionalProperties,omitempty" azure:"ro"`

	// READ-ONLY; Available memory (MB) on the integration runtime node.
	AvailableMemoryInMB *int32 `json:"availableMemoryInMB,omitempty" azure:"ro"`

	// READ-ONLY; CPU percentage on the integration runtime node.
	CPUUtilization *int32 `json:"cpuUtilization,omitempty" azure:"ro"`

	// READ-ONLY; Maximum concurrent jobs on the integration runtime node.
	ConcurrentJobsLimit *int32 `json:"concurrentJobsLimit,omitempty" azure:"ro"`

	// READ-ONLY; The number of jobs currently running on the integration runtime node.
	ConcurrentJobsRunning *int32 `json:"concurrentJobsRunning,omitempty" azure:"ro"`

	// READ-ONLY; The maximum concurrent jobs in this integration runtime.
	MaxConcurrentJobs *int32 `json:"maxConcurrentJobs,omitempty" azure:"ro"`

	// READ-ONLY; Name of the integration runtime node.
	NodeName *string `json:"nodeName,omitempty" azure:"ro"`

	// READ-ONLY; Received bytes on the integration runtime node.
	ReceivedBytes *float64 `json:"receivedBytes,omitempty" azure:"ro"`

	// READ-ONLY; Sent bytes on the integration runtime node.
	SentBytes *float64 `json:"sentBytes,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type NodeMonitoringData.
func (n NodeMonitoringData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalProperties", n.AdditionalProperties)
	populate(objectMap, "availableMemoryInMB", n.AvailableMemoryInMB)
	populate(objectMap, "cpuUtilization", n.CPUUtilization)
	populate(objectMap, "concurrentJobsLimit", n.ConcurrentJobsLimit)
	populate(objectMap, "concurrentJobsRunning", n.ConcurrentJobsRunning)
	populate(objectMap, "maxConcurrentJobs", n.MaxConcurrentJobs)
	populate(objectMap, "nodeName", n.NodeName)
	populate(objectMap, "receivedBytes", n.ReceivedBytes)
	populate(objectMap, "sentBytes", n.SentBytes)
	return json.Marshal(objectMap)
}

// NonSQLDataMigrationTable - Defines metadata for table to be migrated
type NonSQLDataMigrationTable struct {
	// Source table name
	SourceName *string `json:"sourceName,omitempty"`
}

// NonSQLDataMigrationTableResult - Object used to report the data migration results of a table
type NonSQLDataMigrationTableResult struct {
	// READ-ONLY; Time taken to migrate the data
	ElapsedTimeInMiliseconds *float64 `json:"elapsedTimeInMiliseconds,omitempty" azure:"ro"`

	// READ-ONLY; List of errors, if any, during migration
	Errors []*Error `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Result code of the data migration
	ResultCode *DataMigrationResultCode `json:"resultCode,omitempty" azure:"ro"`

	// READ-ONLY; Name of the source table
	SourceName *string `json:"sourceName,omitempty" azure:"ro"`

	// READ-ONLY; Number of rows in the source table
	SourceRowCount *int64 `json:"sourceRowCount,omitempty" azure:"ro"`

	// READ-ONLY; Name of the target table
	TargetName *string `json:"targetName,omitempty" azure:"ro"`

	// READ-ONLY; Number of rows in the target table
	TargetRowCount *int64 `json:"targetRowCount,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type NonSQLDataMigrationTableResult.
func (n NonSQLDataMigrationTableResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "elapsedTimeInMiliseconds", n.ElapsedTimeInMiliseconds)
	populate(objectMap, "errors", n.Errors)
	populate(objectMap, "resultCode", n.ResultCode)
	populate(objectMap, "sourceName", n.SourceName)
	populate(objectMap, "sourceRowCount", n.SourceRowCount)
	populate(objectMap, "targetName", n.TargetName)
	populate(objectMap, "targetRowCount", n.TargetRowCount)
	return json.Marshal(objectMap)
}

// NonSQLMigrationTaskInput - Base class for non sql migration task input
type NonSQLMigrationTaskInput struct {
	// REQUIRED; A URL that points to the drop location to access project artifacts
	ProjectLocation *string `json:"projectLocation,omitempty"`

	// REQUIRED; Name of the migration project
	ProjectName *string `json:"projectName,omitempty"`

	// REQUIRED; Metadata of the tables selected for migration
	SelectedTables []*NonSQLDataMigrationTable `json:"selectedTables,omitempty"`

	// REQUIRED; Information for connecting to target
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// REQUIRED; Target database name
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NonSQLMigrationTaskInput.
func (n NonSQLMigrationTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "projectLocation", n.ProjectLocation)
	populate(objectMap, "projectName", n.ProjectName)
	populate(objectMap, "selectedTables", n.SelectedTables)
	populate(objectMap, "targetConnectionInfo", n.TargetConnectionInfo)
	populate(objectMap, "targetDatabaseName", n.TargetDatabaseName)
	return json.Marshal(objectMap)
}

// NonSQLMigrationTaskOutput - Base class for non sql migration task output
type NonSQLMigrationTaskOutput struct {
	// READ-ONLY; Results of the migration. The key contains the table name and the value the table result object
	DataMigrationTableResults *string `json:"dataMigrationTableResults,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Message about the progress of the migration
	ProgressMessage *string `json:"progressMessage,omitempty" azure:"ro"`

	// READ-ONLY; Name of source server
	SourceServerName *string `json:"sourceServerName,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	Status *MigrationStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Name of target server
	TargetServerName *string `json:"targetServerName,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type NonSQLMigrationTaskOutput.
func (n NonSQLMigrationTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataMigrationTableResults", n.DataMigrationTableResults)
	populateTimeRFC3339(objectMap, "endedOn", n.EndedOn)
	populate(objectMap, "id", n.ID)
	populate(objectMap, "progressMessage", n.ProgressMessage)
	populate(objectMap, "sourceServerName", n.SourceServerName)
	populateTimeRFC3339(objectMap, "startedOn", n.StartedOn)
	populate(objectMap, "status", n.Status)
	populate(objectMap, "targetServerName", n.TargetServerName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NonSQLMigrationTaskOutput.
func (n *NonSQLMigrationTaskOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataMigrationTableResults":
			err = unpopulate(val, &n.DataMigrationTableResults)
			delete(rawMsg, key)
		case "endedOn":
			err = unpopulateTimeRFC3339(val, &n.EndedOn)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &n.ID)
			delete(rawMsg, key)
		case "progressMessage":
			err = unpopulate(val, &n.ProgressMessage)
			delete(rawMsg, key)
		case "sourceServerName":
			err = unpopulate(val, &n.SourceServerName)
			delete(rawMsg, key)
		case "startedOn":
			err = unpopulateTimeRFC3339(val, &n.StartedOn)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &n.Status)
			delete(rawMsg, key)
		case "targetServerName":
			err = unpopulate(val, &n.TargetServerName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ODataError - Error information in OData format.
type ODataError struct {
	// The machine-readable description of the error, such as 'InvalidRequest' or 'InternalServerError'
	Code *string `json:"code,omitempty"`

	// Inner errors that caused this error
	Details []*ODataError `json:"details,omitempty"`

	// The human-readable description of the error
	Message *string `json:"message,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ODataError.
func (o ODataError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", o.Code)
	populate(objectMap, "details", o.Details)
	populate(objectMap, "message", o.Message)
	return json.Marshal(objectMap)
}

// OfflineConfiguration - Offline configuration
type OfflineConfiguration struct {
	// Last backup name for offline migration. This is optional for migrations from file share. If it is not provided, then the
	// service will determine the last backup file name based on latest backup files
	// present in file share.
	LastBackupName *string `json:"lastBackupName,omitempty"`

	// Offline migration
	Offline *bool `json:"offline,omitempty"`
}

// OperationListResult - Result of the request to list SQL operations.
type OperationListResult struct {
	// READ-ONLY
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY
	Value []*OperationsDefinition `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationsClientListOptions contains the optional parameters for the OperationsClient.List method.
type OperationsClientListOptions struct {
	// placeholder for future optional parameters
}

type OperationsDefinition struct {
	// Indicates whether the operation is a data action
	IsDataAction *bool `json:"isDataAction,omitempty"`

	// READ-ONLY
	Display *OperationsDisplayDefinition `json:"display,omitempty" azure:"ro"`

	// READ-ONLY
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY
	Origin *OperationOrigin `json:"origin,omitempty" azure:"ro"`

	// READ-ONLY; Dictionary of
	Properties map[string]map[string]interface{} `json:"properties,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationsDefinition.
func (o OperationsDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "display", o.Display)
	populate(objectMap, "isDataAction", o.IsDataAction)
	populate(objectMap, "name", o.Name)
	populate(objectMap, "origin", o.Origin)
	populate(objectMap, "properties", o.Properties)
	return json.Marshal(objectMap)
}

type OperationsDisplayDefinition struct {
	// READ-ONLY
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY
	Operation *string `json:"operation,omitempty" azure:"ro"`

	// READ-ONLY
	Provider *string `json:"provider,omitempty" azure:"ro"`

	// READ-ONLY
	Resource *string `json:"resource,omitempty" azure:"ro"`
}

// OracleConnectionInfo - Information for connecting to Oracle server
type OracleConnectionInfo struct {
	// REQUIRED; EZConnect or TNSName connection string.
	DataSource *string `json:"dataSource,omitempty"`

	// REQUIRED; Type of connection info
	Type *string `json:"type,omitempty"`

	// Authentication type to use for connection
	Authentication *AuthenticationType `json:"authentication,omitempty"`

	// Password credential.
	Password *string `json:"password,omitempty"`

	// port for server
	Port *int32 `json:"port,omitempty"`

	// name of the server
	ServerName *string `json:"serverName,omitempty"`

	// server version
	ServerVersion *string `json:"serverVersion,omitempty"`

	// User name
	UserName *string `json:"userName,omitempty"`
}

// GetConnectionInfo implements the ConnectionInfoClassification interface for type OracleConnectionInfo.
func (o *OracleConnectionInfo) GetConnectionInfo() *ConnectionInfo {
	return &ConnectionInfo{
		Type:     o.Type,
		UserName: o.UserName,
		Password: o.Password,
	}
}

// MarshalJSON implements the json.Marshaller interface for type OracleConnectionInfo.
func (o OracleConnectionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "authentication", o.Authentication)
	populate(objectMap, "dataSource", o.DataSource)
	populate(objectMap, "password", o.Password)
	populate(objectMap, "port", o.Port)
	populate(objectMap, "serverName", o.ServerName)
	populate(objectMap, "serverVersion", o.ServerVersion)
	objectMap["type"] = "OracleConnectionInfo"
	populate(objectMap, "userName", o.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleConnectionInfo.
func (o *OracleConnectionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authentication":
			err = unpopulate(val, &o.Authentication)
			delete(rawMsg, key)
		case "dataSource":
			err = unpopulate(val, &o.DataSource)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, &o.Password)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &o.Port)
			delete(rawMsg, key)
		case "serverName":
			err = unpopulate(val, &o.ServerName)
			delete(rawMsg, key)
		case "serverVersion":
			err = unpopulate(val, &o.ServerVersion)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &o.Type)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &o.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OracleOCIDriverInfo - Information about an Oracle OCI driver.
type OracleOCIDriverInfo struct {
	// READ-ONLY; The MD5 Base64 encoded checksum for the driver package.
	ArchiveChecksum *string `json:"archiveChecksum,omitempty" azure:"ro"`

	// READ-ONLY; Version listed in the OCI assembly 'oci.dll'
	AssemblyVersion *string `json:"assemblyVersion,omitempty" azure:"ro"`

	// READ-ONLY; The name of the driver package
	DriverName *string `json:"driverName,omitempty" azure:"ro"`

	// READ-ONLY; The size in bytes of the driver package
	DriverSize *string `json:"driverSize,omitempty" azure:"ro"`

	// READ-ONLY; The checksum for the driver package provided by Oracle.
	OracleChecksum *string `json:"oracleChecksum,omitempty" azure:"ro"`

	// READ-ONLY; List of Oracle database versions supported by this driver. Only major minor of the version is listed.
	SupportedOracleVersions []*string `json:"supportedOracleVersions,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OracleOCIDriverInfo.
func (o OracleOCIDriverInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "archiveChecksum", o.ArchiveChecksum)
	populate(objectMap, "assemblyVersion", o.AssemblyVersion)
	populate(objectMap, "driverName", o.DriverName)
	populate(objectMap, "driverSize", o.DriverSize)
	populate(objectMap, "oracleChecksum", o.OracleChecksum)
	populate(objectMap, "supportedOracleVersions", o.SupportedOracleVersions)
	return json.Marshal(objectMap)
}

// OrphanedUserInfo - Information of orphaned users on the SQL server database.
type OrphanedUserInfo struct {
	// Parent database of the user
	DatabaseName *string `json:"databaseName,omitempty"`

	// Name of the orphaned user
	Name *string `json:"name,omitempty"`
}

// PostgreSQLConnectionInfo - Information for connecting to PostgreSQL server
type PostgreSQLConnectionInfo struct {
	// REQUIRED; Port for Server
	Port *int32 `json:"port,omitempty"`

	// REQUIRED; Name of the server
	ServerName *string `json:"serverName,omitempty"`

	// REQUIRED; Type of connection info
	Type *string `json:"type,omitempty"`

	// Additional connection settings
	AdditionalSettings *string `json:"additionalSettings,omitempty"`

	// Authentication type to use for connection
	Authentication *AuthenticationType `json:"authentication,omitempty"`

	// Data source
	DataSource *string `json:"dataSource,omitempty"`

	// Name of the database
	DatabaseName *string `json:"databaseName,omitempty"`

	// Whether to encrypt the connection
	EncryptConnection *bool `json:"encryptConnection,omitempty"`

	// Password credential.
	Password *string `json:"password,omitempty"`

	// server brand version
	ServerBrandVersion *string `json:"serverBrandVersion,omitempty"`

	// server version
	ServerVersion *string `json:"serverVersion,omitempty"`

	// Whether to trust the server certificate
	TrustServerCertificate *bool `json:"trustServerCertificate,omitempty"`

	// User name
	UserName *string `json:"userName,omitempty"`
}

// GetConnectionInfo implements the ConnectionInfoClassification interface for type PostgreSQLConnectionInfo.
func (p *PostgreSQLConnectionInfo) GetConnectionInfo() *ConnectionInfo {
	return &ConnectionInfo{
		Type:     p.Type,
		UserName: p.UserName,
		Password: p.Password,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PostgreSQLConnectionInfo.
func (p PostgreSQLConnectionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalSettings", p.AdditionalSettings)
	populate(objectMap, "authentication", p.Authentication)
	populate(objectMap, "dataSource", p.DataSource)
	populate(objectMap, "databaseName", p.DatabaseName)
	populate(objectMap, "encryptConnection", p.EncryptConnection)
	populate(objectMap, "password", p.Password)
	populate(objectMap, "port", p.Port)
	populate(objectMap, "serverBrandVersion", p.ServerBrandVersion)
	populate(objectMap, "serverName", p.ServerName)
	populate(objectMap, "serverVersion", p.ServerVersion)
	populate(objectMap, "trustServerCertificate", p.TrustServerCertificate)
	objectMap["type"] = "PostgreSqlConnectionInfo"
	populate(objectMap, "userName", p.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PostgreSQLConnectionInfo.
func (p *PostgreSQLConnectionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalSettings":
			err = unpopulate(val, &p.AdditionalSettings)
			delete(rawMsg, key)
		case "authentication":
			err = unpopulate(val, &p.Authentication)
			delete(rawMsg, key)
		case "dataSource":
			err = unpopulate(val, &p.DataSource)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &p.DatabaseName)
			delete(rawMsg, key)
		case "encryptConnection":
			err = unpopulate(val, &p.EncryptConnection)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, &p.Password)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &p.Port)
			delete(rawMsg, key)
		case "serverBrandVersion":
			err = unpopulate(val, &p.ServerBrandVersion)
			delete(rawMsg, key)
		case "serverName":
			err = unpopulate(val, &p.ServerName)
			delete(rawMsg, key)
		case "serverVersion":
			err = unpopulate(val, &p.ServerVersion)
			delete(rawMsg, key)
		case "trustServerCertificate":
			err = unpopulate(val, &p.TrustServerCertificate)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &p.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Project - A project resource
type Project struct {
	// HTTP strong entity tag value. This is ignored if submitted.
	Etag     *string `json:"etag,omitempty"`
	Location *string `json:"location,omitempty"`

	// Project properties
	Properties *ProjectProperties `json:"properties,omitempty"`

	// Dictionary of
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Project.
func (p Project) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "location", p.Location)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "tags", p.Tags)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// ProjectFile - A file resource
type ProjectFile struct {
	// HTTP strong entity tag value. This is ignored if submitted.
	Etag *string `json:"etag,omitempty"`

	// Custom file properties
	Properties *ProjectFileProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ProjectFile.
func (p ProjectFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// ProjectFileProperties - Base class for file properties.
type ProjectFileProperties struct {
	// Optional File extension. If submitted it should not have a leading period and must match the extension from filePath.
	Extension *string `json:"extension,omitempty"`

	// Relative path of this file resource. This property can be set when creating or updating the file resource.
	FilePath *string `json:"filePath,omitempty"`

	// File content type. This property can be modified to reflect the file content type.
	MediaType *string `json:"mediaType,omitempty"`

	// READ-ONLY; Modification DateTime.
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`

	// READ-ONLY; File size.
	Size *int64 `json:"size,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ProjectFileProperties.
func (p ProjectFileProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extension", p.Extension)
	populate(objectMap, "filePath", p.FilePath)
	populateTimeRFC3339(objectMap, "lastModified", p.LastModified)
	populate(objectMap, "mediaType", p.MediaType)
	populate(objectMap, "size", p.Size)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProjectFileProperties.
func (p *ProjectFileProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extension":
			err = unpopulate(val, &p.Extension)
			delete(rawMsg, key)
		case "filePath":
			err = unpopulate(val, &p.FilePath)
			delete(rawMsg, key)
		case "lastModified":
			err = unpopulateTimeRFC3339(val, &p.LastModified)
			delete(rawMsg, key)
		case "mediaType":
			err = unpopulate(val, &p.MediaType)
			delete(rawMsg, key)
		case "size":
			err = unpopulate(val, &p.Size)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ProjectList - OData page of project resources
type ProjectList struct {
	// URL to load the next page of projects
	NextLink *string `json:"nextLink,omitempty"`

	// List of projects
	Value []*Project `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ProjectList.
func (p ProjectList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// ProjectMetadata - Common metadata for migration projects
type ProjectMetadata struct {
	// READ-ONLY; List of tables selected for migration
	SelectedMigrationTables []*MigrationTableMetadata `json:"selectedMigrationTables,omitempty" azure:"ro"`

	// READ-ONLY; Source server name
	SourceServerName *string `json:"sourceServerName,omitempty" azure:"ro"`

	// READ-ONLY; Source server port number
	SourceServerPort *string `json:"sourceServerPort,omitempty" azure:"ro"`

	// READ-ONLY; Source username
	SourceUsername *string `json:"sourceUsername,omitempty" azure:"ro"`

	// READ-ONLY; Target database name
	TargetDbName *string `json:"targetDbName,omitempty" azure:"ro"`

	// READ-ONLY; Target server name
	TargetServerName *string `json:"targetServerName,omitempty" azure:"ro"`

	// READ-ONLY; Target username
	TargetUsername *string `json:"targetUsername,omitempty" azure:"ro"`

	// READ-ONLY; Whether target connection is Windows authentication
	TargetUsingWinAuth *bool `json:"targetUsingWinAuth,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ProjectMetadata.
func (p ProjectMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "selectedMigrationTables", p.SelectedMigrationTables)
	populate(objectMap, "sourceServerName", p.SourceServerName)
	populate(objectMap, "sourceServerPort", p.SourceServerPort)
	populate(objectMap, "sourceUsername", p.SourceUsername)
	populate(objectMap, "targetDbName", p.TargetDbName)
	populate(objectMap, "targetServerName", p.TargetServerName)
	populate(objectMap, "targetUsername", p.TargetUsername)
	populate(objectMap, "targetUsingWinAuth", p.TargetUsingWinAuth)
	return json.Marshal(objectMap)
}

// ProjectProperties - Project-specific properties
type ProjectProperties struct {
	// REQUIRED; Source platform for the project
	SourcePlatform *ProjectSourcePlatform `json:"sourcePlatform,omitempty"`

	// REQUIRED; Target platform for the project
	TargetPlatform *ProjectTargetPlatform `json:"targetPlatform,omitempty"`

	// Field that defines the Azure active directory application info, used to connect to the target Azure resource
	AzureAuthenticationInfo *AzureActiveDirectoryApp `json:"azureAuthenticationInfo,omitempty"`

	// List of DatabaseInfo
	DatabasesInfo []*DatabaseInfo `json:"databasesInfo,omitempty"`

	// Information for connecting to source
	SourceConnectionInfo ConnectionInfoClassification `json:"sourceConnectionInfo,omitempty"`

	// Information for connecting to target
	TargetConnectionInfo ConnectionInfoClassification `json:"targetConnectionInfo,omitempty"`

	// READ-ONLY; UTC Date and time when project was created
	CreationTime *time.Time `json:"creationTime,omitempty" azure:"ro"`

	// READ-ONLY; The project's provisioning state
	ProvisioningState *ProjectProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ProjectProperties.
func (p ProjectProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureAuthenticationInfo", p.AzureAuthenticationInfo)
	populateTimeRFC3339(objectMap, "creationTime", p.CreationTime)
	populate(objectMap, "databasesInfo", p.DatabasesInfo)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	populate(objectMap, "sourceConnectionInfo", p.SourceConnectionInfo)
	populate(objectMap, "sourcePlatform", p.SourcePlatform)
	populate(objectMap, "targetConnectionInfo", p.TargetConnectionInfo)
	populate(objectMap, "targetPlatform", p.TargetPlatform)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProjectProperties.
func (p *ProjectProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureAuthenticationInfo":
			err = unpopulate(val, &p.AzureAuthenticationInfo)
			delete(rawMsg, key)
		case "creationTime":
			err = unpopulateTimeRFC3339(val, &p.CreationTime)
			delete(rawMsg, key)
		case "databasesInfo":
			err = unpopulate(val, &p.DatabasesInfo)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &p.ProvisioningState)
			delete(rawMsg, key)
		case "sourceConnectionInfo":
			p.SourceConnectionInfo, err = unmarshalConnectionInfoClassification(val)
			delete(rawMsg, key)
		case "sourcePlatform":
			err = unpopulate(val, &p.SourcePlatform)
			delete(rawMsg, key)
		case "targetConnectionInfo":
			p.TargetConnectionInfo, err = unmarshalConnectionInfoClassification(val)
			delete(rawMsg, key)
		case "targetPlatform":
			err = unpopulate(val, &p.TargetPlatform)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ProjectTask - A task resource
type ProjectTask struct {
	// HTTP strong entity tag value. This is ignored if submitted.
	Etag *string `json:"etag,omitempty"`

	// Custom task properties
	Properties ProjectTaskPropertiesClassification `json:"properties,omitempty"`

	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ProjectTask.
func (p ProjectTask) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProjectTask.
func (p *ProjectTask) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &p.Etag)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &p.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &p.Name)
			delete(rawMsg, key)
		case "properties":
			p.Properties, err = unmarshalProjectTaskPropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &p.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &p.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ProjectTaskPropertiesClassification provides polymorphic access to related types.
// Call the interface's GetProjectTaskProperties() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CheckOCIDriverTaskProperties, *ConnectToMongoDbTaskProperties, *ConnectToSourceMySQLTaskProperties, *ConnectToSourceOracleSyncTaskProperties,
// - *ConnectToSourcePostgreSQLSyncTaskProperties, *ConnectToSourceSQLServerSyncTaskProperties, *ConnectToSourceSQLServerTaskProperties,
// - *ConnectToTargetAzureDbForMySQLTaskProperties, *ConnectToTargetAzureDbForPostgreSQLSyncTaskProperties, *ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskProperties,
// - *ConnectToTargetSQLDbSyncTaskProperties, *ConnectToTargetSQLDbTaskProperties, *ConnectToTargetSQLMISyncTaskProperties,
// - *ConnectToTargetSQLMITaskProperties, *GetTdeCertificatesSQLTaskProperties, *GetUserTablesMySQLTaskProperties, *GetUserTablesOracleTaskProperties,
// - *GetUserTablesPostgreSQLTaskProperties, *GetUserTablesSQLSyncTaskProperties, *GetUserTablesSQLTaskProperties, *InstallOCIDriverTaskProperties,
// - *MigrateMongoDbTaskProperties, *MigrateMySQLAzureDbForMySQLOfflineTaskProperties, *MigrateMySQLAzureDbForMySQLSyncTaskProperties,
// - *MigrateOracleAzureDbForPostgreSQLSyncTaskProperties, *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskProperties, *MigrateSQLServerSQLDbSyncTaskProperties,
// - *MigrateSQLServerSQLDbTaskProperties, *MigrateSQLServerSQLMISyncTaskProperties, *MigrateSQLServerSQLMITaskProperties,
// - *MigrateSchemaSQLServerSQLDbTaskProperties, *MigrateSsisTaskProperties, *ProjectTaskProperties, *UploadOCIDriverTaskProperties,
// - *ValidateMigrationInputSQLServerSQLDbSyncTaskProperties, *ValidateMigrationInputSQLServerSQLMISyncTaskProperties, *ValidateMigrationInputSQLServerSQLMITaskProperties,
// - *ValidateMongoDbTaskProperties, *ValidateOracleAzureDbForPostgreSQLSyncTaskProperties
type ProjectTaskPropertiesClassification interface {
	// GetProjectTaskProperties returns the ProjectTaskProperties content of the underlying type.
	GetProjectTaskProperties() *ProjectTaskProperties
}

// ProjectTaskProperties - Base class for all types of DMS task properties. If task is not supported by current client, this
// object is returned.
type ProjectTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ProjectTaskProperties.
func (p *ProjectTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties { return p }

// MarshalJSON implements the json.Marshaller interface for type ProjectTaskProperties.
func (p ProjectTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", p.ClientData)
	populate(objectMap, "commands", p.Commands)
	populate(objectMap, "errors", p.Errors)
	populate(objectMap, "state", p.State)
	objectMap["taskType"] = p.TaskType
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProjectTaskProperties.
func (p *ProjectTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &p.ClientData)
			delete(rawMsg, key)
		case "commands":
			p.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &p.Errors)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &p.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &p.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ProjectsClientCreateOrUpdateOptions contains the optional parameters for the ProjectsClient.CreateOrUpdate method.
type ProjectsClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ProjectsClientDeleteOptions contains the optional parameters for the ProjectsClient.Delete method.
type ProjectsClientDeleteOptions struct {
	// Delete the resource even if it contains running tasks
	DeleteRunningTasks *bool
}

// ProjectsClientGetOptions contains the optional parameters for the ProjectsClient.Get method.
type ProjectsClientGetOptions struct {
	// placeholder for future optional parameters
}

// ProjectsClientListOptions contains the optional parameters for the ProjectsClient.List method.
type ProjectsClientListOptions struct {
	// placeholder for future optional parameters
}

// ProjectsClientUpdateOptions contains the optional parameters for the ProjectsClient.Update method.
type ProjectsClientUpdateOptions struct {
	// placeholder for future optional parameters
}

type ProxyResource struct {
	// READ-ONLY
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY
	Type *string `json:"type,omitempty" azure:"ro"`
}

// QueryAnalysisValidationResult - Results for query analysis comparison between the source and target
type QueryAnalysisValidationResult struct {
	// List of queries executed and it's execution results in source and target
	QueryResults *QueryExecutionResult `json:"queryResults,omitempty"`

	// Errors that are part of the execution
	ValidationErrors *ValidationError `json:"validationErrors,omitempty"`
}

// QueryExecutionResult - Describes query analysis results for execution in source and target
type QueryExecutionResult struct {
	// Query text retrieved from the source server
	QueryText *string `json:"queryText,omitempty"`

	// Query analysis result from the source
	SourceResult *ExecutionStatistics `json:"sourceResult,omitempty"`

	// Total no. of statements in the batch
	StatementsInBatch *int64 `json:"statementsInBatch,omitempty"`

	// Query analysis result from the target
	TargetResult *ExecutionStatistics `json:"targetResult,omitempty"`
}

// Quota - Describes a quota for or usage details about a resource
type Quota struct {
	// The current value of the quota. If null or missing, the current value cannot be determined in the context of the request.
	CurrentValue *float64 `json:"currentValue,omitempty"`

	// The resource ID of the quota object
	ID *string `json:"id,omitempty"`

	// The maximum value of the quota. If null or missing, the quota has no maximum, in which case it merely tracks usage.
	Limit *float64 `json:"limit,omitempty"`

	// The name of the quota
	Name *QuotaName `json:"name,omitempty"`

	// The unit for the quota, such as Count, Bytes, BytesPerSecond, etc.
	Unit *string `json:"unit,omitempty"`
}

// QuotaList - OData page of quota objects
type QuotaList struct {
	// URL to load the next page of quotas, or null or missing if this is the last page
	NextLink *string `json:"nextLink,omitempty"`

	// List of quotas
	Value []*Quota `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QuotaList.
func (q QuotaList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", q.NextLink)
	populate(objectMap, "value", q.Value)
	return json.Marshal(objectMap)
}

// QuotaName - The name of the quota
type QuotaName struct {
	// The localized name of the quota
	LocalizedValue *string `json:"localizedValue,omitempty"`

	// The unlocalized name (or ID) of the quota
	Value *string `json:"value,omitempty"`
}

// RegenAuthKeys - An authentication key to regenerate.
type RegenAuthKeys struct {
	// The first authentication key.
	AuthKey1 *string `json:"authKey1,omitempty"`

	// The second authentication key.
	AuthKey2 *string `json:"authKey2,omitempty"`

	// The name of authentication key to generate.
	KeyName *string `json:"keyName,omitempty"`
}

// ReportableException - Exception object for all custom exceptions
type ReportableException struct {
	// Actionable steps for this exception
	ActionableMessage *string `json:"actionableMessage,omitempty"`

	// The path to the file where exception occurred
	FilePath *string `json:"filePath,omitempty"`

	// Coded numerical value that is assigned to a specific exception
	HResult *int32 `json:"hResult,omitempty"`

	// The line number where exception occurred
	LineNumber *string `json:"lineNumber,omitempty"`

	// Error message
	Message *string `json:"message,omitempty"`

	// Stack trace
	StackTrace *string `json:"stackTrace,omitempty"`
}

// Resource - ARM resource.
type Resource struct {
	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// ResourceSKU - Describes an available DMS SKU.
type ResourceSKU struct {
	// READ-ONLY; The api versions that support this SKU.
	APIVersions []*string `json:"apiVersions,omitempty" azure:"ro"`

	// READ-ONLY; A name value pair to describe the capability.
	Capabilities []*ResourceSKUCapabilities `json:"capabilities,omitempty" azure:"ro"`

	// READ-ONLY; Not used.
	Capacity *ResourceSKUCapacity `json:"capacity,omitempty" azure:"ro"`

	// READ-ONLY; Metadata for retrieving price info.
	Costs []*ResourceSKUCosts `json:"costs,omitempty" azure:"ro"`

	// READ-ONLY; The Family of this particular SKU.
	Family *string `json:"family,omitempty" azure:"ro"`

	// READ-ONLY; The Kind of resources that are supported in this SKU.
	Kind *string `json:"kind,omitempty" azure:"ro"`

	// READ-ONLY; The set of locations that the SKU is available.
	Locations []*string `json:"locations,omitempty" azure:"ro"`

	// READ-ONLY; The name of SKU.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of resource the SKU applies to.
	ResourceType *string `json:"resourceType,omitempty" azure:"ro"`

	// READ-ONLY; The restrictions because of which SKU cannot be used. This is empty if there are no restrictions.
	Restrictions []*ResourceSKURestrictions `json:"restrictions,omitempty" azure:"ro"`

	// READ-ONLY; The Size of the SKU.
	Size *string `json:"size,omitempty" azure:"ro"`

	// READ-ONLY; Specifies the tier of DMS in a scale set.
	Tier *string `json:"tier,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceSKU.
func (r ResourceSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "apiVersions", r.APIVersions)
	populate(objectMap, "capabilities", r.Capabilities)
	populate(objectMap, "capacity", r.Capacity)
	populate(objectMap, "costs", r.Costs)
	populate(objectMap, "family", r.Family)
	populate(objectMap, "kind", r.Kind)
	populate(objectMap, "locations", r.Locations)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "resourceType", r.ResourceType)
	populate(objectMap, "restrictions", r.Restrictions)
	populate(objectMap, "size", r.Size)
	populate(objectMap, "tier", r.Tier)
	return json.Marshal(objectMap)
}

// ResourceSKUCapabilities - Describes The SKU capabilities object.
type ResourceSKUCapabilities struct {
	// READ-ONLY; An invariant to describe the feature.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; An invariant if the feature is measured by quantity.
	Value *string `json:"value,omitempty" azure:"ro"`
}

// ResourceSKUCapacity - Describes scaling information of a SKU.
type ResourceSKUCapacity struct {
	// READ-ONLY; The default capacity.
	Default *int64 `json:"default,omitempty" azure:"ro"`

	// READ-ONLY; The maximum capacity.
	Maximum *int64 `json:"maximum,omitempty" azure:"ro"`

	// READ-ONLY; The minimum capacity.
	Minimum *int64 `json:"minimum,omitempty" azure:"ro"`

	// READ-ONLY; The scale type applicable to the SKU.
	ScaleType *ResourceSKUCapacityScaleType `json:"scaleType,omitempty" azure:"ro"`
}

// ResourceSKUCosts - Describes metadata for retrieving price info.
type ResourceSKUCosts struct {
	// READ-ONLY; An invariant to show the extended unit.
	ExtendedUnit *string `json:"extendedUnit,omitempty" azure:"ro"`

	// READ-ONLY; Used for querying price from commerce.
	MeterID *string `json:"meterID,omitempty" azure:"ro"`

	// READ-ONLY; The multiplier is needed to extend the base metered cost.
	Quantity *int64 `json:"quantity,omitempty" azure:"ro"`
}

// ResourceSKURestrictions - Describes scaling information of a SKU.
type ResourceSKURestrictions struct {
	// READ-ONLY; The reason code for restriction.
	ReasonCode *ResourceSKURestrictionsReasonCode `json:"reasonCode,omitempty" azure:"ro"`

	// READ-ONLY; The type of restrictions.
	Type *ResourceSKURestrictionsType `json:"type,omitempty" azure:"ro"`

	// READ-ONLY; The value of restrictions. If the restriction type is set to location. This would be different locations where
	// the SKU is restricted.
	Values []*string `json:"values,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceSKURestrictions.
func (r ResourceSKURestrictions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "reasonCode", r.ReasonCode)
	populate(objectMap, "type", r.Type)
	populate(objectMap, "values", r.Values)
	return json.Marshal(objectMap)
}

// ResourceSKUsClientListSKUsOptions contains the optional parameters for the ResourceSKUsClient.ListSKUs method.
type ResourceSKUsClientListSKUsOptions struct {
	// placeholder for future optional parameters
}

// ResourceSKUsResult - The DMS List SKUs operation response.
type ResourceSKUsResult struct {
	// REQUIRED; The list of SKUs available for the subscription.
	Value []*ResourceSKU `json:"value,omitempty"`

	// The uri to fetch the next page of DMS SKUs. Call ListNext() with this to fetch the next page of DMS SKUs.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceSKUsResult.
func (r ResourceSKUsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// SQLBackupFileInfo - Information of backup file
type SQLBackupFileInfo struct {
	// READ-ONLY; Copy Duration in seconds
	CopyDuration *int32 `json:"copyDuration,omitempty" azure:"ro"`

	// READ-ONLY; Copy throughput in KBps
	CopyThroughput *float64 `json:"copyThroughput,omitempty" azure:"ro"`

	// READ-ONLY; Bytes read
	DataRead *int64 `json:"dataRead,omitempty" azure:"ro"`

	// READ-ONLY; Bytes written
	DataWritten *int64 `json:"dataWritten,omitempty" azure:"ro"`

	// READ-ONLY; Media family sequence number
	FamilySequenceNumber *int32 `json:"familySequenceNumber,omitempty" azure:"ro"`

	// READ-ONLY; File name.
	FileName *string `json:"fileName,omitempty" azure:"ro"`

	// READ-ONLY; Status of the file. (Initial, Uploading, Uploaded, Restoring, Restored or Skipped)
	Status *string `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; File size in bytes
	TotalSize *int64 `json:"totalSize,omitempty" azure:"ro"`
}

// SQLBackupSetInfo - Information of backup set
type SQLBackupSetInfo struct {
	// READ-ONLY; Backup end time.
	BackupFinishDate *time.Time `json:"backupFinishDate,omitempty" azure:"ro"`

	// READ-ONLY; Backup set id.
	BackupSetID *string `json:"backupSetId,omitempty" azure:"ro"`

	// READ-ONLY; Backup start date.
	BackupStartDate *time.Time `json:"backupStartDate,omitempty" azure:"ro"`

	// READ-ONLY; Backup type.
	BackupType *string `json:"backupType,omitempty" azure:"ro"`

	// READ-ONLY; Media family count
	FamilyCount *int32 `json:"familyCount,omitempty" azure:"ro"`

	// READ-ONLY; First LSN of the backup set.
	FirstLSN *string `json:"firstLSN,omitempty" azure:"ro"`

	// READ-ONLY; Has Backup Checksums
	HasBackupChecksums *bool `json:"hasBackupChecksums,omitempty" azure:"ro"`

	// READ-ONLY; The reasons why the backup set is ignored
	IgnoreReasons []*string `json:"ignoreReasons,omitempty" azure:"ro"`

	// READ-ONLY; Whether this backup set has been restored or not.
	IsBackupRestored *bool `json:"isBackupRestored,omitempty" azure:"ro"`

	// READ-ONLY; Last LSN of the backup set.
	LastLSN *string `json:"lastLSN,omitempty" azure:"ro"`

	// READ-ONLY; List of files in the backup set.
	ListOfBackupFiles []*SQLBackupFileInfo `json:"listOfBackupFiles,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLBackupSetInfo.
func (s SQLBackupSetInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "backupFinishDate", s.BackupFinishDate)
	populate(objectMap, "backupSetId", s.BackupSetID)
	populateTimeRFC3339(objectMap, "backupStartDate", s.BackupStartDate)
	populate(objectMap, "backupType", s.BackupType)
	populate(objectMap, "familyCount", s.FamilyCount)
	populate(objectMap, "firstLSN", s.FirstLSN)
	populate(objectMap, "hasBackupChecksums", s.HasBackupChecksums)
	populate(objectMap, "ignoreReasons", s.IgnoreReasons)
	populate(objectMap, "isBackupRestored", s.IsBackupRestored)
	populate(objectMap, "lastLSN", s.LastLSN)
	populate(objectMap, "listOfBackupFiles", s.ListOfBackupFiles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLBackupSetInfo.
func (s *SQLBackupSetInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupFinishDate":
			err = unpopulateTimeRFC3339(val, &s.BackupFinishDate)
			delete(rawMsg, key)
		case "backupSetId":
			err = unpopulate(val, &s.BackupSetID)
			delete(rawMsg, key)
		case "backupStartDate":
			err = unpopulateTimeRFC3339(val, &s.BackupStartDate)
			delete(rawMsg, key)
		case "backupType":
			err = unpopulate(val, &s.BackupType)
			delete(rawMsg, key)
		case "familyCount":
			err = unpopulate(val, &s.FamilyCount)
			delete(rawMsg, key)
		case "firstLSN":
			err = unpopulate(val, &s.FirstLSN)
			delete(rawMsg, key)
		case "hasBackupChecksums":
			err = unpopulate(val, &s.HasBackupChecksums)
			delete(rawMsg, key)
		case "ignoreReasons":
			err = unpopulate(val, &s.IgnoreReasons)
			delete(rawMsg, key)
		case "isBackupRestored":
			err = unpopulate(val, &s.IsBackupRestored)
			delete(rawMsg, key)
		case "lastLSN":
			err = unpopulate(val, &s.LastLSN)
			delete(rawMsg, key)
		case "listOfBackupFiles":
			err = unpopulate(val, &s.ListOfBackupFiles)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLConnectionInfo - Information for connecting to SQL database server
type SQLConnectionInfo struct {
	// REQUIRED; Data source in the format Protocol:MachineName\SQLServerInstanceName,PortNumber
	DataSource *string `json:"dataSource,omitempty"`

	// REQUIRED; Type of connection info
	Type *string `json:"type,omitempty"`

	// Additional connection settings
	AdditionalSettings *string `json:"additionalSettings,omitempty"`

	// Authentication type to use for connection
	Authentication *AuthenticationType `json:"authentication,omitempty"`

	// Whether to encrypt the connection
	EncryptConnection *bool `json:"encryptConnection,omitempty"`

	// Password credential.
	Password *string `json:"password,omitempty"`

	// Server platform type for connection
	Platform *SQLSourcePlatform `json:"platform,omitempty"`

	// Port for Server
	Port *int32 `json:"port,omitempty"`

	// Represents the ID of an HTTP resource represented by an Azure resource provider.
	ResourceID *string `json:"resourceId,omitempty"`

	// server brand version
	ServerBrandVersion *string `json:"serverBrandVersion,omitempty"`

	// name of the server
	ServerName *string `json:"serverName,omitempty"`

	// server version
	ServerVersion *string `json:"serverVersion,omitempty"`

	// Whether to trust the server certificate
	TrustServerCertificate *bool `json:"trustServerCertificate,omitempty"`

	// User name
	UserName *string `json:"userName,omitempty"`
}

// GetConnectionInfo implements the ConnectionInfoClassification interface for type SQLConnectionInfo.
func (s *SQLConnectionInfo) GetConnectionInfo() *ConnectionInfo {
	return &ConnectionInfo{
		Type:     s.Type,
		UserName: s.UserName,
		Password: s.Password,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SQLConnectionInfo.
func (s SQLConnectionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalSettings", s.AdditionalSettings)
	populate(objectMap, "authentication", s.Authentication)
	populate(objectMap, "dataSource", s.DataSource)
	populate(objectMap, "encryptConnection", s.EncryptConnection)
	populate(objectMap, "password", s.Password)
	populate(objectMap, "platform", s.Platform)
	populate(objectMap, "port", s.Port)
	populate(objectMap, "resourceId", s.ResourceID)
	populate(objectMap, "serverBrandVersion", s.ServerBrandVersion)
	populate(objectMap, "serverName", s.ServerName)
	populate(objectMap, "serverVersion", s.ServerVersion)
	populate(objectMap, "trustServerCertificate", s.TrustServerCertificate)
	objectMap["type"] = "SqlConnectionInfo"
	populate(objectMap, "userName", s.UserName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLConnectionInfo.
func (s *SQLConnectionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalSettings":
			err = unpopulate(val, &s.AdditionalSettings)
			delete(rawMsg, key)
		case "authentication":
			err = unpopulate(val, &s.Authentication)
			delete(rawMsg, key)
		case "dataSource":
			err = unpopulate(val, &s.DataSource)
			delete(rawMsg, key)
		case "encryptConnection":
			err = unpopulate(val, &s.EncryptConnection)
			delete(rawMsg, key)
		case "password":
			err = unpopulate(val, &s.Password)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, &s.Platform)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &s.Port)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &s.ResourceID)
			delete(rawMsg, key)
		case "serverBrandVersion":
			err = unpopulate(val, &s.ServerBrandVersion)
			delete(rawMsg, key)
		case "serverName":
			err = unpopulate(val, &s.ServerName)
			delete(rawMsg, key)
		case "serverVersion":
			err = unpopulate(val, &s.ServerVersion)
			delete(rawMsg, key)
		case "trustServerCertificate":
			err = unpopulate(val, &s.TrustServerCertificate)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &s.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SQLConnectionInformation - Source SQL Connection
type SQLConnectionInformation struct {
	// Authentication type.
	Authentication *string `json:"authentication,omitempty"`

	// Data source.
	DataSource *string `json:"dataSource,omitempty"`

	// Whether to encrypt connection or not.
	EncryptConnection *bool `json:"encryptConnection,omitempty"`

	// Password to connect to source SQL.
	Password *string `json:"password,omitempty"`

	// Whether to trust server certificate or not.
	TrustServerCertificate *bool `json:"trustServerCertificate,omitempty"`

	// User name to connect to source SQL.
	UserName *string `json:"userName,omitempty"`
}

// SQLDbMigrationStatusDetails - Detailed status of current Sql Db migration.
type SQLDbMigrationStatusDetails struct {
	// READ-ONLY; Details on progress of ADF copy activities.
	ListOfCopyProgressDetails []*CopyProgressDetails `json:"listOfCopyProgressDetails,omitempty" azure:"ro"`

	// READ-ONLY; Current State of Migration.
	MigrationState *string `json:"migrationState,omitempty" azure:"ro"`

	// READ-ONLY; Sql Data Copy errors, if any.
	SQLDataCopyErrors []*string `json:"sqlDataCopyErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLDbMigrationStatusDetails.
func (s SQLDbMigrationStatusDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "listOfCopyProgressDetails", s.ListOfCopyProgressDetails)
	populate(objectMap, "migrationState", s.MigrationState)
	populate(objectMap, "sqlDataCopyErrors", s.SQLDataCopyErrors)
	return json.Marshal(objectMap)
}

// SQLDbOfflineConfiguration - Offline configuration
type SQLDbOfflineConfiguration struct {
	// READ-ONLY; Offline migration
	Offline *bool `json:"offline,omitempty" azure:"ro"`
}

// SQLFileShare - File share
type SQLFileShare struct {
	// Password for username to access file share location.
	Password *string `json:"password,omitempty"`

	// Location as SMB share or local drive where backups are placed.
	Path *string `json:"path,omitempty"`

	// Username to access the file share location for backups.
	Username *string `json:"username,omitempty"`
}

// SQLMigrationListResult - A list of SQL Migration Service.
type SQLMigrationListResult struct {
	// READ-ONLY
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY
	Value []*SQLMigrationService `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLMigrationListResult.
func (s SQLMigrationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SQLMigrationService - A SQL Migration Service.
type SQLMigrationService struct {
	Location *string `json:"location,omitempty"`

	// The SQL Migration Service properties.
	Properties *SQLMigrationServiceProperties `json:"properties,omitempty"`

	// Dictionary of
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLMigrationService.
func (s SQLMigrationService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// SQLMigrationServiceProperties - The SQL Migration Service properties.
type SQLMigrationServiceProperties struct {
	// READ-ONLY; Current state of the Integration runtime.
	IntegrationRuntimeState *string `json:"integrationRuntimeState,omitempty" azure:"ro"`

	// READ-ONLY; Provisioning state to track the async operation status.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`
}

// SQLMigrationServiceUpdate - An update to a SQL Migration Service.
type SQLMigrationServiceUpdate struct {
	// Dictionary of
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLMigrationServiceUpdate.
func (s SQLMigrationServiceUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "tags", s.Tags)
	return json.Marshal(objectMap)
}

// SQLMigrationServicesClientBeginCreateOrUpdateOptions contains the optional parameters for the SQLMigrationServicesClient.BeginCreateOrUpdate
// method.
type SQLMigrationServicesClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SQLMigrationServicesClientBeginDeleteOptions contains the optional parameters for the SQLMigrationServicesClient.BeginDelete
// method.
type SQLMigrationServicesClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// SQLMigrationServicesClientBeginUpdateOptions contains the optional parameters for the SQLMigrationServicesClient.BeginUpdate
// method.
type SQLMigrationServicesClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// SQLMigrationServicesClientDeleteNodeOptions contains the optional parameters for the SQLMigrationServicesClient.DeleteNode
// method.
type SQLMigrationServicesClientDeleteNodeOptions struct {
	// placeholder for future optional parameters
}

// SQLMigrationServicesClientGetOptions contains the optional parameters for the SQLMigrationServicesClient.Get method.
type SQLMigrationServicesClientGetOptions struct {
	// placeholder for future optional parameters
}

// SQLMigrationServicesClientListAuthKeysOptions contains the optional parameters for the SQLMigrationServicesClient.ListAuthKeys
// method.
type SQLMigrationServicesClientListAuthKeysOptions struct {
	// placeholder for future optional parameters
}

// SQLMigrationServicesClientListByResourceGroupOptions contains the optional parameters for the SQLMigrationServicesClient.ListByResourceGroup
// method.
type SQLMigrationServicesClientListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// SQLMigrationServicesClientListBySubscriptionOptions contains the optional parameters for the SQLMigrationServicesClient.ListBySubscription
// method.
type SQLMigrationServicesClientListBySubscriptionOptions struct {
	// placeholder for future optional parameters
}

// SQLMigrationServicesClientListMigrationsOptions contains the optional parameters for the SQLMigrationServicesClient.ListMigrations
// method.
type SQLMigrationServicesClientListMigrationsOptions struct {
	// placeholder for future optional parameters
}

// SQLMigrationServicesClientListMonitoringDataOptions contains the optional parameters for the SQLMigrationServicesClient.ListMonitoringData
// method.
type SQLMigrationServicesClientListMonitoringDataOptions struct {
	// placeholder for future optional parameters
}

// SQLMigrationServicesClientRegenerateAuthKeysOptions contains the optional parameters for the SQLMigrationServicesClient.RegenerateAuthKeys
// method.
type SQLMigrationServicesClientRegenerateAuthKeysOptions struct {
	// placeholder for future optional parameters
}

// SQLMigrationTaskInput - Base class for migration task input
type SQLMigrationTaskInput struct {
	// REQUIRED; Information for connecting to source
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Information for connecting to target
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// SQLServerSQLMISyncTaskInput - Input for task that migrates SQL Server databases to Azure SQL Database Managed Instance
// online scenario.
type SQLServerSQLMISyncTaskInput struct {
	// REQUIRED; Azure Active Directory Application the DMS instance will use to connect to the target instance of Azure SQL Database
	// Managed Instance and the Azure Storage Account
	AzureApp *AzureActiveDirectoryApp `json:"azureApp,omitempty"`

	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateSQLServerSQLMIDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Connection information for source SQL Server
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Fully qualified resourceId of storage
	StorageResourceID *string `json:"storageResourceId,omitempty"`

	// REQUIRED; Connection information for Azure SQL Database Managed Instance
	TargetConnectionInfo *MiSQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// Backup file share information for all selected databases.
	BackupFileShare *FileShare `json:"backupFileShare,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerSQLMISyncTaskInput.
func (s SQLServerSQLMISyncTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureApp", s.AzureApp)
	populate(objectMap, "backupFileShare", s.BackupFileShare)
	populate(objectMap, "selectedDatabases", s.SelectedDatabases)
	populate(objectMap, "sourceConnectionInfo", s.SourceConnectionInfo)
	populate(objectMap, "storageResourceId", s.StorageResourceID)
	populate(objectMap, "targetConnectionInfo", s.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// SchemaComparisonValidationResult - Results for schema comparison between the source and target
type SchemaComparisonValidationResult struct {
	// List of schema differences between the source and target databases
	SchemaDifferences *SchemaComparisonValidationResultType `json:"schemaDifferences,omitempty"`

	// Count of source database objects
	SourceDatabaseObjectCount map[string]*int64 `json:"sourceDatabaseObjectCount,omitempty"`

	// Count of target database objects
	TargetDatabaseObjectCount map[string]*int64 `json:"targetDatabaseObjectCount,omitempty"`

	// List of errors that happened while performing schema compare validation
	ValidationErrors *ValidationError `json:"validationErrors,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SchemaComparisonValidationResult.
func (s SchemaComparisonValidationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "schemaDifferences", s.SchemaDifferences)
	populate(objectMap, "sourceDatabaseObjectCount", s.SourceDatabaseObjectCount)
	populate(objectMap, "targetDatabaseObjectCount", s.TargetDatabaseObjectCount)
	populate(objectMap, "validationErrors", s.ValidationErrors)
	return json.Marshal(objectMap)
}

// SchemaComparisonValidationResultType - Description about the errors happen while performing migration validation
type SchemaComparisonValidationResultType struct {
	// Name of the object that has the difference
	ObjectName *string `json:"objectName,omitempty"`

	// Type of the object that has the difference. e.g (Table/View/StoredProcedure)
	ObjectType *ObjectType `json:"objectType,omitempty"`

	// Update action type with respect to target
	UpdateAction *UpdateActionType `json:"updateAction,omitempty"`
}

// SchemaMigrationSetting - Settings for migrating schema from source to target
type SchemaMigrationSetting struct {
	// Resource Identifier of a file resource containing the uploaded schema file
	FileID *string `json:"fileId,omitempty"`

	// Name of the file resource containing the uploaded schema file
	FileName *string `json:"fileName,omitempty"`

	// Option on how to migrate the schema
	SchemaOption *SchemaMigrationOption `json:"schemaOption,omitempty"`
}

// SelectedCertificateInput - Info for certificate to be exported for TDE enabled databases.
type SelectedCertificateInput struct {
	// REQUIRED; Name of certificate to be exported.
	CertificateName *string `json:"certificateName,omitempty"`

	// REQUIRED; Password to use for encrypting the exported certificate.
	Password *string `json:"password,omitempty"`
}

// ServerProperties - Server properties for MySQL type source
type ServerProperties struct {
	// READ-ONLY; Number of databases in the server
	ServerDatabaseCount *int32 `json:"serverDatabaseCount,omitempty" azure:"ro"`

	// READ-ONLY; Edition of the database server
	ServerEdition *string `json:"serverEdition,omitempty" azure:"ro"`

	// READ-ONLY; Name of the server
	ServerName *string `json:"serverName,omitempty" azure:"ro"`

	// READ-ONLY; Version of the operating system
	ServerOperatingSystemVersion *string `json:"serverOperatingSystemVersion,omitempty" azure:"ro"`

	// READ-ONLY; Name of the server platform
	ServerPlatform *string `json:"serverPlatform,omitempty" azure:"ro"`

	// READ-ONLY; Version of the database server
	ServerVersion *string `json:"serverVersion,omitempty" azure:"ro"`
}

// Service - A Database Migration Service resource
type Service struct {
	// HTTP strong entity tag value. Ignored if submitted
	Etag *string `json:"etag,omitempty"`

	// The resource kind. Only 'vm' (the default) is supported.
	Kind     *string `json:"kind,omitempty"`
	Location *string `json:"location,omitempty"`

	// Custom service properties
	Properties *ServiceProperties `json:"properties,omitempty"`

	// Service SKU
	SKU *ServiceSKU `json:"sku,omitempty"`

	// Dictionary of
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Service.
func (s Service) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", s.Etag)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "kind", s.Kind)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "sku", s.SKU)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// ServiceList - OData page of service objects
type ServiceList struct {
	// URL to load the next page of services
	NextLink *string `json:"nextLink,omitempty"`

	// List of services
	Value []*Service `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceList.
func (s ServiceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// ServiceOperation - Description of an action supported by the Database Migration Service
type ServiceOperation struct {
	// Localized display text
	Display *ServiceOperationDisplay `json:"display,omitempty"`

	// The fully qualified action name, e.g. Microsoft.DataMigration/services/read
	Name *string `json:"name,omitempty"`
}

// ServiceOperationDisplay - Localized display text
type ServiceOperationDisplay struct {
	// The localized operation description
	Description *string `json:"description,omitempty"`

	// The localized operation name
	Operation *string `json:"operation,omitempty"`

	// The localized resource provider name
	Provider *string `json:"provider,omitempty"`

	// The localized resource type name
	Resource *string `json:"resource,omitempty"`
}

// ServiceOperationList - OData page of action (operation) objects
type ServiceOperationList struct {
	// URL to load the next page of actions
	NextLink *string `json:"nextLink,omitempty"`

	// List of actions
	Value []*ServiceOperation `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceOperationList.
func (s ServiceOperationList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// ServiceProperties - Properties of the Database Migration Service instance
type ServiceProperties struct {
	// The time delay before the service is auto-stopped when idle.
	AutoStopDelay *string `json:"autoStopDelay,omitempty"`

	// Whether service resources should be deleted when stopped. (Turned on by default)
	DeleteResourcesOnStop *bool `json:"deleteResourcesOnStop,omitempty"`

	// The public key of the service, used to encrypt secrets sent to the service
	PublicKey *string `json:"publicKey,omitempty"`

	// The ID of the Microsoft.Network/networkInterfaces resource which the service have
	VirtualNicID *string `json:"virtualNicId,omitempty"`

	// The ID of the Microsoft.Network/virtualNetworks/subnets resource to which the service should be joined
	VirtualSubnetID *string `json:"virtualSubnetId,omitempty"`

	// READ-ONLY; The resource's provisioning state
	ProvisioningState *ServiceProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// ServiceSKU - An Azure SKU instance
type ServiceSKU struct {
	// The capacity of the SKU, if it supports scaling
	Capacity *int32 `json:"capacity,omitempty"`

	// The SKU family, used when the service has multiple performance classes within a tier, such as 'A', 'D', etc. for virtual
	// machines
	Family *string `json:"family,omitempty"`

	// The unique name of the SKU, such as 'P3'
	Name *string `json:"name,omitempty"`

	// The size of the SKU, used when the name alone does not denote a service size or when a SKU has multiple performance classes
	// within a family, e.g. 'A1' for virtual machines
	Size *string `json:"size,omitempty"`

	// The tier of the SKU, such as 'Basic', 'General Purpose', or 'Business Critical'
	Tier *string `json:"tier,omitempty"`
}

// ServiceSKUList - OData page of available SKUs
type ServiceSKUList struct {
	// URL to load the next page of service SKUs
	NextLink *string `json:"nextLink,omitempty"`

	// List of service SKUs
	Value []*AvailableServiceSKU `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceSKUList.
func (s ServiceSKUList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// ServiceStatusResponse - Service health status
type ServiceStatusResponse struct {
	// Agent Configuration
	AgentConfiguration map[string]interface{} `json:"agentConfiguration,omitempty"`

	// The DMS instance agent version
	AgentVersion *string `json:"agentVersion,omitempty"`

	// The machine-readable status, such as 'Initializing', 'Offline', 'Online', 'Deploying', 'Deleting', 'Stopped', 'Stopping',
	// 'Starting', 'FailedToStart', 'FailedToStop' or 'Failed'
	Status *string `json:"status,omitempty"`

	// The list of supported task types
	SupportedTaskTypes []*string `json:"supportedTaskTypes,omitempty"`

	// The services virtual machine size, such as 'StandardD2v2'
	VMSize *string `json:"vmSize,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceStatusResponse.
func (s ServiceStatusResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentConfiguration", s.AgentConfiguration)
	populate(objectMap, "agentVersion", s.AgentVersion)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "supportedTaskTypes", s.SupportedTaskTypes)
	populate(objectMap, "vmSize", s.VMSize)
	return json.Marshal(objectMap)
}

// ServiceTasksClientCancelOptions contains the optional parameters for the ServiceTasksClient.Cancel method.
type ServiceTasksClientCancelOptions struct {
	// placeholder for future optional parameters
}

// ServiceTasksClientCreateOrUpdateOptions contains the optional parameters for the ServiceTasksClient.CreateOrUpdate method.
type ServiceTasksClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ServiceTasksClientDeleteOptions contains the optional parameters for the ServiceTasksClient.Delete method.
type ServiceTasksClientDeleteOptions struct {
	// Delete the resource even if it contains running tasks
	DeleteRunningTasks *bool
}

// ServiceTasksClientGetOptions contains the optional parameters for the ServiceTasksClient.Get method.
type ServiceTasksClientGetOptions struct {
	// Expand the response
	Expand *string
}

// ServiceTasksClientListOptions contains the optional parameters for the ServiceTasksClient.List method.
type ServiceTasksClientListOptions struct {
	// Filter tasks by task type
	TaskType *string
}

// ServiceTasksClientUpdateOptions contains the optional parameters for the ServiceTasksClient.Update method.
type ServiceTasksClientUpdateOptions struct {
	// placeholder for future optional parameters
}

// ServicesClientBeginCreateOrUpdateOptions contains the optional parameters for the ServicesClient.BeginCreateOrUpdate method.
type ServicesClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ServicesClientBeginDeleteOptions contains the optional parameters for the ServicesClient.BeginDelete method.
type ServicesClientBeginDeleteOptions struct {
	// Delete the resource even if it contains running tasks
	DeleteRunningTasks *bool
}

// ServicesClientBeginStartOptions contains the optional parameters for the ServicesClient.BeginStart method.
type ServicesClientBeginStartOptions struct {
	// placeholder for future optional parameters
}

// ServicesClientBeginStopOptions contains the optional parameters for the ServicesClient.BeginStop method.
type ServicesClientBeginStopOptions struct {
	// placeholder for future optional parameters
}

// ServicesClientBeginUpdateOptions contains the optional parameters for the ServicesClient.BeginUpdate method.
type ServicesClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// ServicesClientCheckChildrenNameAvailabilityOptions contains the optional parameters for the ServicesClient.CheckChildrenNameAvailability
// method.
type ServicesClientCheckChildrenNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// ServicesClientCheckNameAvailabilityOptions contains the optional parameters for the ServicesClient.CheckNameAvailability
// method.
type ServicesClientCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// ServicesClientCheckStatusOptions contains the optional parameters for the ServicesClient.CheckStatus method.
type ServicesClientCheckStatusOptions struct {
	// placeholder for future optional parameters
}

// ServicesClientGetOptions contains the optional parameters for the ServicesClient.Get method.
type ServicesClientGetOptions struct {
	// placeholder for future optional parameters
}

// ServicesClientListByResourceGroupOptions contains the optional parameters for the ServicesClient.ListByResourceGroup method.
type ServicesClientListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// ServicesClientListOptions contains the optional parameters for the ServicesClient.List method.
type ServicesClientListOptions struct {
	// placeholder for future optional parameters
}

// ServicesClientListSKUsOptions contains the optional parameters for the ServicesClient.ListSKUs method.
type ServicesClientListSKUsOptions struct {
	// placeholder for future optional parameters
}

// SourceLocation - Source Location details of backups.
type SourceLocation struct {
	// Source Azure Blob.
	AzureBlob *AzureBlob `json:"azureBlob,omitempty"`

	// Source File share.
	FileShare *SQLFileShare `json:"fileShare,omitempty"`

	// READ-ONLY; Backup storage Type.
	FileStorageType *string `json:"fileStorageType,omitempty" azure:"ro"`
}

// SsisMigrationInfo - SSIS migration info with SSIS store type, overwrite policy.
type SsisMigrationInfo struct {
	// The overwrite option for the SSIS environment migration
	EnvironmentOverwriteOption *SsisMigrationOverwriteOption `json:"environmentOverwriteOption,omitempty"`

	// The overwrite option for the SSIS project migration
	ProjectOverwriteOption *SsisMigrationOverwriteOption `json:"projectOverwriteOption,omitempty"`

	// The SSIS store type of source, only SSIS catalog is supported now in DMS
	SsisStoreType *SsisStoreType `json:"ssisStoreType,omitempty"`
}

// StartMigrationScenarioServerRoleResult - Server role migration result
type StartMigrationScenarioServerRoleResult struct {
	// READ-ONLY; Migration exceptions and warnings.
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Name of server role.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StartMigrationScenarioServerRoleResult.
func (s StartMigrationScenarioServerRoleResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "exceptionsAndWarnings", s.ExceptionsAndWarnings)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "state", s.State)
	return json.Marshal(objectMap)
}

// SyncMigrationDatabaseErrorEvent - Database migration errors for online migration
type SyncMigrationDatabaseErrorEvent struct {
	// READ-ONLY; Event text.
	EventText *string `json:"eventText,omitempty" azure:"ro"`

	// READ-ONLY; Event type.
	EventTypeString *string `json:"eventTypeString,omitempty" azure:"ro"`

	// READ-ONLY; String value of timestamp.
	TimestampString *string `json:"timestampString,omitempty" azure:"ro"`
}

type SystemData struct {
	CreatedAt          *time.Time     `json:"createdAt,omitempty"`
	CreatedBy          *string        `json:"createdBy,omitempty"`
	CreatedByType      *CreatedByType `json:"createdByType,omitempty"`
	LastModifiedAt     *time.Time     `json:"lastModifiedAt,omitempty"`
	LastModifiedBy     *string        `json:"lastModifiedBy,omitempty"`
	LastModifiedByType *CreatedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TargetLocation - Target Location details for optional copy of backups
type TargetLocation struct {
	// Storage Account Key.
	AccountKey *string `json:"accountKey,omitempty"`

	// Resource Id of the storage account copying backups.
	StorageAccountResourceID *string `json:"storageAccountResourceId,omitempty"`
}

// TaskList - OData page of tasks
type TaskList struct {
	// URL to load the next page of tasks
	NextLink *string `json:"nextLink,omitempty"`

	// List of tasks
	Value []*ProjectTask `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TaskList.
func (t TaskList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TasksClientCancelOptions contains the optional parameters for the TasksClient.Cancel method.
type TasksClientCancelOptions struct {
	// placeholder for future optional parameters
}

// TasksClientCommandOptions contains the optional parameters for the TasksClient.Command method.
type TasksClientCommandOptions struct {
	// placeholder for future optional parameters
}

// TasksClientCreateOrUpdateOptions contains the optional parameters for the TasksClient.CreateOrUpdate method.
type TasksClientCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// TasksClientDeleteOptions contains the optional parameters for the TasksClient.Delete method.
type TasksClientDeleteOptions struct {
	// Delete the resource even if it contains running tasks
	DeleteRunningTasks *bool
}

// TasksClientGetOptions contains the optional parameters for the TasksClient.Get method.
type TasksClientGetOptions struct {
	// Expand the response
	Expand *string
}

// TasksClientListOptions contains the optional parameters for the TasksClient.List method.
type TasksClientListOptions struct {
	// Filter tasks by task type
	TaskType *string
}

// TasksClientUpdateOptions contains the optional parameters for the TasksClient.Update method.
type TasksClientUpdateOptions struct {
	// placeholder for future optional parameters
}

type TrackedResource struct {
	Location *string `json:"location,omitempty"`

	// Dictionary of
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`

	// READ-ONLY
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

// UploadOCIDriverTaskInput - Input for the service task to upload an OCI driver.
type UploadOCIDriverTaskInput struct {
	// File share information for the OCI driver archive.
	DriverShare *FileShare `json:"driverShare,omitempty"`
}

// UploadOCIDriverTaskOutput - Output for the service task to upload an OCI driver.
type UploadOCIDriverTaskOutput struct {
	// READ-ONLY; The name of the driver package that was validated and uploaded.
	DriverPackageName *string `json:"driverPackageName,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type UploadOCIDriverTaskOutput.
func (u UploadOCIDriverTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "driverPackageName", u.DriverPackageName)
	populate(objectMap, "validationErrors", u.ValidationErrors)
	return json.Marshal(objectMap)
}

// UploadOCIDriverTaskProperties - Properties for the task that uploads an OCI driver.
type UploadOCIDriverTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Input for the service task to upload an OCI driver.
	Input *UploadOCIDriverTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*UploadOCIDriverTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type UploadOCIDriverTaskProperties.
func (u *UploadOCIDriverTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   u.TaskType,
		Errors:     u.Errors,
		State:      u.State,
		Commands:   u.Commands,
		ClientData: u.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type UploadOCIDriverTaskProperties.
func (u UploadOCIDriverTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", u.ClientData)
	populate(objectMap, "commands", u.Commands)
	populate(objectMap, "errors", u.Errors)
	populate(objectMap, "input", u.Input)
	populate(objectMap, "output", u.Output)
	populate(objectMap, "state", u.State)
	objectMap["taskType"] = TaskTypeServiceUploadOCI
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UploadOCIDriverTaskProperties.
func (u *UploadOCIDriverTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &u.ClientData)
			delete(rawMsg, key)
		case "commands":
			u.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &u.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &u.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &u.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &u.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &u.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// UsagesClientListOptions contains the optional parameters for the UsagesClient.List method.
type UsagesClientListOptions struct {
	// placeholder for future optional parameters
}

// ValidateMigrationInputSQLServerSQLDbSyncTaskProperties - Properties for task that validates migration input for SQL to
// Azure SQL DB sync migrations
type ValidateMigrationInputSQLServerSQLDbSyncTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *ValidateSyncMigrationInputSQLServerTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ValidateSyncMigrationInputSQLServerTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ValidateMigrationInputSQLServerSQLDbSyncTaskProperties.
func (v *ValidateMigrationInputSQLServerSQLDbSyncTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   v.TaskType,
		Errors:     v.Errors,
		State:      v.State,
		Commands:   v.Commands,
		ClientData: v.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ValidateMigrationInputSQLServerSQLDbSyncTaskProperties.
func (v ValidateMigrationInputSQLServerSQLDbSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", v.ClientData)
	populate(objectMap, "commands", v.Commands)
	populate(objectMap, "errors", v.Errors)
	populate(objectMap, "input", v.Input)
	populate(objectMap, "output", v.Output)
	populate(objectMap, "state", v.State)
	objectMap["taskType"] = TaskTypeValidateMigrationInputSQLServerSQLDbSync
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateMigrationInputSQLServerSQLDbSyncTaskProperties.
func (v *ValidateMigrationInputSQLServerSQLDbSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &v.ClientData)
			delete(rawMsg, key)
		case "commands":
			v.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &v.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &v.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &v.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &v.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &v.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ValidateMigrationInputSQLServerSQLMISyncTaskInput - Input for task that migrates SQL Server databases to Azure SQL Database
// Managed Instance online scenario.
type ValidateMigrationInputSQLServerSQLMISyncTaskInput struct {
	// REQUIRED; Azure Active Directory Application the DMS instance will use to connect to the target instance of Azure SQL Database
	// Managed Instance and the Azure Storage Account
	AzureApp *AzureActiveDirectoryApp `json:"azureApp,omitempty"`

	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateSQLServerSQLMIDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Connection information for source SQL Server
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Fully qualified resourceId of storage
	StorageResourceID *string `json:"storageResourceId,omitempty"`

	// REQUIRED; Connection information for Azure SQL Database Managed Instance
	TargetConnectionInfo *MiSQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// Backup file share information for all selected databases.
	BackupFileShare *FileShare `json:"backupFileShare,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateMigrationInputSQLServerSQLMISyncTaskInput.
func (v ValidateMigrationInputSQLServerSQLMISyncTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "azureApp", v.AzureApp)
	populate(objectMap, "backupFileShare", v.BackupFileShare)
	populate(objectMap, "selectedDatabases", v.SelectedDatabases)
	populate(objectMap, "sourceConnectionInfo", v.SourceConnectionInfo)
	populate(objectMap, "storageResourceId", v.StorageResourceID)
	populate(objectMap, "targetConnectionInfo", v.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// ValidateMigrationInputSQLServerSQLMISyncTaskOutput - Output for task that validates migration input for Azure SQL Database
// Managed Instance online migration
type ValidateMigrationInputSQLServerSQLMISyncTaskOutput struct {
	// READ-ONLY; Database identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of database
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Errors associated with a selected database object
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateMigrationInputSQLServerSQLMISyncTaskOutput.
func (v ValidateMigrationInputSQLServerSQLMISyncTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "validationErrors", v.ValidationErrors)
	return json.Marshal(objectMap)
}

// ValidateMigrationInputSQLServerSQLMISyncTaskProperties - Properties for task that validates migration input for SQL to
// Azure SQL Database Managed Instance sync scenario
type ValidateMigrationInputSQLServerSQLMISyncTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *ValidateMigrationInputSQLServerSQLMISyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ValidateMigrationInputSQLServerSQLMISyncTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ValidateMigrationInputSQLServerSQLMISyncTaskProperties.
func (v *ValidateMigrationInputSQLServerSQLMISyncTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   v.TaskType,
		Errors:     v.Errors,
		State:      v.State,
		Commands:   v.Commands,
		ClientData: v.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ValidateMigrationInputSQLServerSQLMISyncTaskProperties.
func (v ValidateMigrationInputSQLServerSQLMISyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", v.ClientData)
	populate(objectMap, "commands", v.Commands)
	populate(objectMap, "errors", v.Errors)
	populate(objectMap, "input", v.Input)
	populate(objectMap, "output", v.Output)
	populate(objectMap, "state", v.State)
	objectMap["taskType"] = TaskTypeValidateMigrationInputSQLServerAzureSQLDbMISyncLRS
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateMigrationInputSQLServerSQLMISyncTaskProperties.
func (v *ValidateMigrationInputSQLServerSQLMISyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &v.ClientData)
			delete(rawMsg, key)
		case "commands":
			v.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &v.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &v.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &v.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &v.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &v.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ValidateMigrationInputSQLServerSQLMITaskInput - Input for task that validates migration input for SQL to Azure SQL Managed
// Instance
type ValidateMigrationInputSQLServerSQLMITaskInput struct {
	// REQUIRED; SAS URI of Azure Storage Account Container to be used for storing backup files.
	BackupBlobShare *BlobShare `json:"backupBlobShare,omitempty"`

	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateSQLServerSQLMIDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Information for connecting to source
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Information for connecting to target
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// Backup file share information for all selected databases.
	BackupFileShare *FileShare `json:"backupFileShare,omitempty"`

	// Backup Mode to specify whether to use existing backup or create new backup.
	BackupMode *BackupMode `json:"backupMode,omitempty"`

	// Logins to migrate
	SelectedLogins []*string `json:"selectedLogins,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateMigrationInputSQLServerSQLMITaskInput.
func (v ValidateMigrationInputSQLServerSQLMITaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupBlobShare", v.BackupBlobShare)
	populate(objectMap, "backupFileShare", v.BackupFileShare)
	populate(objectMap, "backupMode", v.BackupMode)
	populate(objectMap, "selectedDatabases", v.SelectedDatabases)
	populate(objectMap, "selectedLogins", v.SelectedLogins)
	populate(objectMap, "sourceConnectionInfo", v.SourceConnectionInfo)
	populate(objectMap, "targetConnectionInfo", v.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// ValidateMigrationInputSQLServerSQLMITaskOutput - Output for task that validates migration input for SQL to Azure SQL Managed
// Instance migrations
type ValidateMigrationInputSQLServerSQLMITaskOutput struct {
	// Information about backup files when existing backup mode is used.
	DatabaseBackupInfo *DatabaseBackupInfo `json:"databaseBackupInfo,omitempty"`

	// READ-ONLY; Errors associated with the BackupFolder path
	BackupFolderErrors []*ReportableException `json:"backupFolderErrors,omitempty" azure:"ro"`

	// READ-ONLY; Errors associated with backup share user name and password credentials
	BackupShareCredentialsErrors []*ReportableException `json:"backupShareCredentialsErrors,omitempty" azure:"ro"`

	// READ-ONLY; Errors associated with the storage account provided.
	BackupStorageAccountErrors []*ReportableException `json:"backupStorageAccountErrors,omitempty" azure:"ro"`

	// READ-ONLY; Errors associated with existing backup files.
	ExistingBackupErrors []*ReportableException `json:"existingBackupErrors,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of database
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Errors associated with the RestoreDatabaseName
	RestoreDatabaseNameErrors []*ReportableException `json:"restoreDatabaseNameErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateMigrationInputSQLServerSQLMITaskOutput.
func (v ValidateMigrationInputSQLServerSQLMITaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupFolderErrors", v.BackupFolderErrors)
	populate(objectMap, "backupShareCredentialsErrors", v.BackupShareCredentialsErrors)
	populate(objectMap, "backupStorageAccountErrors", v.BackupStorageAccountErrors)
	populate(objectMap, "databaseBackupInfo", v.DatabaseBackupInfo)
	populate(objectMap, "existingBackupErrors", v.ExistingBackupErrors)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "restoreDatabaseNameErrors", v.RestoreDatabaseNameErrors)
	return json.Marshal(objectMap)
}

// ValidateMigrationInputSQLServerSQLMITaskProperties - Properties for task that validates migration input for SQL to Azure
// SQL Database Managed Instance
type ValidateMigrationInputSQLServerSQLMITaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Task input
	Input *ValidateMigrationInputSQLServerSQLMITaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ValidateMigrationInputSQLServerSQLMITaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ValidateMigrationInputSQLServerSQLMITaskProperties.
func (v *ValidateMigrationInputSQLServerSQLMITaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   v.TaskType,
		Errors:     v.Errors,
		State:      v.State,
		Commands:   v.Commands,
		ClientData: v.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ValidateMigrationInputSQLServerSQLMITaskProperties.
func (v ValidateMigrationInputSQLServerSQLMITaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", v.ClientData)
	populate(objectMap, "commands", v.Commands)
	populate(objectMap, "errors", v.Errors)
	populate(objectMap, "input", v.Input)
	populate(objectMap, "output", v.Output)
	populate(objectMap, "state", v.State)
	objectMap["taskType"] = TaskTypeValidateMigrationInputSQLServerAzureSQLDbMI
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateMigrationInputSQLServerSQLMITaskProperties.
func (v *ValidateMigrationInputSQLServerSQLMITaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &v.ClientData)
			delete(rawMsg, key)
		case "commands":
			v.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &v.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &v.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &v.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &v.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &v.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ValidateMongoDbTaskProperties - Properties for the task that validates a migration between MongoDB data sources
type ValidateMongoDbTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Describes how a MongoDB data migration should be performed
	Input *MongoDbMigrationSettings `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; An array containing a single MongoDbMigrationProgress object
	Output []*MongoDbMigrationProgress `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ValidateMongoDbTaskProperties.
func (v *ValidateMongoDbTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   v.TaskType,
		Errors:     v.Errors,
		State:      v.State,
		Commands:   v.Commands,
		ClientData: v.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ValidateMongoDbTaskProperties.
func (v ValidateMongoDbTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", v.ClientData)
	populate(objectMap, "commands", v.Commands)
	populate(objectMap, "errors", v.Errors)
	populate(objectMap, "input", v.Input)
	populate(objectMap, "output", v.Output)
	populate(objectMap, "state", v.State)
	objectMap["taskType"] = TaskTypeValidateMongoDb
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateMongoDbTaskProperties.
func (v *ValidateMongoDbTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &v.ClientData)
			delete(rawMsg, key)
		case "commands":
			v.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &v.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &v.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &v.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &v.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &v.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ValidateOracleAzureDbForPostgreSQLSyncTaskProperties - Properties for the task that validates a migration for Oracle to
// Azure Database for PostgreSQL for online migrations
type ValidateOracleAzureDbForPostgreSQLSyncTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *TaskType `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// Input for the task that migrates Oracle databases to Azure Database for PostgreSQL for online migrations
	Input *MigrateOracleAzureDbPostgreSQLSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; An array containing a single validation error response object
	Output []*ValidateOracleAzureDbPostgreSQLSyncTaskOutput `json:"output,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ValidateOracleAzureDbForPostgreSQLSyncTaskProperties.
func (v *ValidateOracleAzureDbForPostgreSQLSyncTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties {
	return &ProjectTaskProperties{
		TaskType:   v.TaskType,
		Errors:     v.Errors,
		State:      v.State,
		Commands:   v.Commands,
		ClientData: v.ClientData,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ValidateOracleAzureDbForPostgreSQLSyncTaskProperties.
func (v ValidateOracleAzureDbForPostgreSQLSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientData", v.ClientData)
	populate(objectMap, "commands", v.Commands)
	populate(objectMap, "errors", v.Errors)
	populate(objectMap, "input", v.Input)
	populate(objectMap, "output", v.Output)
	populate(objectMap, "state", v.State)
	objectMap["taskType"] = TaskTypeValidateOracleAzureDbPostgreSQLSync
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateOracleAzureDbForPostgreSQLSyncTaskProperties.
func (v *ValidateOracleAzureDbForPostgreSQLSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &v.ClientData)
			delete(rawMsg, key)
		case "commands":
			v.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &v.Errors)
			delete(rawMsg, key)
		case "input":
			err = unpopulate(val, &v.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &v.Output)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &v.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &v.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ValidateOracleAzureDbPostgreSQLSyncTaskOutput - Output for task that validates migration input for Oracle to Azure Database
// for PostgreSQL for online migrations
type ValidateOracleAzureDbPostgreSQLSyncTaskOutput struct {
	// READ-ONLY; Errors associated with a selected database object
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateOracleAzureDbPostgreSQLSyncTaskOutput.
func (v ValidateOracleAzureDbPostgreSQLSyncTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "validationErrors", v.ValidationErrors)
	return json.Marshal(objectMap)
}

// ValidateSyncMigrationInputSQLServerTaskInput - Input for task that validates migration input for SQL sync migrations
type ValidateSyncMigrationInputSQLServerTaskInput struct {
	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateSQLServerSQLDbSyncDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Information for connecting to source SQL server
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Information for connecting to target
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateSyncMigrationInputSQLServerTaskInput.
func (v ValidateSyncMigrationInputSQLServerTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "selectedDatabases", v.SelectedDatabases)
	populate(objectMap, "sourceConnectionInfo", v.SourceConnectionInfo)
	populate(objectMap, "targetConnectionInfo", v.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// ValidateSyncMigrationInputSQLServerTaskOutput - Output for task that validates migration input for SQL sync migrations
type ValidateSyncMigrationInputSQLServerTaskOutput struct {
	// READ-ONLY; Database identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of database
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Errors associated with a selected database object
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateSyncMigrationInputSQLServerTaskOutput.
func (v ValidateSyncMigrationInputSQLServerTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "validationErrors", v.ValidationErrors)
	return json.Marshal(objectMap)
}

// ValidationError - Description about the errors happen while performing migration validation
type ValidationError struct {
	// Severity of the error
	Severity *Severity `json:"severity,omitempty"`

	// Error Text
	Text *string `json:"text,omitempty"`
}

// WaitStatistics - Wait statistics gathered during query batch execution
type WaitStatistics struct {
	// Total no. of waits
	WaitCount *int64 `json:"waitCount,omitempty"`

	// Total wait time in millisecond(s)
	WaitTimeMs *float32 `json:"waitTimeMs,omitempty"`

	// Type of the Wait
	WaitType *string `json:"waitType,omitempty"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
