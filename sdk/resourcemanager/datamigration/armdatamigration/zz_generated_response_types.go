//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdatamigration

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// DatabaseMigrationsSQLDbClientCancelPollerResponse contains the response from method DatabaseMigrationsSQLDbClient.Cancel.
type DatabaseMigrationsSQLDbClientCancelPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseMigrationsSQLDbClientCancelPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseMigrationsSQLDbClientCancelPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseMigrationsSQLDbClientCancelResponse, error) {
	respType := DatabaseMigrationsSQLDbClientCancelResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseMigrationsSQLDbClientCancelPollerResponse from the provided client and resume token.
func (l *DatabaseMigrationsSQLDbClientCancelPollerResponse) Resume(ctx context.Context, client *DatabaseMigrationsSQLDbClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseMigrationsSQLDbClient.Cancel", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DatabaseMigrationsSQLDbClientCancelPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseMigrationsSQLDbClientCancelResponse contains the response from method DatabaseMigrationsSQLDbClient.Cancel.
type DatabaseMigrationsSQLDbClientCancelResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseMigrationsSQLDbClientCreateOrUpdatePollerResponse contains the response from method DatabaseMigrationsSQLDbClient.CreateOrUpdate.
type DatabaseMigrationsSQLDbClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseMigrationsSQLDbClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseMigrationsSQLDbClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseMigrationsSQLDbClientCreateOrUpdateResponse, error) {
	respType := DatabaseMigrationsSQLDbClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DatabaseMigrationSQLDb)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseMigrationsSQLDbClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DatabaseMigrationsSQLDbClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DatabaseMigrationsSQLDbClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseMigrationsSQLDbClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DatabaseMigrationsSQLDbClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseMigrationsSQLDbClientCreateOrUpdateResponse contains the response from method DatabaseMigrationsSQLDbClient.CreateOrUpdate.
type DatabaseMigrationsSQLDbClientCreateOrUpdateResponse struct {
	DatabaseMigrationsSQLDbClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseMigrationsSQLDbClientCreateOrUpdateResult contains the result from method DatabaseMigrationsSQLDbClient.CreateOrUpdate.
type DatabaseMigrationsSQLDbClientCreateOrUpdateResult struct {
	DatabaseMigrationSQLDb
}

// DatabaseMigrationsSQLDbClientDeletePollerResponse contains the response from method DatabaseMigrationsSQLDbClient.Delete.
type DatabaseMigrationsSQLDbClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseMigrationsSQLDbClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseMigrationsSQLDbClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseMigrationsSQLDbClientDeleteResponse, error) {
	respType := DatabaseMigrationsSQLDbClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseMigrationsSQLDbClientDeletePollerResponse from the provided client and resume token.
func (l *DatabaseMigrationsSQLDbClientDeletePollerResponse) Resume(ctx context.Context, client *DatabaseMigrationsSQLDbClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseMigrationsSQLDbClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DatabaseMigrationsSQLDbClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseMigrationsSQLDbClientDeleteResponse contains the response from method DatabaseMigrationsSQLDbClient.Delete.
type DatabaseMigrationsSQLDbClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseMigrationsSQLDbClientGetResponse contains the response from method DatabaseMigrationsSQLDbClient.Get.
type DatabaseMigrationsSQLDbClientGetResponse struct {
	DatabaseMigrationsSQLDbClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseMigrationsSQLDbClientGetResult contains the result from method DatabaseMigrationsSQLDbClient.Get.
type DatabaseMigrationsSQLDbClientGetResult struct {
	DatabaseMigrationSQLDb
}

// DatabaseMigrationsSQLMiClientCancelPollerResponse contains the response from method DatabaseMigrationsSQLMiClient.Cancel.
type DatabaseMigrationsSQLMiClientCancelPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseMigrationsSQLMiClientCancelPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseMigrationsSQLMiClientCancelPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseMigrationsSQLMiClientCancelResponse, error) {
	respType := DatabaseMigrationsSQLMiClientCancelResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseMigrationsSQLMiClientCancelPollerResponse from the provided client and resume token.
func (l *DatabaseMigrationsSQLMiClientCancelPollerResponse) Resume(ctx context.Context, client *DatabaseMigrationsSQLMiClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseMigrationsSQLMiClient.Cancel", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DatabaseMigrationsSQLMiClientCancelPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseMigrationsSQLMiClientCancelResponse contains the response from method DatabaseMigrationsSQLMiClient.Cancel.
type DatabaseMigrationsSQLMiClientCancelResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseMigrationsSQLMiClientCreateOrUpdatePollerResponse contains the response from method DatabaseMigrationsSQLMiClient.CreateOrUpdate.
type DatabaseMigrationsSQLMiClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseMigrationsSQLMiClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseMigrationsSQLMiClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseMigrationsSQLMiClientCreateOrUpdateResponse, error) {
	respType := DatabaseMigrationsSQLMiClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DatabaseMigrationSQLMi)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseMigrationsSQLMiClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DatabaseMigrationsSQLMiClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DatabaseMigrationsSQLMiClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseMigrationsSQLMiClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DatabaseMigrationsSQLMiClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseMigrationsSQLMiClientCreateOrUpdateResponse contains the response from method DatabaseMigrationsSQLMiClient.CreateOrUpdate.
type DatabaseMigrationsSQLMiClientCreateOrUpdateResponse struct {
	DatabaseMigrationsSQLMiClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseMigrationsSQLMiClientCreateOrUpdateResult contains the result from method DatabaseMigrationsSQLMiClient.CreateOrUpdate.
type DatabaseMigrationsSQLMiClientCreateOrUpdateResult struct {
	DatabaseMigrationSQLMi
}

// DatabaseMigrationsSQLMiClientCutoverPollerResponse contains the response from method DatabaseMigrationsSQLMiClient.Cutover.
type DatabaseMigrationsSQLMiClientCutoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseMigrationsSQLMiClientCutoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseMigrationsSQLMiClientCutoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseMigrationsSQLMiClientCutoverResponse, error) {
	respType := DatabaseMigrationsSQLMiClientCutoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseMigrationsSQLMiClientCutoverPollerResponse from the provided client and resume token.
func (l *DatabaseMigrationsSQLMiClientCutoverPollerResponse) Resume(ctx context.Context, client *DatabaseMigrationsSQLMiClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseMigrationsSQLMiClient.Cutover", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DatabaseMigrationsSQLMiClientCutoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseMigrationsSQLMiClientCutoverResponse contains the response from method DatabaseMigrationsSQLMiClient.Cutover.
type DatabaseMigrationsSQLMiClientCutoverResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseMigrationsSQLMiClientGetResponse contains the response from method DatabaseMigrationsSQLMiClient.Get.
type DatabaseMigrationsSQLMiClientGetResponse struct {
	DatabaseMigrationsSQLMiClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseMigrationsSQLMiClientGetResult contains the result from method DatabaseMigrationsSQLMiClient.Get.
type DatabaseMigrationsSQLMiClientGetResult struct {
	DatabaseMigrationSQLMi
}

// DatabaseMigrationsSQLVMClientCancelPollerResponse contains the response from method DatabaseMigrationsSQLVMClient.Cancel.
type DatabaseMigrationsSQLVMClientCancelPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseMigrationsSQLVMClientCancelPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseMigrationsSQLVMClientCancelPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseMigrationsSQLVMClientCancelResponse, error) {
	respType := DatabaseMigrationsSQLVMClientCancelResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseMigrationsSQLVMClientCancelPollerResponse from the provided client and resume token.
func (l *DatabaseMigrationsSQLVMClientCancelPollerResponse) Resume(ctx context.Context, client *DatabaseMigrationsSQLVMClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseMigrationsSQLVMClient.Cancel", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DatabaseMigrationsSQLVMClientCancelPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseMigrationsSQLVMClientCancelResponse contains the response from method DatabaseMigrationsSQLVMClient.Cancel.
type DatabaseMigrationsSQLVMClientCancelResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseMigrationsSQLVMClientCreateOrUpdatePollerResponse contains the response from method DatabaseMigrationsSQLVMClient.CreateOrUpdate.
type DatabaseMigrationsSQLVMClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseMigrationsSQLVMClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseMigrationsSQLVMClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseMigrationsSQLVMClientCreateOrUpdateResponse, error) {
	respType := DatabaseMigrationsSQLVMClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DatabaseMigrationSQLVM)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseMigrationsSQLVMClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DatabaseMigrationsSQLVMClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DatabaseMigrationsSQLVMClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseMigrationsSQLVMClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DatabaseMigrationsSQLVMClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseMigrationsSQLVMClientCreateOrUpdateResponse contains the response from method DatabaseMigrationsSQLVMClient.CreateOrUpdate.
type DatabaseMigrationsSQLVMClientCreateOrUpdateResponse struct {
	DatabaseMigrationsSQLVMClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseMigrationsSQLVMClientCreateOrUpdateResult contains the result from method DatabaseMigrationsSQLVMClient.CreateOrUpdate.
type DatabaseMigrationsSQLVMClientCreateOrUpdateResult struct {
	DatabaseMigrationSQLVM
}

// DatabaseMigrationsSQLVMClientCutoverPollerResponse contains the response from method DatabaseMigrationsSQLVMClient.Cutover.
type DatabaseMigrationsSQLVMClientCutoverPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DatabaseMigrationsSQLVMClientCutoverPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DatabaseMigrationsSQLVMClientCutoverPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DatabaseMigrationsSQLVMClientCutoverResponse, error) {
	respType := DatabaseMigrationsSQLVMClientCutoverResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DatabaseMigrationsSQLVMClientCutoverPollerResponse from the provided client and resume token.
func (l *DatabaseMigrationsSQLVMClientCutoverPollerResponse) Resume(ctx context.Context, client *DatabaseMigrationsSQLVMClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DatabaseMigrationsSQLVMClient.Cutover", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DatabaseMigrationsSQLVMClientCutoverPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DatabaseMigrationsSQLVMClientCutoverResponse contains the response from method DatabaseMigrationsSQLVMClient.Cutover.
type DatabaseMigrationsSQLVMClientCutoverResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseMigrationsSQLVMClientGetResponse contains the response from method DatabaseMigrationsSQLVMClient.Get.
type DatabaseMigrationsSQLVMClientGetResponse struct {
	DatabaseMigrationsSQLVMClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DatabaseMigrationsSQLVMClientGetResult contains the result from method DatabaseMigrationsSQLVMClient.Get.
type DatabaseMigrationsSQLVMClientGetResult struct {
	DatabaseMigrationSQLVM
}

// FilesClientCreateOrUpdateResponse contains the response from method FilesClient.CreateOrUpdate.
type FilesClientCreateOrUpdateResponse struct {
	FilesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FilesClientCreateOrUpdateResult contains the result from method FilesClient.CreateOrUpdate.
type FilesClientCreateOrUpdateResult struct {
	ProjectFile
}

// FilesClientDeleteResponse contains the response from method FilesClient.Delete.
type FilesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FilesClientGetResponse contains the response from method FilesClient.Get.
type FilesClientGetResponse struct {
	FilesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FilesClientGetResult contains the result from method FilesClient.Get.
type FilesClientGetResult struct {
	ProjectFile
}

// FilesClientListResponse contains the response from method FilesClient.List.
type FilesClientListResponse struct {
	FilesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FilesClientListResult contains the result from method FilesClient.List.
type FilesClientListResult struct {
	FileList
}

// FilesClientReadResponse contains the response from method FilesClient.Read.
type FilesClientReadResponse struct {
	FilesClientReadResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FilesClientReadResult contains the result from method FilesClient.Read.
type FilesClientReadResult struct {
	FileStorageInfo
}

// FilesClientReadWriteResponse contains the response from method FilesClient.ReadWrite.
type FilesClientReadWriteResponse struct {
	FilesClientReadWriteResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FilesClientReadWriteResult contains the result from method FilesClient.ReadWrite.
type FilesClientReadWriteResult struct {
	FileStorageInfo
}

// FilesClientUpdateResponse contains the response from method FilesClient.Update.
type FilesClientUpdateResponse struct {
	FilesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// FilesClientUpdateResult contains the result from method FilesClient.Update.
type FilesClientUpdateResult struct {
	ProjectFile
}

// OperationsClientListResponse contains the response from method OperationsClient.List.
type OperationsClientListResponse struct {
	OperationsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsClientListResult contains the result from method OperationsClient.List.
type OperationsClientListResult struct {
	OperationListResult
}

// ProjectsClientCreateOrUpdateResponse contains the response from method ProjectsClient.CreateOrUpdate.
type ProjectsClientCreateOrUpdateResponse struct {
	ProjectsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProjectsClientCreateOrUpdateResult contains the result from method ProjectsClient.CreateOrUpdate.
type ProjectsClientCreateOrUpdateResult struct {
	Project
}

// ProjectsClientDeleteResponse contains the response from method ProjectsClient.Delete.
type ProjectsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProjectsClientGetResponse contains the response from method ProjectsClient.Get.
type ProjectsClientGetResponse struct {
	ProjectsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProjectsClientGetResult contains the result from method ProjectsClient.Get.
type ProjectsClientGetResult struct {
	Project
}

// ProjectsClientListResponse contains the response from method ProjectsClient.List.
type ProjectsClientListResponse struct {
	ProjectsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProjectsClientListResult contains the result from method ProjectsClient.List.
type ProjectsClientListResult struct {
	ProjectList
}

// ProjectsClientUpdateResponse contains the response from method ProjectsClient.Update.
type ProjectsClientUpdateResponse struct {
	ProjectsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ProjectsClientUpdateResult contains the result from method ProjectsClient.Update.
type ProjectsClientUpdateResult struct {
	Project
}

// ResourceSKUsClientListSKUsResponse contains the response from method ResourceSKUsClient.ListSKUs.
type ResourceSKUsClientListSKUsResponse struct {
	ResourceSKUsClientListSKUsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ResourceSKUsClientListSKUsResult contains the result from method ResourceSKUsClient.ListSKUs.
type ResourceSKUsClientListSKUsResult struct {
	ResourceSKUsResult
}

// SQLMigrationServicesClientCreateOrUpdatePollerResponse contains the response from method SQLMigrationServicesClient.CreateOrUpdate.
type SQLMigrationServicesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLMigrationServicesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLMigrationServicesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLMigrationServicesClientCreateOrUpdateResponse, error) {
	respType := SQLMigrationServicesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SQLMigrationService)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLMigrationServicesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SQLMigrationServicesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SQLMigrationServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLMigrationServicesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SQLMigrationServicesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLMigrationServicesClientCreateOrUpdateResponse contains the response from method SQLMigrationServicesClient.CreateOrUpdate.
type SQLMigrationServicesClientCreateOrUpdateResponse struct {
	SQLMigrationServicesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLMigrationServicesClientCreateOrUpdateResult contains the result from method SQLMigrationServicesClient.CreateOrUpdate.
type SQLMigrationServicesClientCreateOrUpdateResult struct {
	SQLMigrationService
}

// SQLMigrationServicesClientDeleteNodeResponse contains the response from method SQLMigrationServicesClient.DeleteNode.
type SQLMigrationServicesClientDeleteNodeResponse struct {
	SQLMigrationServicesClientDeleteNodeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLMigrationServicesClientDeleteNodeResult contains the result from method SQLMigrationServicesClient.DeleteNode.
type SQLMigrationServicesClientDeleteNodeResult struct {
	DeleteNode
}

// SQLMigrationServicesClientDeletePollerResponse contains the response from method SQLMigrationServicesClient.Delete.
type SQLMigrationServicesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLMigrationServicesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLMigrationServicesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLMigrationServicesClientDeleteResponse, error) {
	respType := SQLMigrationServicesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLMigrationServicesClientDeletePollerResponse from the provided client and resume token.
func (l *SQLMigrationServicesClientDeletePollerResponse) Resume(ctx context.Context, client *SQLMigrationServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLMigrationServicesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SQLMigrationServicesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLMigrationServicesClientDeleteResponse contains the response from method SQLMigrationServicesClient.Delete.
type SQLMigrationServicesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLMigrationServicesClientGetResponse contains the response from method SQLMigrationServicesClient.Get.
type SQLMigrationServicesClientGetResponse struct {
	SQLMigrationServicesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLMigrationServicesClientGetResult contains the result from method SQLMigrationServicesClient.Get.
type SQLMigrationServicesClientGetResult struct {
	SQLMigrationService
}

// SQLMigrationServicesClientListAuthKeysResponse contains the response from method SQLMigrationServicesClient.ListAuthKeys.
type SQLMigrationServicesClientListAuthKeysResponse struct {
	SQLMigrationServicesClientListAuthKeysResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLMigrationServicesClientListAuthKeysResult contains the result from method SQLMigrationServicesClient.ListAuthKeys.
type SQLMigrationServicesClientListAuthKeysResult struct {
	AuthenticationKeys
}

// SQLMigrationServicesClientListByResourceGroupResponse contains the response from method SQLMigrationServicesClient.ListByResourceGroup.
type SQLMigrationServicesClientListByResourceGroupResponse struct {
	SQLMigrationServicesClientListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLMigrationServicesClientListByResourceGroupResult contains the result from method SQLMigrationServicesClient.ListByResourceGroup.
type SQLMigrationServicesClientListByResourceGroupResult struct {
	SQLMigrationListResult
}

// SQLMigrationServicesClientListBySubscriptionResponse contains the response from method SQLMigrationServicesClient.ListBySubscription.
type SQLMigrationServicesClientListBySubscriptionResponse struct {
	SQLMigrationServicesClientListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLMigrationServicesClientListBySubscriptionResult contains the result from method SQLMigrationServicesClient.ListBySubscription.
type SQLMigrationServicesClientListBySubscriptionResult struct {
	SQLMigrationListResult
}

// SQLMigrationServicesClientListMigrationsResponse contains the response from method SQLMigrationServicesClient.ListMigrations.
type SQLMigrationServicesClientListMigrationsResponse struct {
	SQLMigrationServicesClientListMigrationsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLMigrationServicesClientListMigrationsResult contains the result from method SQLMigrationServicesClient.ListMigrations.
type SQLMigrationServicesClientListMigrationsResult struct {
	DatabaseMigrationListResult
}

// SQLMigrationServicesClientListMonitoringDataResponse contains the response from method SQLMigrationServicesClient.ListMonitoringData.
type SQLMigrationServicesClientListMonitoringDataResponse struct {
	SQLMigrationServicesClientListMonitoringDataResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLMigrationServicesClientListMonitoringDataResult contains the result from method SQLMigrationServicesClient.ListMonitoringData.
type SQLMigrationServicesClientListMonitoringDataResult struct {
	IntegrationRuntimeMonitoringData
}

// SQLMigrationServicesClientRegenerateAuthKeysResponse contains the response from method SQLMigrationServicesClient.RegenerateAuthKeys.
type SQLMigrationServicesClientRegenerateAuthKeysResponse struct {
	SQLMigrationServicesClientRegenerateAuthKeysResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLMigrationServicesClientRegenerateAuthKeysResult contains the result from method SQLMigrationServicesClient.RegenerateAuthKeys.
type SQLMigrationServicesClientRegenerateAuthKeysResult struct {
	RegenAuthKeys
}

// SQLMigrationServicesClientUpdatePollerResponse contains the response from method SQLMigrationServicesClient.Update.
type SQLMigrationServicesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SQLMigrationServicesClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SQLMigrationServicesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SQLMigrationServicesClientUpdateResponse, error) {
	respType := SQLMigrationServicesClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SQLMigrationService)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SQLMigrationServicesClientUpdatePollerResponse from the provided client and resume token.
func (l *SQLMigrationServicesClientUpdatePollerResponse) Resume(ctx context.Context, client *SQLMigrationServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SQLMigrationServicesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SQLMigrationServicesClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SQLMigrationServicesClientUpdateResponse contains the response from method SQLMigrationServicesClient.Update.
type SQLMigrationServicesClientUpdateResponse struct {
	SQLMigrationServicesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SQLMigrationServicesClientUpdateResult contains the result from method SQLMigrationServicesClient.Update.
type SQLMigrationServicesClientUpdateResult struct {
	SQLMigrationService
}

// ServiceTasksClientCancelResponse contains the response from method ServiceTasksClient.Cancel.
type ServiceTasksClientCancelResponse struct {
	ServiceTasksClientCancelResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceTasksClientCancelResult contains the result from method ServiceTasksClient.Cancel.
type ServiceTasksClientCancelResult struct {
	ProjectTask
}

// ServiceTasksClientCreateOrUpdateResponse contains the response from method ServiceTasksClient.CreateOrUpdate.
type ServiceTasksClientCreateOrUpdateResponse struct {
	ServiceTasksClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceTasksClientCreateOrUpdateResult contains the result from method ServiceTasksClient.CreateOrUpdate.
type ServiceTasksClientCreateOrUpdateResult struct {
	ProjectTask
}

// ServiceTasksClientDeleteResponse contains the response from method ServiceTasksClient.Delete.
type ServiceTasksClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceTasksClientGetResponse contains the response from method ServiceTasksClient.Get.
type ServiceTasksClientGetResponse struct {
	ServiceTasksClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceTasksClientGetResult contains the result from method ServiceTasksClient.Get.
type ServiceTasksClientGetResult struct {
	ProjectTask
}

// ServiceTasksClientListResponse contains the response from method ServiceTasksClient.List.
type ServiceTasksClientListResponse struct {
	ServiceTasksClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceTasksClientListResult contains the result from method ServiceTasksClient.List.
type ServiceTasksClientListResult struct {
	TaskList
}

// ServiceTasksClientUpdateResponse contains the response from method ServiceTasksClient.Update.
type ServiceTasksClientUpdateResponse struct {
	ServiceTasksClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServiceTasksClientUpdateResult contains the result from method ServiceTasksClient.Update.
type ServiceTasksClientUpdateResult struct {
	ProjectTask
}

// ServicesClientCheckChildrenNameAvailabilityResponse contains the response from method ServicesClient.CheckChildrenNameAvailability.
type ServicesClientCheckChildrenNameAvailabilityResponse struct {
	ServicesClientCheckChildrenNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientCheckChildrenNameAvailabilityResult contains the result from method ServicesClient.CheckChildrenNameAvailability.
type ServicesClientCheckChildrenNameAvailabilityResult struct {
	NameAvailabilityResponse
}

// ServicesClientCheckNameAvailabilityResponse contains the response from method ServicesClient.CheckNameAvailability.
type ServicesClientCheckNameAvailabilityResponse struct {
	ServicesClientCheckNameAvailabilityResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientCheckNameAvailabilityResult contains the result from method ServicesClient.CheckNameAvailability.
type ServicesClientCheckNameAvailabilityResult struct {
	NameAvailabilityResponse
}

// ServicesClientCheckStatusResponse contains the response from method ServicesClient.CheckStatus.
type ServicesClientCheckStatusResponse struct {
	ServicesClientCheckStatusResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientCheckStatusResult contains the result from method ServicesClient.CheckStatus.
type ServicesClientCheckStatusResult struct {
	ServiceStatusResponse
}

// ServicesClientCreateOrUpdatePollerResponse contains the response from method ServicesClient.CreateOrUpdate.
type ServicesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServicesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesClientCreateOrUpdateResponse, error) {
	respType := ServicesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Service)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServicesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServicesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesClientCreateOrUpdateResponse contains the response from method ServicesClient.CreateOrUpdate.
type ServicesClientCreateOrUpdateResponse struct {
	ServicesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientCreateOrUpdateResult contains the result from method ServicesClient.CreateOrUpdate.
type ServicesClientCreateOrUpdateResult struct {
	Service
}

// ServicesClientDeletePollerResponse contains the response from method ServicesClient.Delete.
type ServicesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServicesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesClientDeleteResponse, error) {
	respType := ServicesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesClientDeletePollerResponse from the provided client and resume token.
func (l *ServicesClientDeletePollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServicesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesClientDeleteResponse contains the response from method ServicesClient.Delete.
type ServicesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientGetResponse contains the response from method ServicesClient.Get.
type ServicesClientGetResponse struct {
	ServicesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientGetResult contains the result from method ServicesClient.Get.
type ServicesClientGetResult struct {
	Service
}

// ServicesClientListByResourceGroupResponse contains the response from method ServicesClient.ListByResourceGroup.
type ServicesClientListByResourceGroupResponse struct {
	ServicesClientListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientListByResourceGroupResult contains the result from method ServicesClient.ListByResourceGroup.
type ServicesClientListByResourceGroupResult struct {
	ServiceList
}

// ServicesClientListResponse contains the response from method ServicesClient.List.
type ServicesClientListResponse struct {
	ServicesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientListResult contains the result from method ServicesClient.List.
type ServicesClientListResult struct {
	ServiceList
}

// ServicesClientListSKUsResponse contains the response from method ServicesClient.ListSKUs.
type ServicesClientListSKUsResponse struct {
	ServicesClientListSKUsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientListSKUsResult contains the result from method ServicesClient.ListSKUs.
type ServicesClientListSKUsResult struct {
	ServiceSKUList
}

// ServicesClientStartPollerResponse contains the response from method ServicesClient.Start.
type ServicesClientStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesClientStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServicesClientStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesClientStartResponse, error) {
	respType := ServicesClientStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesClientStartPollerResponse from the provided client and resume token.
func (l *ServicesClientStartPollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.Start", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServicesClientStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesClientStartResponse contains the response from method ServicesClient.Start.
type ServicesClientStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientStopPollerResponse contains the response from method ServicesClient.Stop.
type ServicesClientStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesClientStopPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServicesClientStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesClientStopResponse, error) {
	respType := ServicesClientStopResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesClientStopPollerResponse from the provided client and resume token.
func (l *ServicesClientStopPollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.Stop", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServicesClientStopPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesClientStopResponse contains the response from method ServicesClient.Stop.
type ServicesClientStopResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientUpdatePollerResponse contains the response from method ServicesClient.Update.
type ServicesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServicesClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServicesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServicesClientUpdateResponse, error) {
	respType := ServicesClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Service)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ServicesClientUpdatePollerResponse from the provided client and resume token.
func (l *ServicesClientUpdatePollerResponse) Resume(ctx context.Context, client *ServicesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServicesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServicesClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ServicesClientUpdateResponse contains the response from method ServicesClient.Update.
type ServicesClientUpdateResponse struct {
	ServicesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ServicesClientUpdateResult contains the result from method ServicesClient.Update.
type ServicesClientUpdateResult struct {
	Service
}

// TasksClientCancelResponse contains the response from method TasksClient.Cancel.
type TasksClientCancelResponse struct {
	TasksClientCancelResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TasksClientCancelResult contains the result from method TasksClient.Cancel.
type TasksClientCancelResult struct {
	ProjectTask
}

// TasksClientCommandResponse contains the response from method TasksClient.Command.
type TasksClientCommandResponse struct {
	TasksClientCommandResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TasksClientCommandResult contains the result from method TasksClient.Command.
type TasksClientCommandResult struct {
	CommandPropertiesClassification
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TasksClientCommandResult.
func (t *TasksClientCommandResult) UnmarshalJSON(data []byte) error {
	res, err := unmarshalCommandPropertiesClassification(data)
	if err != nil {
		return err
	}
	t.CommandPropertiesClassification = res
	return nil
}

// TasksClientCreateOrUpdateResponse contains the response from method TasksClient.CreateOrUpdate.
type TasksClientCreateOrUpdateResponse struct {
	TasksClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TasksClientCreateOrUpdateResult contains the result from method TasksClient.CreateOrUpdate.
type TasksClientCreateOrUpdateResult struct {
	ProjectTask
}

// TasksClientDeleteResponse contains the response from method TasksClient.Delete.
type TasksClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TasksClientGetResponse contains the response from method TasksClient.Get.
type TasksClientGetResponse struct {
	TasksClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TasksClientGetResult contains the result from method TasksClient.Get.
type TasksClientGetResult struct {
	ProjectTask
}

// TasksClientListResponse contains the response from method TasksClient.List.
type TasksClientListResponse struct {
	TasksClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TasksClientListResult contains the result from method TasksClient.List.
type TasksClientListResult struct {
	TaskList
}

// TasksClientUpdateResponse contains the response from method TasksClient.Update.
type TasksClientUpdateResponse struct {
	TasksClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// TasksClientUpdateResult contains the result from method TasksClient.Update.
type TasksClientUpdateResult struct {
	ProjectTask
}

// UsagesClientListResponse contains the response from method UsagesClient.List.
type UsagesClientListResponse struct {
	UsagesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// UsagesClientListResult contains the result from method UsagesClient.List.
type UsagesClientListResult struct {
	QuotaList
}
