//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcompute

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// APIError - Api error.
type APIError struct {
	// The error code.
	Code *string `json:"code,omitempty"`

	// The Api error details
	Details []*APIErrorBase `json:"details,omitempty"`

	// The Api inner error
	Innererror *InnerError `json:"innererror,omitempty"`

	// The error message.
	Message *string `json:"message,omitempty"`

	// The target of the particular error.
	Target *string `json:"target,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type APIError.
func (a APIError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", a.Code)
	populate(objectMap, "details", a.Details)
	populate(objectMap, "innererror", a.Innererror)
	populate(objectMap, "message", a.Message)
	populate(objectMap, "target", a.Target)
	return json.Marshal(objectMap)
}

// APIErrorBase - Api error base.
type APIErrorBase struct {
	// The error code.
	Code *string `json:"code,omitempty"`

	// The error message.
	Message *string `json:"message,omitempty"`

	// The target of the particular error.
	Target *string `json:"target,omitempty"`
}

// AccessURI - A disk access SAS uri.
type AccessURI struct {
	// READ-ONLY; A SAS uri for accessing a disk.
	AccessSAS *string `json:"accessSAS,omitempty" azure:"ro"`

	// READ-ONLY; A SAS uri for accessing a VM guest state.
	SecurityDataAccessSAS *string `json:"securityDataAccessSAS,omitempty" azure:"ro"`
}

// CloudError - An error response from the Compute service.
type CloudError struct {
	// Api error.
	Error *APIError `json:"error,omitempty"`
}

// CreationData - Data used when creating a disk.
type CreationData struct {
	// REQUIRED; This enumerates the possible sources of a disk's creation.
	CreateOption *DiskCreateOption `json:"createOption,omitempty"`

	// Required if creating from a Gallery Image. The id of the ImageDiskReference will be the ARM id of the shared galley image
	// version from which to create a disk.
	GalleryImageReference *ImageDiskReference `json:"galleryImageReference,omitempty"`

	// Disk source information.
	ImageReference *ImageDiskReference `json:"imageReference,omitempty"`

	// Logical sector size in bytes for Ultra disks. Supported values are 512 ad 4096. 4096 is the default.
	LogicalSectorSize *int32 `json:"logicalSectorSize,omitempty"`

	// If createOption is ImportSecure, this is the URI of a blob to be imported into VM guest state.
	SecurityDataURI *string `json:"securityDataUri,omitempty"`

	// If createOption is Copy, this is the ARM id of the source snapshot or disk.
	SourceResourceID *string `json:"sourceResourceId,omitempty"`

	// If createOption is Import, this is the URI of a blob to be imported into a managed disk.
	SourceURI *string `json:"sourceUri,omitempty"`

	// Required if createOption is Import. The Azure Resource Manager identifier of the storage account containing the blob to
	// import as a disk.
	StorageAccountID *string `json:"storageAccountId,omitempty"`

	// If createOption is Upload, this is the size of the contents of the upload including the VHD footer. This value should be
	// between 20972032 (20 MiB + 512 bytes for the VHD footer) and 35183298347520
	// bytes (32 TiB + 512 bytes for the VHD footer).
	UploadSizeBytes *int64 `json:"uploadSizeBytes,omitempty"`

	// READ-ONLY; If this field is set, this is the unique id identifying the source of this resource.
	SourceUniqueID *string `json:"sourceUniqueId,omitempty" azure:"ro"`
}

// Disk resource.
type Disk struct {
	// REQUIRED; Resource location
	Location *string `json:"location,omitempty"`

	// The extended location where the disk will be created. Extended location cannot be changed.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	// Disk resource properties.
	Properties *DiskProperties `json:"properties,omitempty"`

	// The disks sku name. Can be StandardLRS, PremiumLRS, StandardSSDLRS, UltraSSDLRS, PremiumZRS, or StandardSSDZRS.
	SKU *DiskSKU `json:"sku,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`

	// The Logical zone list for Disk.
	Zones []*string `json:"zones,omitempty"`

	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; A relative URI containing the ID of the VM that has the disk attached.
	ManagedBy *string `json:"managedBy,omitempty" azure:"ro"`

	// READ-ONLY; List of relative URIs containing the IDs of the VMs that have the disk attached. maxShares should be set to
	// a value greater than one for disks to allow attaching them to multiple VMs.
	ManagedByExtended []*string `json:"managedByExtended,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Disk.
func (d Disk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extendedLocation", d.ExtendedLocation)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "location", d.Location)
	populate(objectMap, "managedBy", d.ManagedBy)
	populate(objectMap, "managedByExtended", d.ManagedByExtended)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "sku", d.SKU)
	populate(objectMap, "tags", d.Tags)
	populate(objectMap, "type", d.Type)
	populate(objectMap, "zones", d.Zones)
	return json.Marshal(objectMap)
}

// DiskAccess - disk access resource.
type DiskAccess struct {
	// REQUIRED; Resource location
	Location *string `json:"location,omitempty"`

	// The extended location where the disk access will be created. Extended location cannot be changed.
	ExtendedLocation *ExtendedLocation     `json:"extendedLocation,omitempty"`
	Properties       *DiskAccessProperties `json:"properties,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DiskAccess.
func (d DiskAccess) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extendedLocation", d.ExtendedLocation)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "location", d.Location)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "tags", d.Tags)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// DiskAccessList - The List disk access operation response.
type DiskAccessList struct {
	// REQUIRED; A list of disk access resources.
	Value []*DiskAccess `json:"value,omitempty"`

	// The uri to fetch the next page of disk access resources. Call ListNext() with this to fetch the next page of disk access
	// resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DiskAccessList.
func (d DiskAccessList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

type DiskAccessProperties struct {
	// READ-ONLY; A readonly collection of private endpoint connections created on the disk. Currently only one endpoint connection
	// is supported.
	PrivateEndpointConnections []*PrivateEndpointConnection `json:"privateEndpointConnections,omitempty" azure:"ro"`

	// READ-ONLY; The disk access resource provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The time when the disk access was created.
	TimeCreated *time.Time `json:"timeCreated,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DiskAccessProperties.
func (d DiskAccessProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "privateEndpointConnections", d.PrivateEndpointConnections)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populateTimeRFC3339(objectMap, "timeCreated", d.TimeCreated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiskAccessProperties.
func (d *DiskAccessProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "privateEndpointConnections":
			err = unpopulate(val, &d.PrivateEndpointConnections)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &d.ProvisioningState)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateTimeRFC3339(val, &d.TimeCreated)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DiskAccessUpdate - Used for updating a disk access resource.
type DiskAccessUpdate struct {
	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DiskAccessUpdate.
func (d DiskAccessUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// DiskAccessesClientBeginCreateOrUpdateOptions contains the optional parameters for the DiskAccessesClient.BeginCreateOrUpdate
// method.
type DiskAccessesClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DiskAccessesClientBeginDeleteAPrivateEndpointConnectionOptions contains the optional parameters for the DiskAccessesClient.BeginDeleteAPrivateEndpointConnection
// method.
type DiskAccessesClientBeginDeleteAPrivateEndpointConnectionOptions struct {
	// placeholder for future optional parameters
}

// DiskAccessesClientBeginDeleteOptions contains the optional parameters for the DiskAccessesClient.BeginDelete method.
type DiskAccessesClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// DiskAccessesClientBeginUpdateAPrivateEndpointConnectionOptions contains the optional parameters for the DiskAccessesClient.BeginUpdateAPrivateEndpointConnection
// method.
type DiskAccessesClientBeginUpdateAPrivateEndpointConnectionOptions struct {
	// placeholder for future optional parameters
}

// DiskAccessesClientBeginUpdateOptions contains the optional parameters for the DiskAccessesClient.BeginUpdate method.
type DiskAccessesClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// DiskAccessesClientGetAPrivateEndpointConnectionOptions contains the optional parameters for the DiskAccessesClient.GetAPrivateEndpointConnection
// method.
type DiskAccessesClientGetAPrivateEndpointConnectionOptions struct {
	// placeholder for future optional parameters
}

// DiskAccessesClientGetOptions contains the optional parameters for the DiskAccessesClient.Get method.
type DiskAccessesClientGetOptions struct {
	// placeholder for future optional parameters
}

// DiskAccessesClientGetPrivateLinkResourcesOptions contains the optional parameters for the DiskAccessesClient.GetPrivateLinkResources
// method.
type DiskAccessesClientGetPrivateLinkResourcesOptions struct {
	// placeholder for future optional parameters
}

// DiskAccessesClientListByResourceGroupOptions contains the optional parameters for the DiskAccessesClient.ListByResourceGroup
// method.
type DiskAccessesClientListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// DiskAccessesClientListOptions contains the optional parameters for the DiskAccessesClient.List method.
type DiskAccessesClientListOptions struct {
	// placeholder for future optional parameters
}

// DiskAccessesClientListPrivateEndpointConnectionsOptions contains the optional parameters for the DiskAccessesClient.ListPrivateEndpointConnections
// method.
type DiskAccessesClientListPrivateEndpointConnectionsOptions struct {
	// placeholder for future optional parameters
}

// DiskEncryptionSet - disk encryption set resource.
type DiskEncryptionSet struct {
	// REQUIRED; Resource location
	Location *string `json:"location,omitempty"`

	// The managed identity for the disk encryption set. It should be given permission on the key vault before it can be used
	// to encrypt disks.
	Identity   *EncryptionSetIdentity   `json:"identity,omitempty"`
	Properties *EncryptionSetProperties `json:"properties,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DiskEncryptionSet.
func (d DiskEncryptionSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", d.ID)
	populate(objectMap, "identity", d.Identity)
	populate(objectMap, "location", d.Location)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "tags", d.Tags)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// DiskEncryptionSetList - The List disk encryption set operation response.
type DiskEncryptionSetList struct {
	// REQUIRED; A list of disk encryption sets.
	Value []*DiskEncryptionSet `json:"value,omitempty"`

	// The uri to fetch the next page of disk encryption sets. Call ListNext() with this to fetch the next page of disk encryption
	// sets.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DiskEncryptionSetList.
func (d DiskEncryptionSetList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DiskEncryptionSetUpdate - disk encryption set update resource.
type DiskEncryptionSetUpdate struct {
	// The managed identity for the disk encryption set. It should be given permission on the key vault before it can be used
	// to encrypt disks.
	Identity *EncryptionSetIdentity `json:"identity,omitempty"`

	// disk encryption set resource update properties.
	Properties *DiskEncryptionSetUpdateProperties `json:"properties,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DiskEncryptionSetUpdate.
func (d DiskEncryptionSetUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", d.Identity)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// DiskEncryptionSetUpdateProperties - disk encryption set resource update properties.
type DiskEncryptionSetUpdateProperties struct {
	// Key Vault Key Url to be used for server side encryption of Managed Disks and Snapshots
	ActiveKey *KeyForDiskEncryptionSet `json:"activeKey,omitempty"`

	// The type of key used to encrypt the data of the disk.
	EncryptionType *DiskEncryptionSetType `json:"encryptionType,omitempty"`

	// Set this flag to true to enable auto-updating of this disk encryption set to the latest key version.
	RotationToLatestKeyVersionEnabled *bool `json:"rotationToLatestKeyVersionEnabled,omitempty"`
}

// DiskEncryptionSetsClientBeginCreateOrUpdateOptions contains the optional parameters for the DiskEncryptionSetsClient.BeginCreateOrUpdate
// method.
type DiskEncryptionSetsClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DiskEncryptionSetsClientBeginDeleteOptions contains the optional parameters for the DiskEncryptionSetsClient.BeginDelete
// method.
type DiskEncryptionSetsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// DiskEncryptionSetsClientBeginUpdateOptions contains the optional parameters for the DiskEncryptionSetsClient.BeginUpdate
// method.
type DiskEncryptionSetsClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// DiskEncryptionSetsClientGetOptions contains the optional parameters for the DiskEncryptionSetsClient.Get method.
type DiskEncryptionSetsClientGetOptions struct {
	// placeholder for future optional parameters
}

// DiskEncryptionSetsClientListAssociatedResourcesOptions contains the optional parameters for the DiskEncryptionSetsClient.ListAssociatedResources
// method.
type DiskEncryptionSetsClientListAssociatedResourcesOptions struct {
	// placeholder for future optional parameters
}

// DiskEncryptionSetsClientListByResourceGroupOptions contains the optional parameters for the DiskEncryptionSetsClient.ListByResourceGroup
// method.
type DiskEncryptionSetsClientListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// DiskEncryptionSetsClientListOptions contains the optional parameters for the DiskEncryptionSetsClient.List method.
type DiskEncryptionSetsClientListOptions struct {
	// placeholder for future optional parameters
}

// DiskList - The List Disks operation response.
type DiskList struct {
	// REQUIRED; A list of disks.
	Value []*Disk `json:"value,omitempty"`

	// The uri to fetch the next page of disks. Call ListNext() with this to fetch the next page of disks.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DiskList.
func (d DiskList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DiskProperties - Disk resource properties.
type DiskProperties struct {
	// REQUIRED; Disk source information. CreationData information cannot be changed after the disk has been created.
	CreationData *CreationData `json:"creationData,omitempty"`

	// Set to true to enable bursting beyond the provisioned performance target of the disk. Bursting is disabled by default.
	// Does not apply to Ultra disks.
	BurstingEnabled *bool `json:"burstingEnabled,omitempty"`

	// Percentage complete for the background copy when a resource is created via the CopyStart operation.
	CompletionPercent *float32 `json:"completionPercent,omitempty"`

	// Additional authentication requirements when exporting or uploading to a disk or snapshot.
	DataAccessAuthMode *DataAccessAuthMode `json:"dataAccessAuthMode,omitempty"`

	// ARM id of the DiskAccess resource for using private endpoints on disks.
	DiskAccessID *string `json:"diskAccessId,omitempty"`

	// The total number of IOPS that will be allowed across all VMs mounting the shared disk as ReadOnly. One operation can transfer
	// between 4k and 256k bytes.
	DiskIOPSReadOnly *int64 `json:"diskIOPSReadOnly,omitempty"`

	// The number of IOPS allowed for this disk; only settable for UltraSSD disks. One operation can transfer between 4k and 256k
	// bytes.
	DiskIOPSReadWrite *int64 `json:"diskIOPSReadWrite,omitempty"`

	// The total throughput (MBps) that will be allowed across all VMs mounting the shared disk as ReadOnly. MBps means millions
	// of bytes per second - MB here uses the ISO notation, of powers of 10.
	DiskMBpsReadOnly *int64 `json:"diskMBpsReadOnly,omitempty"`

	// The bandwidth allowed for this disk; only settable for UltraSSD disks. MBps means millions of bytes per second - MB here
	// uses the ISO notation, of powers of 10.
	DiskMBpsReadWrite *int64 `json:"diskMBpsReadWrite,omitempty"`

	// If creationData.createOption is Empty, this field is mandatory and it indicates the size of the disk to create. If this
	// field is present for updates or creation with other options, it indicates a
	// resize. Resizes are only allowed if the disk is not attached to a running VM, and can only increase the disk's size.
	DiskSizeGB *int32 `json:"diskSizeGB,omitempty"`

	// Encryption property can be used to encrypt data at rest with customer managed keys or platform managed keys.
	Encryption *Encryption `json:"encryption,omitempty"`

	// Encryption settings collection used for Azure Disk Encryption, can contain multiple encryption settings per disk or snapshot.
	EncryptionSettingsCollection *EncryptionSettingsCollection `json:"encryptionSettingsCollection,omitempty"`

	// The hypervisor generation of the Virtual Machine. Applicable to OS disks only.
	HyperVGeneration *HyperVGeneration `json:"hyperVGeneration,omitempty"`

	// The maximum number of VMs that can attach to the disk at the same time. Value greater than one indicates a disk that can
	// be mounted on multiple VMs at the same time.
	MaxShares *int32 `json:"maxShares,omitempty"`

	// Policy for accessing the disk via network.
	NetworkAccessPolicy *NetworkAccessPolicy `json:"networkAccessPolicy,omitempty"`

	// The Operating System type.
	OSType *OperatingSystemTypes `json:"osType,omitempty"`

	// Policy for controlling export on the disk.
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// Purchase plan information for the the image from which the OS disk was created. E.g. - {name: 2019-Datacenter, publisher:
	// MicrosoftWindowsServer, product: WindowsServer}
	PurchasePlan *PurchasePlan `json:"purchasePlan,omitempty"`

	// Contains the security related information for the resource.
	SecurityProfile *DiskSecurityProfile `json:"securityProfile,omitempty"`

	// List of supported capabilities for the image from which the OS disk was created.
	SupportedCapabilities *SupportedCapabilities `json:"supportedCapabilities,omitempty"`

	// Indicates the OS on a disk supports hibernation.
	SupportsHibernation *bool `json:"supportsHibernation,omitempty"`

	// Performance tier of the disk (e.g, P4, S10) as described here: https://azure.microsoft.com/en-us/pricing/details/managed-disks/.
	// Does not apply to Ultra disks.
	Tier *string `json:"tier,omitempty"`

	// READ-ONLY; The size of the disk in bytes. This field is read only.
	DiskSizeBytes *int64 `json:"diskSizeBytes,omitempty" azure:"ro"`

	// READ-ONLY; The state of the disk.
	DiskState *DiskState `json:"diskState,omitempty" azure:"ro"`

	// READ-ONLY; Properties of the disk for which update is pending.
	PropertyUpdatesInProgress *PropertyUpdatesInProgress `json:"propertyUpdatesInProgress,omitempty" azure:"ro"`

	// READ-ONLY; The disk provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Details of the list of all VMs that have the disk attached. maxShares should be set to a value greater than
	// one for disks to allow attaching them to multiple VMs.
	ShareInfo []*ShareInfoElement `json:"shareInfo,omitempty" azure:"ro"`

	// READ-ONLY; The time when the disk was created.
	TimeCreated *time.Time `json:"timeCreated,omitempty" azure:"ro"`

	// READ-ONLY; Unique Guid identifying the resource.
	UniqueID *string `json:"uniqueId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DiskProperties.
func (d DiskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "burstingEnabled", d.BurstingEnabled)
	populate(objectMap, "completionPercent", d.CompletionPercent)
	populate(objectMap, "creationData", d.CreationData)
	populate(objectMap, "dataAccessAuthMode", d.DataAccessAuthMode)
	populate(objectMap, "diskAccessId", d.DiskAccessID)
	populate(objectMap, "diskIOPSReadOnly", d.DiskIOPSReadOnly)
	populate(objectMap, "diskIOPSReadWrite", d.DiskIOPSReadWrite)
	populate(objectMap, "diskMBpsReadOnly", d.DiskMBpsReadOnly)
	populate(objectMap, "diskMBpsReadWrite", d.DiskMBpsReadWrite)
	populate(objectMap, "diskSizeBytes", d.DiskSizeBytes)
	populate(objectMap, "diskSizeGB", d.DiskSizeGB)
	populate(objectMap, "diskState", d.DiskState)
	populate(objectMap, "encryption", d.Encryption)
	populate(objectMap, "encryptionSettingsCollection", d.EncryptionSettingsCollection)
	populate(objectMap, "hyperVGeneration", d.HyperVGeneration)
	populate(objectMap, "maxShares", d.MaxShares)
	populate(objectMap, "networkAccessPolicy", d.NetworkAccessPolicy)
	populate(objectMap, "osType", d.OSType)
	populate(objectMap, "propertyUpdatesInProgress", d.PropertyUpdatesInProgress)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", d.PublicNetworkAccess)
	populate(objectMap, "purchasePlan", d.PurchasePlan)
	populate(objectMap, "securityProfile", d.SecurityProfile)
	populate(objectMap, "shareInfo", d.ShareInfo)
	populate(objectMap, "supportedCapabilities", d.SupportedCapabilities)
	populate(objectMap, "supportsHibernation", d.SupportsHibernation)
	populate(objectMap, "tier", d.Tier)
	populateTimeRFC3339(objectMap, "timeCreated", d.TimeCreated)
	populate(objectMap, "uniqueId", d.UniqueID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiskProperties.
func (d *DiskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "burstingEnabled":
			err = unpopulate(val, &d.BurstingEnabled)
			delete(rawMsg, key)
		case "completionPercent":
			err = unpopulate(val, &d.CompletionPercent)
			delete(rawMsg, key)
		case "creationData":
			err = unpopulate(val, &d.CreationData)
			delete(rawMsg, key)
		case "dataAccessAuthMode":
			err = unpopulate(val, &d.DataAccessAuthMode)
			delete(rawMsg, key)
		case "diskAccessId":
			err = unpopulate(val, &d.DiskAccessID)
			delete(rawMsg, key)
		case "diskIOPSReadOnly":
			err = unpopulate(val, &d.DiskIOPSReadOnly)
			delete(rawMsg, key)
		case "diskIOPSReadWrite":
			err = unpopulate(val, &d.DiskIOPSReadWrite)
			delete(rawMsg, key)
		case "diskMBpsReadOnly":
			err = unpopulate(val, &d.DiskMBpsReadOnly)
			delete(rawMsg, key)
		case "diskMBpsReadWrite":
			err = unpopulate(val, &d.DiskMBpsReadWrite)
			delete(rawMsg, key)
		case "diskSizeBytes":
			err = unpopulate(val, &d.DiskSizeBytes)
			delete(rawMsg, key)
		case "diskSizeGB":
			err = unpopulate(val, &d.DiskSizeGB)
			delete(rawMsg, key)
		case "diskState":
			err = unpopulate(val, &d.DiskState)
			delete(rawMsg, key)
		case "encryption":
			err = unpopulate(val, &d.Encryption)
			delete(rawMsg, key)
		case "encryptionSettingsCollection":
			err = unpopulate(val, &d.EncryptionSettingsCollection)
			delete(rawMsg, key)
		case "hyperVGeneration":
			err = unpopulate(val, &d.HyperVGeneration)
			delete(rawMsg, key)
		case "maxShares":
			err = unpopulate(val, &d.MaxShares)
			delete(rawMsg, key)
		case "networkAccessPolicy":
			err = unpopulate(val, &d.NetworkAccessPolicy)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, &d.OSType)
			delete(rawMsg, key)
		case "propertyUpdatesInProgress":
			err = unpopulate(val, &d.PropertyUpdatesInProgress)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &d.ProvisioningState)
			delete(rawMsg, key)
		case "publicNetworkAccess":
			err = unpopulate(val, &d.PublicNetworkAccess)
			delete(rawMsg, key)
		case "purchasePlan":
			err = unpopulate(val, &d.PurchasePlan)
			delete(rawMsg, key)
		case "securityProfile":
			err = unpopulate(val, &d.SecurityProfile)
			delete(rawMsg, key)
		case "shareInfo":
			err = unpopulate(val, &d.ShareInfo)
			delete(rawMsg, key)
		case "supportedCapabilities":
			err = unpopulate(val, &d.SupportedCapabilities)
			delete(rawMsg, key)
		case "supportsHibernation":
			err = unpopulate(val, &d.SupportsHibernation)
			delete(rawMsg, key)
		case "tier":
			err = unpopulate(val, &d.Tier)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateTimeRFC3339(val, &d.TimeCreated)
			delete(rawMsg, key)
		case "uniqueId":
			err = unpopulate(val, &d.UniqueID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DiskRestorePoint - Properties of disk restore point
type DiskRestorePoint struct {
	// Properties of an incremental disk restore point
	Properties *DiskRestorePointProperties `json:"properties,omitempty"`

	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// DiskRestorePointClientBeginGrantAccessOptions contains the optional parameters for the DiskRestorePointClient.BeginGrantAccess
// method.
type DiskRestorePointClientBeginGrantAccessOptions struct {
	// placeholder for future optional parameters
}

// DiskRestorePointClientBeginRevokeAccessOptions contains the optional parameters for the DiskRestorePointClient.BeginRevokeAccess
// method.
type DiskRestorePointClientBeginRevokeAccessOptions struct {
	// placeholder for future optional parameters
}

// DiskRestorePointClientGetOptions contains the optional parameters for the DiskRestorePointClient.Get method.
type DiskRestorePointClientGetOptions struct {
	// placeholder for future optional parameters
}

// DiskRestorePointClientListByRestorePointOptions contains the optional parameters for the DiskRestorePointClient.ListByRestorePoint
// method.
type DiskRestorePointClientListByRestorePointOptions struct {
	// placeholder for future optional parameters
}

// DiskRestorePointList - The List Disk Restore Points operation response.
type DiskRestorePointList struct {
	// REQUIRED; A list of disk restore points.
	Value []*DiskRestorePoint `json:"value,omitempty"`

	// The uri to fetch the next page of disk restore points. Call ListNext() with this to fetch the next page of disk restore
	// points.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DiskRestorePointList.
func (d DiskRestorePointList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DiskRestorePointProperties - Properties of an incremental disk restore point
type DiskRestorePointProperties struct {
	// Percentage complete for the background copy of disk restore point when source resource is from a different region.
	CompletionPercent *float32 `json:"completionPercent,omitempty"`

	// ARM id of the DiskAccess resource for using private endpoints on disks.
	DiskAccessID *string `json:"diskAccessId,omitempty"`

	// The hypervisor generation of the Virtual Machine. Applicable to OS disks only.
	HyperVGeneration *HyperVGeneration `json:"hyperVGeneration,omitempty"`

	// Policy for accessing the disk via network.
	NetworkAccessPolicy *NetworkAccessPolicy `json:"networkAccessPolicy,omitempty"`

	// Policy for controlling export on the disk.
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// Purchase plan information for the the image from which the OS disk was created.
	PurchasePlan *PurchasePlan `json:"purchasePlan,omitempty"`

	// List of supported capabilities for the image from which the OS disk was created.
	SupportedCapabilities *SupportedCapabilities `json:"supportedCapabilities,omitempty"`

	// Indicates the OS on a disk supports hibernation.
	SupportsHibernation *bool `json:"supportsHibernation,omitempty"`

	// READ-ONLY; Encryption property can be used to encrypt data at rest with customer managed keys or platform managed keys.
	Encryption *Encryption `json:"encryption,omitempty" azure:"ro"`

	// READ-ONLY; id of the backing snapshot's MIS family
	FamilyID *string `json:"familyId,omitempty" azure:"ro"`

	// READ-ONLY; The Operating System type.
	OSType *OperatingSystemTypes `json:"osType,omitempty" azure:"ro"`

	// READ-ONLY; Replication state of disk restore point when source resource is from a different region.
	ReplicationState *string `json:"replicationState,omitempty" azure:"ro"`

	// READ-ONLY; arm id of source disk or source disk restore point.
	SourceResourceID *string `json:"sourceResourceId,omitempty" azure:"ro"`

	// READ-ONLY; Location of source disk or source disk restore point when source resource is from a different region.
	SourceResourceLocation *string `json:"sourceResourceLocation,omitempty" azure:"ro"`

	// READ-ONLY; unique incarnation id of the source disk
	SourceUniqueID *string `json:"sourceUniqueId,omitempty" azure:"ro"`

	// READ-ONLY; The timestamp of restorePoint creation
	TimeCreated *time.Time `json:"timeCreated,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DiskRestorePointProperties.
func (d DiskRestorePointProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "completionPercent", d.CompletionPercent)
	populate(objectMap, "diskAccessId", d.DiskAccessID)
	populate(objectMap, "encryption", d.Encryption)
	populate(objectMap, "familyId", d.FamilyID)
	populate(objectMap, "hyperVGeneration", d.HyperVGeneration)
	populate(objectMap, "networkAccessPolicy", d.NetworkAccessPolicy)
	populate(objectMap, "osType", d.OSType)
	populate(objectMap, "publicNetworkAccess", d.PublicNetworkAccess)
	populate(objectMap, "purchasePlan", d.PurchasePlan)
	populate(objectMap, "replicationState", d.ReplicationState)
	populate(objectMap, "sourceResourceId", d.SourceResourceID)
	populate(objectMap, "sourceResourceLocation", d.SourceResourceLocation)
	populate(objectMap, "sourceUniqueId", d.SourceUniqueID)
	populate(objectMap, "supportedCapabilities", d.SupportedCapabilities)
	populate(objectMap, "supportsHibernation", d.SupportsHibernation)
	populateTimeRFC3339(objectMap, "timeCreated", d.TimeCreated)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiskRestorePointProperties.
func (d *DiskRestorePointProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "completionPercent":
			err = unpopulate(val, &d.CompletionPercent)
			delete(rawMsg, key)
		case "diskAccessId":
			err = unpopulate(val, &d.DiskAccessID)
			delete(rawMsg, key)
		case "encryption":
			err = unpopulate(val, &d.Encryption)
			delete(rawMsg, key)
		case "familyId":
			err = unpopulate(val, &d.FamilyID)
			delete(rawMsg, key)
		case "hyperVGeneration":
			err = unpopulate(val, &d.HyperVGeneration)
			delete(rawMsg, key)
		case "networkAccessPolicy":
			err = unpopulate(val, &d.NetworkAccessPolicy)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, &d.OSType)
			delete(rawMsg, key)
		case "publicNetworkAccess":
			err = unpopulate(val, &d.PublicNetworkAccess)
			delete(rawMsg, key)
		case "purchasePlan":
			err = unpopulate(val, &d.PurchasePlan)
			delete(rawMsg, key)
		case "replicationState":
			err = unpopulate(val, &d.ReplicationState)
			delete(rawMsg, key)
		case "sourceResourceId":
			err = unpopulate(val, &d.SourceResourceID)
			delete(rawMsg, key)
		case "sourceResourceLocation":
			err = unpopulate(val, &d.SourceResourceLocation)
			delete(rawMsg, key)
		case "sourceUniqueId":
			err = unpopulate(val, &d.SourceUniqueID)
			delete(rawMsg, key)
		case "supportedCapabilities":
			err = unpopulate(val, &d.SupportedCapabilities)
			delete(rawMsg, key)
		case "supportsHibernation":
			err = unpopulate(val, &d.SupportsHibernation)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateTimeRFC3339(val, &d.TimeCreated)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DiskSKU - The disks sku name. Can be StandardLRS, PremiumLRS, StandardSSDLRS, UltraSSDLRS, PremiumZRS, or StandardSSDZRS.
type DiskSKU struct {
	// The sku name.
	Name *DiskStorageAccountTypes `json:"name,omitempty"`

	// READ-ONLY; The sku tier.
	Tier *string `json:"tier,omitempty" azure:"ro"`
}

// DiskSecurityProfile - Contains the security related information for the resource.
type DiskSecurityProfile struct {
	// ResourceId of the disk encryption set associated to Confidential VM supported disk encrypted with customer managed key
	SecureVMDiskEncryptionSetID *string `json:"secureVMDiskEncryptionSetId,omitempty"`

	// Specifies the SecurityType of the VM. Applicable for OS disks only.
	SecurityType *DiskSecurityTypes `json:"securityType,omitempty"`
}

// DiskUpdate - Disk update resource.
type DiskUpdate struct {
	// Disk resource update properties.
	Properties *DiskUpdateProperties `json:"properties,omitempty"`

	// The disks sku name. Can be StandardLRS, PremiumLRS, StandardSSDLRS, UltraSSDLRS, PremiumZRS, or StandardSSDZRS.
	SKU *DiskSKU `json:"sku,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DiskUpdate.
func (d DiskUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "sku", d.SKU)
	populate(objectMap, "tags", d.Tags)
	return json.Marshal(objectMap)
}

// DiskUpdateProperties - Disk resource update properties.
type DiskUpdateProperties struct {
	// Set to true to enable bursting beyond the provisioned performance target of the disk. Bursting is disabled by default.
	// Does not apply to Ultra disks.
	BurstingEnabled *bool `json:"burstingEnabled,omitempty"`

	// Additional authentication requirements when exporting or uploading to a disk or snapshot.
	DataAccessAuthMode *DataAccessAuthMode `json:"dataAccessAuthMode,omitempty"`

	// ARM id of the DiskAccess resource for using private endpoints on disks.
	DiskAccessID *string `json:"diskAccessId,omitempty"`

	// The total number of IOPS that will be allowed across all VMs mounting the shared disk as ReadOnly. One operation can transfer
	// between 4k and 256k bytes.
	DiskIOPSReadOnly *int64 `json:"diskIOPSReadOnly,omitempty"`

	// The number of IOPS allowed for this disk; only settable for UltraSSD disks. One operation can transfer between 4k and 256k
	// bytes.
	DiskIOPSReadWrite *int64 `json:"diskIOPSReadWrite,omitempty"`

	// The total throughput (MBps) that will be allowed across all VMs mounting the shared disk as ReadOnly. MBps means millions
	// of bytes per second - MB here uses the ISO notation, of powers of 10.
	DiskMBpsReadOnly *int64 `json:"diskMBpsReadOnly,omitempty"`

	// The bandwidth allowed for this disk; only settable for UltraSSD disks. MBps means millions of bytes per second - MB here
	// uses the ISO notation, of powers of 10.
	DiskMBpsReadWrite *int64 `json:"diskMBpsReadWrite,omitempty"`

	// If creationData.createOption is Empty, this field is mandatory and it indicates the size of the disk to create. If this
	// field is present for updates or creation with other options, it indicates a
	// resize. Resizes are only allowed if the disk is not attached to a running VM, and can only increase the disk's size.
	DiskSizeGB *int32 `json:"diskSizeGB,omitempty"`

	// Encryption property can be used to encrypt data at rest with customer managed keys or platform managed keys.
	Encryption *Encryption `json:"encryption,omitempty"`

	// Encryption settings collection used be Azure Disk Encryption, can contain multiple encryption settings per disk or snapshot.
	EncryptionSettingsCollection *EncryptionSettingsCollection `json:"encryptionSettingsCollection,omitempty"`

	// The maximum number of VMs that can attach to the disk at the same time. Value greater than one indicates a disk that can
	// be mounted on multiple VMs at the same time.
	MaxShares *int32 `json:"maxShares,omitempty"`

	// Policy for accessing the disk via network.
	NetworkAccessPolicy *NetworkAccessPolicy `json:"networkAccessPolicy,omitempty"`

	// the Operating System type.
	OSType *OperatingSystemTypes `json:"osType,omitempty"`

	// Policy for controlling export on the disk.
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// Purchase plan information to be added on the OS disk
	PurchasePlan *PurchasePlan `json:"purchasePlan,omitempty"`

	// List of supported capabilities to be added on the OS disk.
	SupportedCapabilities *SupportedCapabilities `json:"supportedCapabilities,omitempty"`

	// Indicates the OS on a disk supports hibernation.
	SupportsHibernation *bool `json:"supportsHibernation,omitempty"`

	// Performance tier of the disk (e.g, P4, S10) as described here: https://azure.microsoft.com/en-us/pricing/details/managed-disks/.
	// Does not apply to Ultra disks.
	Tier *string `json:"tier,omitempty"`

	// READ-ONLY; Properties of the disk for which update is pending.
	PropertyUpdatesInProgress *PropertyUpdatesInProgress `json:"propertyUpdatesInProgress,omitempty" azure:"ro"`
}

// DisksClientBeginCreateOrUpdateOptions contains the optional parameters for the DisksClient.BeginCreateOrUpdate method.
type DisksClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// DisksClientBeginDeleteOptions contains the optional parameters for the DisksClient.BeginDelete method.
type DisksClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// DisksClientBeginGrantAccessOptions contains the optional parameters for the DisksClient.BeginGrantAccess method.
type DisksClientBeginGrantAccessOptions struct {
	// placeholder for future optional parameters
}

// DisksClientBeginRevokeAccessOptions contains the optional parameters for the DisksClient.BeginRevokeAccess method.
type DisksClientBeginRevokeAccessOptions struct {
	// placeholder for future optional parameters
}

// DisksClientBeginUpdateOptions contains the optional parameters for the DisksClient.BeginUpdate method.
type DisksClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// DisksClientGetOptions contains the optional parameters for the DisksClient.Get method.
type DisksClientGetOptions struct {
	// placeholder for future optional parameters
}

// DisksClientListByResourceGroupOptions contains the optional parameters for the DisksClient.ListByResourceGroup method.
type DisksClientListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// DisksClientListOptions contains the optional parameters for the DisksClient.List method.
type DisksClientListOptions struct {
	// placeholder for future optional parameters
}

// Encryption at rest settings for disk or snapshot
type Encryption struct {
	// ResourceId of the disk encryption set to use for enabling encryption at rest.
	DiskEncryptionSetID *string `json:"diskEncryptionSetId,omitempty"`

	// The type of key used to encrypt the data of the disk.
	Type *EncryptionType `json:"type,omitempty"`
}

// EncryptionSetIdentity - The managed identity for the disk encryption set. It should be given permission on the key vault
// before it can be used to encrypt disks.
type EncryptionSetIdentity struct {
	// The type of Managed Identity used by the DiskEncryptionSet. Only SystemAssigned is supported for new creations. Disk Encryption
	// Sets can be updated with Identity type None during migration of
	// subscription to a new Azure Active Directory tenant; it will cause the encrypted resources to lose access to the keys.
	Type *DiskEncryptionSetIdentityType `json:"type,omitempty"`

	// READ-ONLY; The object id of the Managed Identity Resource. This will be sent to the RP from ARM via the x-ms-identity-principal-id
	// header in the PUT request if the resource has a systemAssigned(implicit)
	// identity
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The tenant id of the Managed Identity Resource. This will be sent to the RP from ARM via the x-ms-client-tenant-id
	// header in the PUT request if the resource has a systemAssigned(implicit) identity
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

type EncryptionSetProperties struct {
	// The key vault key which is currently used by this disk encryption set.
	ActiveKey *KeyForDiskEncryptionSet `json:"activeKey,omitempty"`

	// The type of key used to encrypt the data of the disk.
	EncryptionType *DiskEncryptionSetType `json:"encryptionType,omitempty"`

	// Set this flag to true to enable auto-updating of this disk encryption set to the latest key version.
	RotationToLatestKeyVersionEnabled *bool `json:"rotationToLatestKeyVersionEnabled,omitempty"`

	// READ-ONLY; The error that was encountered during auto-key rotation. If an error is present, then auto-key rotation will
	// not be attempted until the error on this disk encryption set is fixed.
	AutoKeyRotationError *APIError `json:"autoKeyRotationError,omitempty" azure:"ro"`

	// READ-ONLY; The time when the active key of this disk encryption set was updated.
	LastKeyRotationTimestamp *time.Time `json:"lastKeyRotationTimestamp,omitempty" azure:"ro"`

	// READ-ONLY; A readonly collection of key vault keys previously used by this disk encryption set while a key rotation is
	// in progress. It will be empty if there is no ongoing key rotation.
	PreviousKeys []*KeyForDiskEncryptionSet `json:"previousKeys,omitempty" azure:"ro"`

	// READ-ONLY; The disk encryption set provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionSetProperties.
func (e EncryptionSetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activeKey", e.ActiveKey)
	populate(objectMap, "autoKeyRotationError", e.AutoKeyRotationError)
	populate(objectMap, "encryptionType", e.EncryptionType)
	populateTimeRFC3339(objectMap, "lastKeyRotationTimestamp", e.LastKeyRotationTimestamp)
	populate(objectMap, "previousKeys", e.PreviousKeys)
	populate(objectMap, "provisioningState", e.ProvisioningState)
	populate(objectMap, "rotationToLatestKeyVersionEnabled", e.RotationToLatestKeyVersionEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncryptionSetProperties.
func (e *EncryptionSetProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activeKey":
			err = unpopulate(val, &e.ActiveKey)
			delete(rawMsg, key)
		case "autoKeyRotationError":
			err = unpopulate(val, &e.AutoKeyRotationError)
			delete(rawMsg, key)
		case "encryptionType":
			err = unpopulate(val, &e.EncryptionType)
			delete(rawMsg, key)
		case "lastKeyRotationTimestamp":
			err = unpopulateTimeRFC3339(val, &e.LastKeyRotationTimestamp)
			delete(rawMsg, key)
		case "previousKeys":
			err = unpopulate(val, &e.PreviousKeys)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &e.ProvisioningState)
			delete(rawMsg, key)
		case "rotationToLatestKeyVersionEnabled":
			err = unpopulate(val, &e.RotationToLatestKeyVersionEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// EncryptionSettingsCollection - Encryption settings for disk or snapshot
type EncryptionSettingsCollection struct {
	// REQUIRED; Set this flag to true and provide DiskEncryptionKey and optional KeyEncryptionKey to enable encryption. Set this
	// flag to false and remove DiskEncryptionKey and KeyEncryptionKey to disable encryption.
	// If EncryptionSettings is null in the request object, the existing settings remain unchanged.
	Enabled *bool `json:"enabled,omitempty"`

	// A collection of encryption settings, one for each disk volume.
	EncryptionSettings []*EncryptionSettingsElement `json:"encryptionSettings,omitempty"`

	// Describes what type of encryption is used for the disks. Once this field is set, it cannot be overwritten. '1.0' corresponds
	// to Azure Disk Encryption with AAD app.'1.1' corresponds to Azure Disk
	// Encryption.
	EncryptionSettingsVersion *string `json:"encryptionSettingsVersion,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionSettingsCollection.
func (e EncryptionSettingsCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "enabled", e.Enabled)
	populate(objectMap, "encryptionSettings", e.EncryptionSettings)
	populate(objectMap, "encryptionSettingsVersion", e.EncryptionSettingsVersion)
	return json.Marshal(objectMap)
}

// EncryptionSettingsElement - Encryption settings for one disk volume.
type EncryptionSettingsElement struct {
	// Key Vault Secret Url and vault id of the disk encryption key
	DiskEncryptionKey *KeyVaultAndSecretReference `json:"diskEncryptionKey,omitempty"`

	// Key Vault Key Url and vault id of the key encryption key. KeyEncryptionKey is optional and when provided is used to unwrap
	// the disk encryption key.
	KeyEncryptionKey *KeyVaultAndKeyReference `json:"keyEncryptionKey,omitempty"`
}

// ExtendedLocation - The complex type of the extended location.
type ExtendedLocation struct {
	// The name of the extended location.
	Name *string `json:"name,omitempty"`

	// The type of the extended location.
	Type *ExtendedLocationTypes `json:"type,omitempty"`
}

// GrantAccessData - Data used for requesting a SAS.
type GrantAccessData struct {
	// REQUIRED
	Access *AccessLevel `json:"access,omitempty"`

	// REQUIRED; Time duration in seconds until the SAS access expires.
	DurationInSeconds *int32 `json:"durationInSeconds,omitempty"`

	// Set this flag to true to get additional SAS for VM guest state
	GetSecureVMGuestStateSAS *bool `json:"getSecureVMGuestStateSAS,omitempty"`
}

// ImageDiskReference - The source image used for creating the disk.
type ImageDiskReference struct {
	// REQUIRED; A relative uri containing either a Platform Image Repository or user image reference.
	ID *string `json:"id,omitempty"`

	// If the disk is created from an image's data disk, this is an index that indicates which of the data disks in the image
	// to use. For OS disks, this field is null.
	Lun *int32 `json:"lun,omitempty"`
}

// InnerError - Inner error details.
type InnerError struct {
	// The internal error message or exception dump.
	Errordetail *string `json:"errordetail,omitempty"`

	// The exception type.
	Exceptiontype *string `json:"exceptiontype,omitempty"`
}

// KeyForDiskEncryptionSet - Key Vault Key Url to be used for server side encryption of Managed Disks and Snapshots
type KeyForDiskEncryptionSet struct {
	// REQUIRED; Fully versioned Key Url pointing to a key in KeyVault. Version segment of the Url is required regardless of rotationToLatestKeyVersionEnabled
	// value.
	KeyURL *string `json:"keyUrl,omitempty"`

	// Resource id of the KeyVault containing the key or secret. This property is optional and cannot be used if the KeyVault
	// subscription is not the same as the Disk Encryption Set subscription.
	SourceVault *SourceVault `json:"sourceVault,omitempty"`
}

// KeyVaultAndKeyReference - Key Vault Key Url and vault id of KeK, KeK is optional and when provided is used to unwrap the
// encryptionKey
type KeyVaultAndKeyReference struct {
	// REQUIRED; Url pointing to a key or secret in KeyVault
	KeyURL *string `json:"keyUrl,omitempty"`

	// REQUIRED; Resource id of the KeyVault containing the key or secret
	SourceVault *SourceVault `json:"sourceVault,omitempty"`
}

// KeyVaultAndSecretReference - Key Vault Secret Url and vault id of the encryption key
type KeyVaultAndSecretReference struct {
	// REQUIRED; Url pointing to a key or secret in KeyVault
	SecretURL *string `json:"secretUrl,omitempty"`

	// REQUIRED; Resource id of the KeyVault containing the key or secret
	SourceVault *SourceVault `json:"sourceVault,omitempty"`
}

// PrivateEndpoint - The Private Endpoint resource.
type PrivateEndpoint struct {
	// READ-ONLY; The ARM identifier for Private Endpoint
	ID *string `json:"id,omitempty" azure:"ro"`
}

// PrivateEndpointConnection - The Private Endpoint Connection resource.
type PrivateEndpointConnection struct {
	// Resource properties.
	Properties *PrivateEndpointConnectionProperties `json:"properties,omitempty"`

	// READ-ONLY; private endpoint connection Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; private endpoint connection name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; private endpoint connection type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PrivateEndpointConnectionListResult - A list of private link resources
type PrivateEndpointConnectionListResult struct {
	// The uri to fetch the next page of snapshots. Call ListNext() with this to fetch the next page of snapshots.
	NextLink *string `json:"nextLink,omitempty"`

	// Array of private endpoint connections
	Value []*PrivateEndpointConnection `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateEndpointConnectionListResult.
func (p PrivateEndpointConnectionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateEndpointConnectionProperties - Properties of the PrivateEndpointConnectProperties.
type PrivateEndpointConnectionProperties struct {
	// REQUIRED; A collection of information about the state of the connection between DiskAccess and Virtual Network.
	PrivateLinkServiceConnectionState *PrivateLinkServiceConnectionState `json:"privateLinkServiceConnectionState,omitempty"`

	// READ-ONLY; The resource of private end point.
	PrivateEndpoint *PrivateEndpoint `json:"privateEndpoint,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning state of the private endpoint connection resource.
	ProvisioningState *PrivateEndpointConnectionProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// PrivateLinkResource - A private link resource
type PrivateLinkResource struct {
	// Resource properties.
	Properties *PrivateLinkResourceProperties `json:"properties,omitempty"`

	// READ-ONLY; private link resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; private link resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; private link resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PrivateLinkResourceListResult - A list of private link resources
type PrivateLinkResourceListResult struct {
	// Array of private link resources
	Value []*PrivateLinkResource `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceListResult.
func (p PrivateLinkResourceListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// PrivateLinkResourceProperties - Properties of a private link resource.
type PrivateLinkResourceProperties struct {
	// The private link resource DNS zone name.
	RequiredZoneNames []*string `json:"requiredZoneNames,omitempty"`

	// READ-ONLY; The private link resource group id.
	GroupID *string `json:"groupId,omitempty" azure:"ro"`

	// READ-ONLY; The private link resource required member names.
	RequiredMembers []*string `json:"requiredMembers,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PrivateLinkResourceProperties.
func (p PrivateLinkResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "groupId", p.GroupID)
	populate(objectMap, "requiredMembers", p.RequiredMembers)
	populate(objectMap, "requiredZoneNames", p.RequiredZoneNames)
	return json.Marshal(objectMap)
}

// PrivateLinkServiceConnectionState - A collection of information about the state of the connection between service consumer
// and provider.
type PrivateLinkServiceConnectionState struct {
	// A message indicating if changes on the service provider require any updates on the consumer.
	ActionsRequired *string `json:"actionsRequired,omitempty"`

	// The reason for approval/rejection of the connection.
	Description *string `json:"description,omitempty"`

	// Indicates whether the connection has been Approved/Rejected/Removed by the owner of the service.
	Status *PrivateEndpointServiceConnectionStatus `json:"status,omitempty"`
}

// PropertyUpdatesInProgress - Properties of the disk for which update is pending.
type PropertyUpdatesInProgress struct {
	// The target performance tier of the disk if a tier change operation is in progress.
	TargetTier *string `json:"targetTier,omitempty"`
}

// ProxyOnlyResource - The ProxyOnly Resource model definition.
type ProxyOnlyResource struct {
	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// PurchasePlan - Used for establishing the purchase context of any 3rd Party artifact through MarketPlace.
type PurchasePlan struct {
	// REQUIRED; The plan ID.
	Name *string `json:"name,omitempty"`

	// REQUIRED; Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference
	// element.
	Product *string `json:"product,omitempty"`

	// REQUIRED; The publisher ID.
	Publisher *string `json:"publisher,omitempty"`

	// The Offer Promotion Code.
	PromotionCode *string `json:"promotionCode,omitempty"`
}

// Resource - The Resource model definition.
type Resource struct {
	// REQUIRED; Resource location
	Location *string `json:"location,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// ResourceURIList - The List resources which are encrypted with the disk encryption set.
type ResourceURIList struct {
	// REQUIRED; A list of IDs or Owner IDs of resources which are encrypted with the disk encryption set.
	Value []*string `json:"value,omitempty"`

	// The uri to fetch the next page of encrypted resources. Call ListNext() with this to fetch the next page of encrypted resources.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceURIList.
func (r ResourceURIList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

type ShareInfoElement struct {
	// READ-ONLY; A relative URI containing the ID of the VM that has the disk attached.
	VMURI *string `json:"vmUri,omitempty" azure:"ro"`
}

// Snapshot resource.
type Snapshot struct {
	// REQUIRED; Resource location
	Location *string `json:"location,omitempty"`

	// The extended location where the snapshot will be created. Extended location cannot be changed.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	// Snapshot resource properties.
	Properties *SnapshotProperties `json:"properties,omitempty"`

	// The snapshots sku name. Can be StandardLRS, PremiumLRS, or Standard_ZRS. This is an optional parameter for incremental
	// snapshot and the default behavior is the SKU will be set to the same sku as the
	// previous snapshot
	SKU *SnapshotSKU `json:"sku,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Unused. Always Null.
	ManagedBy *string `json:"managedBy,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Snapshot.
func (s Snapshot) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extendedLocation", s.ExtendedLocation)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "location", s.Location)
	populate(objectMap, "managedBy", s.ManagedBy)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "sku", s.SKU)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// SnapshotList - The List Snapshots operation response.
type SnapshotList struct {
	// REQUIRED; A list of snapshots.
	Value []*Snapshot `json:"value,omitempty"`

	// The uri to fetch the next page of snapshots. Call ListNext() with this to fetch the next page of snapshots.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SnapshotList.
func (s SnapshotList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// SnapshotProperties - Snapshot resource properties.
type SnapshotProperties struct {
	// REQUIRED; Disk source information. CreationData information cannot be changed after the disk has been created.
	CreationData *CreationData `json:"creationData,omitempty"`

	// Percentage complete for the background copy when a resource is created via the CopyStart operation.
	CompletionPercent *float32 `json:"completionPercent,omitempty"`

	// Additional authentication requirements when exporting or uploading to a disk or snapshot.
	DataAccessAuthMode *DataAccessAuthMode `json:"dataAccessAuthMode,omitempty"`

	// ARM id of the DiskAccess resource for using private endpoints on disks.
	DiskAccessID *string `json:"diskAccessId,omitempty"`

	// If creationData.createOption is Empty, this field is mandatory and it indicates the size of the disk to create. If this
	// field is present for updates or creation with other options, it indicates a
	// resize. Resizes are only allowed if the disk is not attached to a running VM, and can only increase the disk's size.
	DiskSizeGB *int32 `json:"diskSizeGB,omitempty"`

	// Encryption property can be used to encrypt data at rest with customer managed keys or platform managed keys.
	Encryption *Encryption `json:"encryption,omitempty"`

	// Encryption settings collection used be Azure Disk Encryption, can contain multiple encryption settings per disk or snapshot.
	EncryptionSettingsCollection *EncryptionSettingsCollection `json:"encryptionSettingsCollection,omitempty"`

	// The hypervisor generation of the Virtual Machine. Applicable to OS disks only.
	HyperVGeneration *HyperVGeneration `json:"hyperVGeneration,omitempty"`

	// Whether a snapshot is incremental. Incremental snapshots on the same disk occupy less space than full snapshots and can
	// be diffed.
	Incremental *bool `json:"incremental,omitempty"`

	// Policy for accessing the disk via network.
	NetworkAccessPolicy *NetworkAccessPolicy `json:"networkAccessPolicy,omitempty"`

	// The Operating System type.
	OSType *OperatingSystemTypes `json:"osType,omitempty"`

	// Policy for controlling export on the disk.
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// Purchase plan information for the image from which the source disk for the snapshot was originally created.
	PurchasePlan *PurchasePlan `json:"purchasePlan,omitempty"`

	// Contains the security related information for the resource.
	SecurityProfile *DiskSecurityProfile `json:"securityProfile,omitempty"`

	// List of supported capabilities for the image from which the source disk from the snapshot was originally created.
	SupportedCapabilities *SupportedCapabilities `json:"supportedCapabilities,omitempty"`

	// Indicates the OS on a snapshot supports hibernation.
	SupportsHibernation *bool `json:"supportsHibernation,omitempty"`

	// READ-ONLY; The size of the disk in bytes. This field is read only.
	DiskSizeBytes *int64 `json:"diskSizeBytes,omitempty" azure:"ro"`

	// READ-ONLY; The state of the snapshot.
	DiskState *DiskState `json:"diskState,omitempty" azure:"ro"`

	// READ-ONLY; The disk provisioning state.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; The time when the snapshot was created.
	TimeCreated *time.Time `json:"timeCreated,omitempty" azure:"ro"`

	// READ-ONLY; Unique Guid identifying the resource.
	UniqueID *string `json:"uniqueId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type SnapshotProperties.
func (s SnapshotProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "completionPercent", s.CompletionPercent)
	populate(objectMap, "creationData", s.CreationData)
	populate(objectMap, "dataAccessAuthMode", s.DataAccessAuthMode)
	populate(objectMap, "diskAccessId", s.DiskAccessID)
	populate(objectMap, "diskSizeBytes", s.DiskSizeBytes)
	populate(objectMap, "diskSizeGB", s.DiskSizeGB)
	populate(objectMap, "diskState", s.DiskState)
	populate(objectMap, "encryption", s.Encryption)
	populate(objectMap, "encryptionSettingsCollection", s.EncryptionSettingsCollection)
	populate(objectMap, "hyperVGeneration", s.HyperVGeneration)
	populate(objectMap, "incremental", s.Incremental)
	populate(objectMap, "networkAccessPolicy", s.NetworkAccessPolicy)
	populate(objectMap, "osType", s.OSType)
	populate(objectMap, "provisioningState", s.ProvisioningState)
	populate(objectMap, "publicNetworkAccess", s.PublicNetworkAccess)
	populate(objectMap, "purchasePlan", s.PurchasePlan)
	populate(objectMap, "securityProfile", s.SecurityProfile)
	populate(objectMap, "supportedCapabilities", s.SupportedCapabilities)
	populate(objectMap, "supportsHibernation", s.SupportsHibernation)
	populateTimeRFC3339(objectMap, "timeCreated", s.TimeCreated)
	populate(objectMap, "uniqueId", s.UniqueID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SnapshotProperties.
func (s *SnapshotProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "completionPercent":
			err = unpopulate(val, &s.CompletionPercent)
			delete(rawMsg, key)
		case "creationData":
			err = unpopulate(val, &s.CreationData)
			delete(rawMsg, key)
		case "dataAccessAuthMode":
			err = unpopulate(val, &s.DataAccessAuthMode)
			delete(rawMsg, key)
		case "diskAccessId":
			err = unpopulate(val, &s.DiskAccessID)
			delete(rawMsg, key)
		case "diskSizeBytes":
			err = unpopulate(val, &s.DiskSizeBytes)
			delete(rawMsg, key)
		case "diskSizeGB":
			err = unpopulate(val, &s.DiskSizeGB)
			delete(rawMsg, key)
		case "diskState":
			err = unpopulate(val, &s.DiskState)
			delete(rawMsg, key)
		case "encryption":
			err = unpopulate(val, &s.Encryption)
			delete(rawMsg, key)
		case "encryptionSettingsCollection":
			err = unpopulate(val, &s.EncryptionSettingsCollection)
			delete(rawMsg, key)
		case "hyperVGeneration":
			err = unpopulate(val, &s.HyperVGeneration)
			delete(rawMsg, key)
		case "incremental":
			err = unpopulate(val, &s.Incremental)
			delete(rawMsg, key)
		case "networkAccessPolicy":
			err = unpopulate(val, &s.NetworkAccessPolicy)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, &s.OSType)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &s.ProvisioningState)
			delete(rawMsg, key)
		case "publicNetworkAccess":
			err = unpopulate(val, &s.PublicNetworkAccess)
			delete(rawMsg, key)
		case "purchasePlan":
			err = unpopulate(val, &s.PurchasePlan)
			delete(rawMsg, key)
		case "securityProfile":
			err = unpopulate(val, &s.SecurityProfile)
			delete(rawMsg, key)
		case "supportedCapabilities":
			err = unpopulate(val, &s.SupportedCapabilities)
			delete(rawMsg, key)
		case "supportsHibernation":
			err = unpopulate(val, &s.SupportsHibernation)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateTimeRFC3339(val, &s.TimeCreated)
			delete(rawMsg, key)
		case "uniqueId":
			err = unpopulate(val, &s.UniqueID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SnapshotSKU - The snapshots sku name. Can be StandardLRS, PremiumLRS, or Standard_ZRS. This is an optional parameter for
// incremental snapshot and the default behavior is the SKU will be set to the same sku as the
// previous snapshot
type SnapshotSKU struct {
	// The sku name.
	Name *SnapshotStorageAccountTypes `json:"name,omitempty"`

	// READ-ONLY; The sku tier.
	Tier *string `json:"tier,omitempty" azure:"ro"`
}

// SnapshotUpdate - Snapshot update resource.
type SnapshotUpdate struct {
	// Snapshot resource update properties.
	Properties *SnapshotUpdateProperties `json:"properties,omitempty"`

	// The snapshots sku name. Can be StandardLRS, PremiumLRS, or Standard_ZRS. This is an optional parameter for incremental
	// snapshot and the default behavior is the SKU will be set to the same sku as the
	// previous snapshot
	SKU *SnapshotSKU `json:"sku,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SnapshotUpdate.
func (s SnapshotUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "sku", s.SKU)
	populate(objectMap, "tags", s.Tags)
	return json.Marshal(objectMap)
}

// SnapshotUpdateProperties - Snapshot resource update properties.
type SnapshotUpdateProperties struct {
	// Additional authentication requirements when exporting or uploading to a disk or snapshot.
	DataAccessAuthMode *DataAccessAuthMode `json:"dataAccessAuthMode,omitempty"`

	// ARM id of the DiskAccess resource for using private endpoints on disks.
	DiskAccessID *string `json:"diskAccessId,omitempty"`

	// If creationData.createOption is Empty, this field is mandatory and it indicates the size of the disk to create. If this
	// field is present for updates or creation with other options, it indicates a
	// resize. Resizes are only allowed if the disk is not attached to a running VM, and can only increase the disk's size.
	DiskSizeGB *int32 `json:"diskSizeGB,omitempty"`

	// Encryption property can be used to encrypt data at rest with customer managed keys or platform managed keys.
	Encryption *Encryption `json:"encryption,omitempty"`

	// Encryption settings collection used be Azure Disk Encryption, can contain multiple encryption settings per disk or snapshot.
	EncryptionSettingsCollection *EncryptionSettingsCollection `json:"encryptionSettingsCollection,omitempty"`

	// Policy for accessing the disk via network.
	NetworkAccessPolicy *NetworkAccessPolicy `json:"networkAccessPolicy,omitempty"`

	// the Operating System type.
	OSType *OperatingSystemTypes `json:"osType,omitempty"`

	// Policy for controlling export on the disk.
	PublicNetworkAccess *PublicNetworkAccess `json:"publicNetworkAccess,omitempty"`

	// List of supported capabilities for the image from which the OS disk was created.
	SupportedCapabilities *SupportedCapabilities `json:"supportedCapabilities,omitempty"`

	// Indicates the OS on a snapshot supports hibernation.
	SupportsHibernation *bool `json:"supportsHibernation,omitempty"`
}

// SnapshotsClientBeginCreateOrUpdateOptions contains the optional parameters for the SnapshotsClient.BeginCreateOrUpdate
// method.
type SnapshotsClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// SnapshotsClientBeginDeleteOptions contains the optional parameters for the SnapshotsClient.BeginDelete method.
type SnapshotsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// SnapshotsClientBeginGrantAccessOptions contains the optional parameters for the SnapshotsClient.BeginGrantAccess method.
type SnapshotsClientBeginGrantAccessOptions struct {
	// placeholder for future optional parameters
}

// SnapshotsClientBeginRevokeAccessOptions contains the optional parameters for the SnapshotsClient.BeginRevokeAccess method.
type SnapshotsClientBeginRevokeAccessOptions struct {
	// placeholder for future optional parameters
}

// SnapshotsClientBeginUpdateOptions contains the optional parameters for the SnapshotsClient.BeginUpdate method.
type SnapshotsClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// SnapshotsClientGetOptions contains the optional parameters for the SnapshotsClient.Get method.
type SnapshotsClientGetOptions struct {
	// placeholder for future optional parameters
}

// SnapshotsClientListByResourceGroupOptions contains the optional parameters for the SnapshotsClient.ListByResourceGroup
// method.
type SnapshotsClientListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// SnapshotsClientListOptions contains the optional parameters for the SnapshotsClient.List method.
type SnapshotsClientListOptions struct {
	// placeholder for future optional parameters
}

// SourceVault - The vault id is an Azure Resource Manager Resource id in the form /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.KeyVault/vaults/{vaultName}
type SourceVault struct {
	// Resource Id
	ID *string `json:"id,omitempty"`
}

// SupportedCapabilities - List of supported capabilities persisted on the disk resource for VM use.
type SupportedCapabilities struct {
	// True if the image from which the OS disk is created supports accelerated networking.
	AcceleratedNetwork *bool `json:"acceleratedNetwork,omitempty"`

	// CPU architecture supported by an OS disk.
	Architecture *Architecture `json:"architecture,omitempty"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
