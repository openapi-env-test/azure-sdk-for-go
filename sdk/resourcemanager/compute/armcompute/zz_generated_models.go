//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcompute

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// APIError - Api error.
type APIError struct {
	// The error code.
	Code *string `json:"code,omitempty"`

	// The Api error details
	Details []*APIErrorBase `json:"details,omitempty"`

	// The Api inner error
	Innererror *InnerError `json:"innererror,omitempty"`

	// The error message.
	Message *string `json:"message,omitempty"`

	// The target of the particular error.
	Target *string `json:"target,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type APIError.
func (a APIError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", a.Code)
	populate(objectMap, "details", a.Details)
	populate(objectMap, "innererror", a.Innererror)
	populate(objectMap, "message", a.Message)
	populate(objectMap, "target", a.Target)
	return json.Marshal(objectMap)
}

// APIErrorBase - Api error base.
type APIErrorBase struct {
	// The error code.
	Code *string `json:"code,omitempty"`

	// The error message.
	Message *string `json:"message,omitempty"`

	// The target of the particular error.
	Target *string `json:"target,omitempty"`
}

// AdditionalCapabilities - Enables or disables a capability on the virtual machine or virtual machine scale set.
type AdditionalCapabilities struct {
	// The flag that enables or disables hibernation capability on the VM.
	HibernationEnabled *bool `json:"hibernationEnabled,omitempty"`

	// The flag that enables or disables a capability to have one or more managed data disks with UltraSSDLRS storage account
	// type on the VM or VMSS. Managed disks with storage account type UltraSSDLRS can
	// be added to a virtual machine or virtual machine scale set only if this property is enabled.
	UltraSSDEnabled *bool `json:"ultraSSDEnabled,omitempty"`
}

// AdditionalUnattendContent - Specifies additional XML formatted information that can be included in the Unattend.xml file,
// which is used by Windows Setup. Contents are defined by setting name, component name, and the pass in
// which the content is applied.
type AdditionalUnattendContent struct {
	// The component name. Currently, the only allowable value is Microsoft-Windows-Shell-Setup.
	ComponentName *string `json:"componentName,omitempty"`

	// Specifies the XML formatted content that is added to the unattend.xml file for the specified path and component. The XML
	// must be less than 4KB and must include the root element for the setting or
	// feature that is being inserted.
	Content *string `json:"content,omitempty"`

	// The pass name. Currently, the only allowable value is OobeSystem.
	PassName *string `json:"passName,omitempty"`

	// Specifies the name of the setting to which the content applies. Possible values are: FirstLogonCommands and AutoLogon.
	SettingName *SettingNames `json:"settingName,omitempty"`
}

// ApplicationProfile - Contains the list of gallery applications that should be made available to the VM/VMSS
type ApplicationProfile struct {
	// Specifies the gallery applications that should be made available to the VM/VMSS
	GalleryApplications []*VMGalleryApplication `json:"galleryApplications,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ApplicationProfile.
func (a ApplicationProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "galleryApplications", a.GalleryApplications)
	return json.Marshal(objectMap)
}

// AvailablePatchSummary - Describes the properties of an virtual machine instance view for available patch summary.
type AvailablePatchSummary struct {
	// READ-ONLY; The activity ID of the operation that produced this result. It is used to correlate across CRP and extension
	// logs.
	AssessmentActivityID *string `json:"assessmentActivityId,omitempty" azure:"ro"`

	// READ-ONLY; The number of critical or security patches that have been detected as available and not yet installed.
	CriticalAndSecurityPatchCount *int32 `json:"criticalAndSecurityPatchCount,omitempty" azure:"ro"`

	// READ-ONLY; The errors that were encountered during execution of the operation. The details array contains the list of them.
	Error *APIError `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; The UTC timestamp when the operation began.
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty" azure:"ro"`

	// READ-ONLY; The number of all available patches excluding critical and security.
	OtherPatchCount *int32 `json:"otherPatchCount,omitempty" azure:"ro"`

	// READ-ONLY; The overall reboot status of the VM. It will be true when partially installed patches require a reboot to complete
	// installation but the reboot has not yet occurred.
	RebootPending *bool `json:"rebootPending,omitempty" azure:"ro"`

	// READ-ONLY; The UTC timestamp when the operation began.
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`

	// READ-ONLY; The overall success or failure status of the operation. It remains "InProgress" until the operation completes.
	// At that point it will become "Unknown", "Failed", "Succeeded", or
	// "CompletedWithWarnings."
	Status *PatchOperationStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AvailablePatchSummary.
func (a AvailablePatchSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assessmentActivityId", a.AssessmentActivityID)
	populate(objectMap, "criticalAndSecurityPatchCount", a.CriticalAndSecurityPatchCount)
	populate(objectMap, "error", a.Error)
	populateTimeRFC3339(objectMap, "lastModifiedTime", a.LastModifiedTime)
	populate(objectMap, "otherPatchCount", a.OtherPatchCount)
	populate(objectMap, "rebootPending", a.RebootPending)
	populateTimeRFC3339(objectMap, "startTime", a.StartTime)
	populate(objectMap, "status", a.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AvailablePatchSummary.
func (a *AvailablePatchSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentActivityId":
			err = unpopulate(val, &a.AssessmentActivityID)
			delete(rawMsg, key)
		case "criticalAndSecurityPatchCount":
			err = unpopulate(val, &a.CriticalAndSecurityPatchCount)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &a.Error)
			delete(rawMsg, key)
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, &a.LastModifiedTime)
			delete(rawMsg, key)
		case "otherPatchCount":
			err = unpopulate(val, &a.OtherPatchCount)
			delete(rawMsg, key)
		case "rebootPending":
			err = unpopulate(val, &a.RebootPending)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &a.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &a.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BillingProfile - Specifies the billing related details of a Azure Spot VM or VMSS.
// Minimum api-version: 2019-03-01.
type BillingProfile struct {
	// Specifies the maximum price you are willing to pay for a Azure Spot VM/VMSS. This price is in US Dollars.
	// This price will be compared with the current Azure Spot price for the VM size. Also, the prices are compared at the time
	// of create/update of Azure Spot VM/VMSS and the operation will only succeed if
	// the maxPrice is greater than the current Azure Spot price.
	// The maxPrice will also be used for evicting a Azure Spot VM/VMSS if the current Azure Spot price goes beyond the maxPrice
	// after creation of VM/VMSS.
	// Possible values are:
	// - Any decimal value greater than zero. Example: 0.01538
	// -1 â€“ indicates default price to be up-to on-demand.
	// You can set the maxPrice to -1 to indicate that the Azure Spot VM/VMSS should not be evicted for price reasons. Also, the
	// default max price is -1 if it is not provided by you.
	// Minimum api-version: 2019-03-01.
	MaxPrice *float64 `json:"maxPrice,omitempty"`
}

// BootDiagnostics - Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to diagnose
// VM status.
// You can easily view the output of your console log.
// Azure also enables you to see a screenshot of the VM from the hypervisor.
type BootDiagnostics struct {
	// Whether boot diagnostics should be enabled on the Virtual Machine.
	Enabled *bool `json:"enabled,omitempty"`

	// Uri of the storage account to use for placing the console output and screenshot.
	// If storageUri is not specified while enabling boot diagnostics, managed storage will be used.
	StorageURI *string `json:"storageUri,omitempty"`
}

// BootDiagnosticsInstanceView - The instance view of a virtual machine boot diagnostics.
type BootDiagnosticsInstanceView struct {
	// READ-ONLY; The console screenshot blob URI.
	// NOTE: This will not be set if boot diagnostics is currently enabled with managed storage.
	ConsoleScreenshotBlobURI *string `json:"consoleScreenshotBlobUri,omitempty" azure:"ro"`

	// READ-ONLY; The serial console log blob Uri.
	// NOTE: This will not be set if boot diagnostics is currently enabled with managed storage.
	SerialConsoleLogBlobURI *string `json:"serialConsoleLogBlobUri,omitempty" azure:"ro"`

	// READ-ONLY; The boot diagnostics status information for the VM.
	// NOTE: It will be set only if there are errors encountered in enabling boot diagnostics.
	Status *InstanceViewStatus `json:"status,omitempty" azure:"ro"`
}

// CapacityReservationProfile - The parameters of a capacity reservation Profile.
type CapacityReservationProfile struct {
	// Specifies the capacity reservation group resource id that should be used for allocating the virtual machine or scaleset
	// vm instances provided enough capacity has been reserved. Please refer to
	// https://aka.ms/CapacityReservation for more details.
	CapacityReservationGroup *SubResource `json:"capacityReservationGroup,omitempty"`
}

// CloudError - An error response from the Compute service.
type CloudError struct {
	// Api error.
	Error *APIError `json:"error,omitempty"`
}

// DataDisk - Describes a data disk.
type DataDisk struct {
	// REQUIRED; Specifies how the virtual machine should be created.
	// Possible values are:
	// Attach \u2013 This value is used when you are using a specialized disk to create the virtual machine.
	// FromImage \u2013 This value is used when you are using an image to create the virtual machine. If you are using a platform
	// image, you also use the imageReference element described above. If you are
	// using a marketplace image, you also use the plan element previously described.
	CreateOption *DiskCreateOptionTypes `json:"createOption,omitempty"`

	// REQUIRED; Specifies the logical unit number of the data disk. This value is used to identify data disks within the VM and
	// therefore must be unique for each data disk attached to a VM.
	Lun *int32 `json:"lun,omitempty"`

	// Specifies the caching requirements.
	// Possible values are:
	// None
	// ReadOnly
	// ReadWrite
	// Default: None for Standard storage. ReadOnly for Premium storage
	Caching *CachingTypes `json:"caching,omitempty"`

	// Specifies whether data disk should be deleted or detached upon VM deletion.
	// Possible values:
	// Delete If this value is used, the data disk is deleted when VM is deleted.
	// Detach If this value is used, the data disk is retained after VM is deleted.
	// The default value is set to detach
	DeleteOption *DiskDeleteOptionTypes `json:"deleteOption,omitempty"`

	// Specifies the detach behavior to be used while detaching a disk or which is already in the process of detachment from the
	// virtual machine. Supported values: ForceDetach.
	// detachOption: ForceDetach is applicable only for managed data disks. If a previous detachment attempt of the data disk
	// did not complete due to an unexpected failure from the virtual machine and the
	// disk is still not released then use force-detach as a last resort option to detach the disk forcibly from the VM. All writes
	// might not have been flushed when using this detach behavior.
	// This feature is still in preview mode and is not supported for VirtualMachineScaleSet. To force-detach a data disk update
	// toBeDetached to 'true' along with setting detachOption: 'ForceDetach'.
	DetachOption *DiskDetachOptionTypes `json:"detachOption,omitempty"`

	// Specifies the size of an empty data disk in gigabytes. This element can be used to overwrite the size of the disk in a
	// virtual machine image.
	// This value cannot be larger than 1023 GB
	DiskSizeGB *int32 `json:"diskSizeGB,omitempty"`

	// The source user image virtual hard disk. The virtual hard disk will be copied before being attached to the virtual machine.
	// If SourceImage is provided, the destination virtual hard drive must not
	// exist.
	Image *VirtualHardDisk `json:"image,omitempty"`

	// The managed disk parameters.
	ManagedDisk *ManagedDiskParameters `json:"managedDisk,omitempty"`

	// The disk name.
	Name *string `json:"name,omitempty"`

	// Specifies whether the data disk is in process of detachment from the VirtualMachine/VirtualMachineScaleset
	ToBeDetached *bool `json:"toBeDetached,omitempty"`

	// The virtual hard disk.
	Vhd *VirtualHardDisk `json:"vhd,omitempty"`

	// Specifies whether writeAccelerator should be enabled or disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`

	// READ-ONLY; Specifies the Read-Write IOPS for the managed disk when StorageAccountType is UltraSSD_LRS. Returned only for
	// VirtualMachine ScaleSet VM disks. Can be updated only via updates to the VirtualMachine
	// Scale Set.
	DiskIOPSReadWrite *int64 `json:"diskIOPSReadWrite,omitempty" azure:"ro"`

	// READ-ONLY; Specifies the bandwidth in MB per second for the managed disk when StorageAccountType is UltraSSD_LRS. Returned
	// only for VirtualMachine ScaleSet VM disks. Can be updated only via updates to the
	// VirtualMachine Scale Set.
	DiskMBpsReadWrite *int64 `json:"diskMBpsReadWrite,omitempty" azure:"ro"`
}

// DiagnosticsProfile - Specifies the boot diagnostic settings state.
// Minimum api-version: 2015-06-15.
type DiagnosticsProfile struct {
	// Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to diagnose VM status.
	// NOTE: If storageUri is being specified then ensure that the storage account is in the same region and subscription as the
	// VM.
	// You can easily view the output of your console log.
	// Azure also enables you to see a screenshot of the VM from the hypervisor.
	BootDiagnostics *BootDiagnostics `json:"bootDiagnostics,omitempty"`
}

// DiffDiskSettings - Describes the parameters of ephemeral disk settings that can be specified for operating system disk.
// NOTE: The ephemeral disk settings can only be specified for managed disk.
type DiffDiskSettings struct {
	// Specifies the ephemeral disk settings for operating system disk.
	Option *DiffDiskOptions `json:"option,omitempty"`

	// Specifies the ephemeral disk placement for operating system disk.
	// Possible values are:
	// CacheDisk
	// ResourceDisk
	// Default: CacheDisk if one is configured for the VM size otherwise ResourceDisk is used.
	// Refer to VM size documentation for Windows VM at https://docs.microsoft.com/azure/virtual-machines/windows/sizes and Linux
	// VM at https://docs.microsoft.com/azure/virtual-machines/linux/sizes to check
	// which VM sizes exposes a cache disk.
	Placement *DiffDiskPlacement `json:"placement,omitempty"`
}

// DiskEncryptionSetParameters - Describes the parameter of customer managed disk encryption set resource id that can be specified
// for disk.
// NOTE: The disk encryption set resource id can only be specified for managed disk. Please refer https://aka.ms/mdssewithcmkoverview
// for more details.
type DiskEncryptionSetParameters struct {
	// Resource Id
	ID *string `json:"id,omitempty"`
}

// DiskEncryptionSettings - Describes a Encryption Settings for a Disk
type DiskEncryptionSettings struct {
	// Specifies the location of the disk encryption key, which is a Key Vault Secret.
	DiskEncryptionKey *KeyVaultSecretReference `json:"diskEncryptionKey,omitempty"`

	// Specifies whether disk encryption should be enabled on the virtual machine.
	Enabled *bool `json:"enabled,omitempty"`

	// Specifies the location of the key encryption key in Key Vault.
	KeyEncryptionKey *KeyVaultKeyReference `json:"keyEncryptionKey,omitempty"`
}

// DiskInstanceView - The instance view of the disk.
type DiskInstanceView struct {
	// Specifies the encryption settings for the OS Disk.
	// Minimum api-version: 2015-06-15
	EncryptionSettings []*DiskEncryptionSettings `json:"encryptionSettings,omitempty"`

	// The disk name.
	Name *string `json:"name,omitempty"`

	// The resource status information.
	Statuses []*InstanceViewStatus `json:"statuses,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DiskInstanceView.
func (d DiskInstanceView) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "encryptionSettings", d.EncryptionSettings)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "statuses", d.Statuses)
	return json.Marshal(objectMap)
}

// ExtendedLocation - The complex type of the extended location.
type ExtendedLocation struct {
	// The name of the extended location.
	Name *string `json:"name,omitempty"`

	// The type of the extended location.
	Type *ExtendedLocationTypes `json:"type,omitempty"`
}

// HardwareProfile - Specifies the hardware settings for the virtual machine.
type HardwareProfile struct {
	// Specifies the size of the virtual machine.
	// The enum data type is currently deprecated and will be removed by December 23rd 2023.
	// Recommended way to get the list of available sizes is using these APIs:
	// List all available virtual machine sizes in an availability set [https://docs.microsoft.com/rest/api/compute/availabilitysets/listavailablesizes]
	// List all available virtual machine sizes in a region [https://docs.microsoft.com/rest/api/compute/resourceskus/list]
	// List all available virtual machine sizes for resizing [https://docs.microsoft.com/rest/api/compute/virtualmachines/listavailablesizes].
	// For more information about virtual machine sizes, see Sizes for
	// virtual machines [https://docs.microsoft.com/azure/virtual-machines/sizes].
	// The available VM sizes depend on region and availability set.
	VMSize *VirtualMachineSizeTypes `json:"vmSize,omitempty"`

	// Specifies the properties for customizing the size of the virtual machine. Minimum api-version: 2021-07-01.
	// This feature is still in preview mode and is not supported for VirtualMachineScaleSet.
	// Please follow the instructions in VM Customization [https://aka.ms/vmcustomization] for more details.
	VMSizeProperties *VMSizeProperties `json:"vmSizeProperties,omitempty"`
}

// ImageReference - Specifies information about the image to use. You can specify information about platform images, marketplace
// images, or virtual machine images. This element is required when you want to use a platform
// image, marketplace image, or virtual machine image, but is not used in other creation operations. NOTE: Image reference
// publisher and offer can only be set when you create the scale set.
type ImageReference struct {
	// Specified the community gallery image unique id for vm deployment. This can be fetched from community gallery image GET
	// call.
	CommunityGalleryImageID *string `json:"communityGalleryImageId,omitempty"`

	// Resource Id
	ID *string `json:"id,omitempty"`

	// Specifies the offer of the platform image or marketplace image used to create the virtual machine.
	Offer *string `json:"offer,omitempty"`

	// The image publisher.
	Publisher *string `json:"publisher,omitempty"`

	// The image SKU.
	SKU *string `json:"sku,omitempty"`

	// Specified the shared gallery image unique id for vm deployment. This can be fetched from shared gallery image GET call.
	SharedGalleryImageID *string `json:"sharedGalleryImageId,omitempty"`

	// Specifies the version of the platform image or marketplace image used to create the virtual machine. The allowed formats
	// are Major.Minor.Build or 'latest'. Major, Minor, and Build are decimal numbers.
	// Specify 'latest' to use the latest version of an image available at deploy time. Even if you use 'latest', the VM image
	// will not automatically update after deploy time even if a new version becomes
	// available. Please do not use field 'version' for gallery image deployment, gallery image should always use 'id' field for
	// deployment, to use 'latest' version of gallery image, just set
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/images/{imageName}'
	// in the 'id' field without version input.
	Version *string `json:"version,omitempty"`

	// READ-ONLY; Specifies in decimal numbers, the version of platform image or marketplace image used to create the virtual
	// machine. This readonly field differs from 'version', only if the value specified in
	// 'version' field is 'latest'.
	ExactVersion *string `json:"exactVersion,omitempty" azure:"ro"`
}

// InnerError - Inner error details.
type InnerError struct {
	// The internal error message or exception dump.
	Errordetail *string `json:"errordetail,omitempty"`

	// The exception type.
	Exceptiontype *string `json:"exceptiontype,omitempty"`
}

// InstanceViewStatus - Instance view status.
type InstanceViewStatus struct {
	// The status code.
	Code *string `json:"code,omitempty"`

	// The short localizable label for the status.
	DisplayStatus *string `json:"displayStatus,omitempty"`

	// The level code.
	Level *StatusLevelTypes `json:"level,omitempty"`

	// The detailed status message, including for alerts and error messages.
	Message *string `json:"message,omitempty"`

	// The time of the status.
	Time *time.Time `json:"time,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type InstanceViewStatus.
func (i InstanceViewStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", i.Code)
	populate(objectMap, "displayStatus", i.DisplayStatus)
	populate(objectMap, "level", i.Level)
	populate(objectMap, "message", i.Message)
	populateTimeRFC3339(objectMap, "time", i.Time)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InstanceViewStatus.
func (i *InstanceViewStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, &i.Code)
			delete(rawMsg, key)
		case "displayStatus":
			err = unpopulate(val, &i.DisplayStatus)
			delete(rawMsg, key)
		case "level":
			err = unpopulate(val, &i.Level)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &i.Message)
			delete(rawMsg, key)
		case "time":
			err = unpopulateTimeRFC3339(val, &i.Time)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// KeyVaultKeyReference - Describes a reference to Key Vault Key
type KeyVaultKeyReference struct {
	// REQUIRED; The URL referencing a key encryption key in Key Vault.
	KeyURL *string `json:"keyUrl,omitempty"`

	// REQUIRED; The relative URL of the Key Vault containing the key.
	SourceVault *SubResource `json:"sourceVault,omitempty"`
}

// KeyVaultSecretReference - Describes a reference to Key Vault Secret
type KeyVaultSecretReference struct {
	// REQUIRED; The URL referencing a secret in a Key Vault.
	SecretURL *string `json:"secretUrl,omitempty"`

	// REQUIRED; The relative URL of the Key Vault containing the secret.
	SourceVault *SubResource `json:"sourceVault,omitempty"`
}

// LastPatchInstallationSummary - Describes the properties of the last installed patch summary.
type LastPatchInstallationSummary struct {
	// READ-ONLY; The errors that were encountered during execution of the operation. The details array contains the list of them.
	Error *APIError `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; The number of all available patches but excluded explicitly by a customer-specified exclusion list match.
	ExcludedPatchCount *int32 `json:"excludedPatchCount,omitempty" azure:"ro"`

	// READ-ONLY; The count of patches that failed installation.
	FailedPatchCount *int32 `json:"failedPatchCount,omitempty" azure:"ro"`

	// READ-ONLY; The activity ID of the operation that produced this result. It is used to correlate across CRP and extension
	// logs.
	InstallationActivityID *string `json:"installationActivityId,omitempty" azure:"ro"`

	// READ-ONLY; The count of patches that successfully installed.
	InstalledPatchCount *int32 `json:"installedPatchCount,omitempty" azure:"ro"`

	// READ-ONLY; The UTC timestamp when the operation began.
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty" azure:"ro"`

	// READ-ONLY; Describes whether the operation ran out of time before it completed all its intended actions
	MaintenanceWindowExceeded *bool `json:"maintenanceWindowExceeded,omitempty" azure:"ro"`

	// READ-ONLY; The number of all available patches but not going to be installed because it didn't match a classification or
	// inclusion list entry.
	NotSelectedPatchCount *int32 `json:"notSelectedPatchCount,omitempty" azure:"ro"`

	// READ-ONLY; The number of all available patches expected to be installed over the course of the patch installation operation.
	PendingPatchCount *int32 `json:"pendingPatchCount,omitempty" azure:"ro"`

	// READ-ONLY; The UTC timestamp when the operation began.
	StartTime *time.Time `json:"startTime,omitempty" azure:"ro"`

	// READ-ONLY; The overall success or failure status of the operation. It remains "InProgress" until the operation completes.
	// At that point it will become "Unknown", "Failed", "Succeeded", or
	// "CompletedWithWarnings."
	Status *PatchOperationStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type LastPatchInstallationSummary.
func (l LastPatchInstallationSummary) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", l.Error)
	populate(objectMap, "excludedPatchCount", l.ExcludedPatchCount)
	populate(objectMap, "failedPatchCount", l.FailedPatchCount)
	populate(objectMap, "installationActivityId", l.InstallationActivityID)
	populate(objectMap, "installedPatchCount", l.InstalledPatchCount)
	populateTimeRFC3339(objectMap, "lastModifiedTime", l.LastModifiedTime)
	populate(objectMap, "maintenanceWindowExceeded", l.MaintenanceWindowExceeded)
	populate(objectMap, "notSelectedPatchCount", l.NotSelectedPatchCount)
	populate(objectMap, "pendingPatchCount", l.PendingPatchCount)
	populateTimeRFC3339(objectMap, "startTime", l.StartTime)
	populate(objectMap, "status", l.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LastPatchInstallationSummary.
func (l *LastPatchInstallationSummary) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &l.Error)
			delete(rawMsg, key)
		case "excludedPatchCount":
			err = unpopulate(val, &l.ExcludedPatchCount)
			delete(rawMsg, key)
		case "failedPatchCount":
			err = unpopulate(val, &l.FailedPatchCount)
			delete(rawMsg, key)
		case "installationActivityId":
			err = unpopulate(val, &l.InstallationActivityID)
			delete(rawMsg, key)
		case "installedPatchCount":
			err = unpopulate(val, &l.InstalledPatchCount)
			delete(rawMsg, key)
		case "lastModifiedTime":
			err = unpopulateTimeRFC3339(val, &l.LastModifiedTime)
			delete(rawMsg, key)
		case "maintenanceWindowExceeded":
			err = unpopulate(val, &l.MaintenanceWindowExceeded)
			delete(rawMsg, key)
		case "notSelectedPatchCount":
			err = unpopulate(val, &l.NotSelectedPatchCount)
			delete(rawMsg, key)
		case "pendingPatchCount":
			err = unpopulate(val, &l.PendingPatchCount)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &l.StartTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &l.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// LinuxConfiguration - Specifies the Linux operating system settings on the virtual machine.
// For a list of supported Linux distributions, see Linux on Azure-Endorsed Distributions [https://docs.microsoft.com/azure/virtual-machines/linux/endorsed-distros].
type LinuxConfiguration struct {
	// Specifies whether password authentication should be disabled.
	DisablePasswordAuthentication *bool `json:"disablePasswordAuthentication,omitempty"`

	// [Preview Feature] Specifies settings related to VM Guest Patching on Linux.
	PatchSettings *LinuxPatchSettings `json:"patchSettings,omitempty"`

	// Indicates whether virtual machine agent should be provisioned on the virtual machine.
	// When this property is not specified in the request body, default behavior is to set it to true. This will ensure that VM
	// Agent is installed on the VM so that extensions can be added to the VM later.
	ProvisionVMAgent *bool `json:"provisionVMAgent,omitempty"`

	// Specifies the ssh key configuration for a Linux OS.
	SSH *SSHConfiguration `json:"ssh,omitempty"`
}

// LinuxParameters - Input for InstallPatches on a Linux VM, as directly received by the API
type LinuxParameters struct {
	// The update classifications to select when installing patches for Linux.
	ClassificationsToInclude []*VMGuestPatchClassificationLinux `json:"classificationsToInclude,omitempty"`

	// This is used as a maintenance run identifier for Auto VM Guest Patching in Linux.
	MaintenanceRunID *string `json:"maintenanceRunId,omitempty"`

	// packages to exclude in the patch operation. Format: packageName_packageVersion
	PackageNameMasksToExclude []*string `json:"packageNameMasksToExclude,omitempty"`

	// packages to include in the patch operation. Format: packageName_packageVersion
	PackageNameMasksToInclude []*string `json:"packageNameMasksToInclude,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type LinuxParameters.
func (l LinuxParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "classificationsToInclude", l.ClassificationsToInclude)
	populate(objectMap, "maintenanceRunId", l.MaintenanceRunID)
	populate(objectMap, "packageNameMasksToExclude", l.PackageNameMasksToExclude)
	populate(objectMap, "packageNameMasksToInclude", l.PackageNameMasksToInclude)
	return json.Marshal(objectMap)
}

// LinuxPatchSettings - Specifies settings related to VM Guest Patching on Linux.
type LinuxPatchSettings struct {
	// Specifies the mode of VM Guest Patch Assessment for the IaaS virtual machine.
	// Possible values are:
	// ImageDefault - You control the timing of patch assessments on a virtual machine.
	// AutomaticByPlatform - The platform will trigger periodic patch assessments. The property provisionVMAgent must be true.
	AssessmentMode *LinuxPatchAssessmentMode `json:"assessmentMode,omitempty"`

	// Specifies additional settings for patch mode AutomaticByPlatform in VM Guest Patching on Linux.
	AutomaticByPlatformSettings *LinuxVMGuestPatchAutomaticByPlatformSettings `json:"automaticByPlatformSettings,omitempty"`

	// Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual machines associated to virtual machine scale
	// set with OrchestrationMode as Flexible.
	// Possible values are:
	// ImageDefault - The virtual machine's default patching configuration is used.
	// AutomaticByPlatform - The virtual machine will be automatically updated by the platform. The property provisionVMAgent
	// must be true
	PatchMode *LinuxVMGuestPatchMode `json:"patchMode,omitempty"`
}

// LinuxVMGuestPatchAutomaticByPlatformSettings - Specifies additional settings to be applied when patch mode AutomaticByPlatform
// is selected in Linux patch settings.
type LinuxVMGuestPatchAutomaticByPlatformSettings struct {
	// Specifies the reboot setting for all AutomaticByPlatform patch installation operations.
	RebootSetting *LinuxVMGuestPatchAutomaticByPlatformRebootSetting `json:"rebootSetting,omitempty"`
}

// MaintenanceRedeployStatus - Maintenance Operation Status.
type MaintenanceRedeployStatus struct {
	// True, if customer is allowed to perform Maintenance.
	IsCustomerInitiatedMaintenanceAllowed *bool `json:"isCustomerInitiatedMaintenanceAllowed,omitempty"`

	// Message returned for the last Maintenance Operation.
	LastOperationMessage *string `json:"lastOperationMessage,omitempty"`

	// The Last Maintenance Operation Result Code.
	LastOperationResultCode *MaintenanceOperationResultCodeTypes `json:"lastOperationResultCode,omitempty"`

	// End Time for the Maintenance Window.
	MaintenanceWindowEndTime *time.Time `json:"maintenanceWindowEndTime,omitempty"`

	// Start Time for the Maintenance Window.
	MaintenanceWindowStartTime *time.Time `json:"maintenanceWindowStartTime,omitempty"`

	// End Time for the Pre Maintenance Window.
	PreMaintenanceWindowEndTime *time.Time `json:"preMaintenanceWindowEndTime,omitempty"`

	// Start Time for the Pre Maintenance Window.
	PreMaintenanceWindowStartTime *time.Time `json:"preMaintenanceWindowStartTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MaintenanceRedeployStatus.
func (m MaintenanceRedeployStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "isCustomerInitiatedMaintenanceAllowed", m.IsCustomerInitiatedMaintenanceAllowed)
	populate(objectMap, "lastOperationMessage", m.LastOperationMessage)
	populate(objectMap, "lastOperationResultCode", m.LastOperationResultCode)
	populateTimeRFC3339(objectMap, "maintenanceWindowEndTime", m.MaintenanceWindowEndTime)
	populateTimeRFC3339(objectMap, "maintenanceWindowStartTime", m.MaintenanceWindowStartTime)
	populateTimeRFC3339(objectMap, "preMaintenanceWindowEndTime", m.PreMaintenanceWindowEndTime)
	populateTimeRFC3339(objectMap, "preMaintenanceWindowStartTime", m.PreMaintenanceWindowStartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MaintenanceRedeployStatus.
func (m *MaintenanceRedeployStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isCustomerInitiatedMaintenanceAllowed":
			err = unpopulate(val, &m.IsCustomerInitiatedMaintenanceAllowed)
			delete(rawMsg, key)
		case "lastOperationMessage":
			err = unpopulate(val, &m.LastOperationMessage)
			delete(rawMsg, key)
		case "lastOperationResultCode":
			err = unpopulate(val, &m.LastOperationResultCode)
			delete(rawMsg, key)
		case "maintenanceWindowEndTime":
			err = unpopulateTimeRFC3339(val, &m.MaintenanceWindowEndTime)
			delete(rawMsg, key)
		case "maintenanceWindowStartTime":
			err = unpopulateTimeRFC3339(val, &m.MaintenanceWindowStartTime)
			delete(rawMsg, key)
		case "preMaintenanceWindowEndTime":
			err = unpopulateTimeRFC3339(val, &m.PreMaintenanceWindowEndTime)
			delete(rawMsg, key)
		case "preMaintenanceWindowStartTime":
			err = unpopulateTimeRFC3339(val, &m.PreMaintenanceWindowStartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ManagedDiskParameters - The parameters of a managed disk.
type ManagedDiskParameters struct {
	// Specifies the customer managed disk encryption set resource id for the managed disk.
	DiskEncryptionSet *DiskEncryptionSetParameters `json:"diskEncryptionSet,omitempty"`

	// Resource Id
	ID *string `json:"id,omitempty"`

	// Specifies the security profile for the managed disk.
	SecurityProfile *VMDiskSecurityProfile `json:"securityProfile,omitempty"`

	// Specifies the storage account type for the managed disk. NOTE: UltraSSD_LRS can only be used with data disks, it cannot
	// be used with OS Disk.
	StorageAccountType *StorageAccountTypes `json:"storageAccountType,omitempty"`
}

// NetworkInterfaceReference - Describes a network interface reference.
type NetworkInterfaceReference struct {
	// Resource Id
	ID *string `json:"id,omitempty"`

	// Describes a network interface reference properties.
	Properties *NetworkInterfaceReferenceProperties `json:"properties,omitempty"`
}

// NetworkInterfaceReferenceProperties - Describes a network interface reference properties.
type NetworkInterfaceReferenceProperties struct {
	// Specify what happens to the network interface when the VM is deleted
	DeleteOption *DeleteOptions `json:"deleteOption,omitempty"`

	// Specifies the primary network interface in case the virtual machine has more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`
}

// NetworkProfile - Specifies the network interfaces or the networking configuration of the virtual machine.
type NetworkProfile struct {
	// specifies the Microsoft.Network API version used when creating networking resources in the Network Interface Configurations
	NetworkAPIVersion *NetworkAPIVersion `json:"networkApiVersion,omitempty"`

	// Specifies the networking configurations that will be used to create the virtual machine networking resources.
	NetworkInterfaceConfigurations []*VirtualMachineNetworkInterfaceConfiguration `json:"networkInterfaceConfigurations,omitempty"`

	// Specifies the list of resource Ids for the network interfaces associated with the virtual machine.
	NetworkInterfaces []*NetworkInterfaceReference `json:"networkInterfaces,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NetworkProfile.
func (n NetworkProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "networkApiVersion", n.NetworkAPIVersion)
	populate(objectMap, "networkInterfaceConfigurations", n.NetworkInterfaceConfigurations)
	populate(objectMap, "networkInterfaces", n.NetworkInterfaces)
	return json.Marshal(objectMap)
}

// OSDisk - Specifies information about the operating system disk used by the virtual machine.
// For more information about disks, see About disks and VHDs for Azure virtual machines [https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview].
type OSDisk struct {
	// REQUIRED; Specifies how the virtual machine should be created.
	// Possible values are:
	// Attach \u2013 This value is used when you are using a specialized disk to create the virtual machine.
	// FromImage \u2013 This value is used when you are using an image to create the virtual machine. If you are using a platform
	// image, you also use the imageReference element described above. If you are
	// using a marketplace image, you also use the plan element previously described.
	CreateOption *DiskCreateOptionTypes `json:"createOption,omitempty"`

	// Specifies the caching requirements.
	// Possible values are:
	// None
	// ReadOnly
	// ReadWrite
	// Default: None for Standard storage. ReadOnly for Premium storage.
	Caching *CachingTypes `json:"caching,omitempty"`

	// Specifies whether OS Disk should be deleted or detached upon VM deletion.
	// Possible values:
	// Delete If this value is used, the OS disk is deleted when VM is deleted.
	// Detach If this value is used, the os disk is retained after VM is deleted.
	// The default value is set to detach. For an ephemeral OS Disk, the default value is set to Delete. User cannot change the
	// delete option for ephemeral OS Disk.
	DeleteOption *DiskDeleteOptionTypes `json:"deleteOption,omitempty"`

	// Specifies the ephemeral Disk Settings for the operating system disk used by the virtual machine.
	DiffDiskSettings *DiffDiskSettings `json:"diffDiskSettings,omitempty"`

	// Specifies the size of an empty data disk in gigabytes. This element can be used to overwrite the size of the disk in a
	// virtual machine image.
	// This value cannot be larger than 1023 GB
	DiskSizeGB *int32 `json:"diskSizeGB,omitempty"`

	// Specifies the encryption settings for the OS Disk.
	// Minimum api-version: 2015-06-15
	EncryptionSettings *DiskEncryptionSettings `json:"encryptionSettings,omitempty"`

	// The source user image virtual hard disk. The virtual hard disk will be copied before being attached to the virtual machine.
	// If SourceImage is provided, the destination virtual hard drive must not
	// exist.
	Image *VirtualHardDisk `json:"image,omitempty"`

	// The managed disk parameters.
	ManagedDisk *ManagedDiskParameters `json:"managedDisk,omitempty"`

	// The disk name.
	Name *string `json:"name,omitempty"`

	// This property allows you to specify the type of the OS that is included in the disk if creating a VM from user-image or
	// a specialized VHD.
	// Possible values are:
	// Windows
	// Linux
	OSType *OperatingSystemTypes `json:"osType,omitempty"`

	// The virtual hard disk.
	Vhd *VirtualHardDisk `json:"vhd,omitempty"`

	// Specifies whether writeAccelerator should be enabled or disabled on the disk.
	WriteAcceleratorEnabled *bool `json:"writeAcceleratorEnabled,omitempty"`
}

// OSProfile - Specifies the operating system settings for the virtual machine. Some of the settings cannot be changed once
// VM is provisioned.
type OSProfile struct {
	// Specifies the password of the administrator account.
	// Minimum-length (Windows): 8 characters
	// Minimum-length (Linux): 6 characters
	// Max-length (Windows): 123 characters
	// Max-length (Linux): 72 characters
	// Complexity requirements: 3 out of 4 conditions below need to be fulfilled
	// Has lower characters
	// Has upper characters
	// Has a digit
	// Has a special character (Regex match [\W_])
	// Disallowed values: "abc@123", "P@$$w0rd", "P@ssw0rd", "P@ssword123", "Pa$$word", "pass@word1", "Password!", "Password1",
	// "Password22", "iloveyou!"
	// For resetting the password, see How to reset the Remote Desktop service or its login password in a Windows VM [https://docs.microsoft.com/troubleshoot/azure/virtual-machines/reset-rdp]
	// For resetting root password, see Manage users, SSH, and check or repair disks on Azure Linux VMs using the VMAccess Extension
	// [https://docs.microsoft.com/troubleshoot/azure/virtual-machines/troubleshoot-ssh-connection]
	AdminPassword *string `json:"adminPassword,omitempty"`

	// Specifies the name of the administrator account.
	// This property cannot be updated after the VM is created.
	// Windows-only restriction: Cannot end in "."
	// Disallowed values: "administrator", "admin", "user", "user1", "test", "user2", "test1", "user3", "admin1", "1", "123",
	// "a", "actuser", "adm", "admin2", "aspnet", "backup", "console", "david", "guest",
	// "john", "owner", "root", "server", "sql", "support", "support_388945a0", "sys", "test2", "test3", "user4", "user5".
	// Minimum-length (Linux): 1 character
	// Max-length (Linux): 64 characters
	// Max-length (Windows): 20 characters.
	AdminUsername *string `json:"adminUsername,omitempty"`

	// Specifies whether extension operations should be allowed on the virtual machine.
	// This may only be set to False when no extensions are present on the virtual machine.
	AllowExtensionOperations *bool `json:"allowExtensionOperations,omitempty"`

	// Specifies the host OS name of the virtual machine.
	// This name cannot be updated after the VM is created.
	// Max-length (Windows): 15 characters
	// Max-length (Linux): 64 characters.
	// For naming conventions and restrictions see Azure infrastructure services implementation guidelines [https://docs.microsoft.com/azure/azure-resource-manager/management/resource-name-rules].
	ComputerName *string `json:"computerName,omitempty"`

	// Specifies a base-64 encoded string of custom data. The base-64 encoded string is decoded to a binary array that is saved
	// as a file on the Virtual Machine. The maximum length of the binary array is
	// 65535 bytes.
	// Note: Do not pass any secrets or passwords in customData property
	// This property cannot be updated after the VM is created.
	// customData is passed to the VM to be saved as a file, for more information see Custom Data on Azure VMs [https://azure.microsoft.com/blog/custom-data-and-cloud-init-on-windows-azure/]
	// For using cloud-init for your Linux VM, see Using cloud-init to customize a Linux VM during creation [https://docs.microsoft.com/azure/virtual-machines/linux/using-cloud-init]
	CustomData *string `json:"customData,omitempty"`

	// Specifies the Linux operating system settings on the virtual machine.
	// For a list of supported Linux distributions, see Linux on Azure-Endorsed Distributions [https://docs.microsoft.com/azure/virtual-machines/linux/endorsed-distros].
	LinuxConfiguration *LinuxConfiguration `json:"linuxConfiguration,omitempty"`

	// Optional property which must either be set to True or omitted.
	RequireGuestProvisionSignal *bool `json:"requireGuestProvisionSignal,omitempty"`

	// Specifies set of certificates that should be installed onto the virtual machine. To install certificates on a virtual machine
	// it is recommended to use the Azure Key Vault virtual machine extension for
	// Linux [https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-linux] or the Azure Key Vault virtual machine
	// extension for Windows
	// [https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-windows].
	Secrets []*VaultSecretGroup `json:"secrets,omitempty"`

	// Specifies Windows operating system settings on the virtual machine.
	WindowsConfiguration *WindowsConfiguration `json:"windowsConfiguration,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OSProfile.
func (o OSProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "adminPassword", o.AdminPassword)
	populate(objectMap, "adminUsername", o.AdminUsername)
	populate(objectMap, "allowExtensionOperations", o.AllowExtensionOperations)
	populate(objectMap, "computerName", o.ComputerName)
	populate(objectMap, "customData", o.CustomData)
	populate(objectMap, "linuxConfiguration", o.LinuxConfiguration)
	populate(objectMap, "requireGuestProvisionSignal", o.RequireGuestProvisionSignal)
	populate(objectMap, "secrets", o.Secrets)
	populate(objectMap, "windowsConfiguration", o.WindowsConfiguration)
	return json.Marshal(objectMap)
}

// PatchInstallationDetail - Information about a specific patch that was encountered during an installation action.
type PatchInstallationDetail struct {
	// READ-ONLY; The classification(s) of the patch as provided by the patch publisher.
	Classifications []*string `json:"classifications,omitempty" azure:"ro"`

	// READ-ONLY; The state of the patch after the installation operation completed.
	InstallationState *PatchInstallationState `json:"installationState,omitempty" azure:"ro"`

	// READ-ONLY; The KBID of the patch. Only applies to Windows patches.
	KbID *string `json:"kbId,omitempty" azure:"ro"`

	// READ-ONLY; The friendly name of the patch.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; A unique identifier for the patch.
	PatchID *string `json:"patchId,omitempty" azure:"ro"`

	// READ-ONLY; The version string of the package. It may conform to Semantic Versioning. Only applies to Linux.
	Version *string `json:"version,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type PatchInstallationDetail.
func (p PatchInstallationDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "classifications", p.Classifications)
	populate(objectMap, "installationState", p.InstallationState)
	populate(objectMap, "kbId", p.KbID)
	populate(objectMap, "name", p.Name)
	populate(objectMap, "patchId", p.PatchID)
	populate(objectMap, "version", p.Version)
	return json.Marshal(objectMap)
}

// PatchSettings - Specifies settings related to VM Guest Patching on Windows.
type PatchSettings struct {
	// Specifies the mode of VM Guest patch assessment for the IaaS virtual machine.
	// Possible values are:
	// ImageDefault - You control the timing of patch assessments on a virtual machine.
	// AutomaticByPlatform - The platform will trigger periodic patch assessments. The property provisionVMAgent must be true.
	AssessmentMode *WindowsPatchAssessmentMode `json:"assessmentMode,omitempty"`

	// Specifies additional settings for patch mode AutomaticByPlatform in VM Guest Patching on Windows.
	AutomaticByPlatformSettings *WindowsVMGuestPatchAutomaticByPlatformSettings `json:"automaticByPlatformSettings,omitempty"`

	// Enables customers to patch their Azure VMs without requiring a reboot. For enableHotpatching, the 'provisionVMAgent' must
	// be set to true and 'patchMode' must be set to 'AutomaticByPlatform'.
	EnableHotpatching *bool `json:"enableHotpatching,omitempty"`

	// Specifies the mode of VM Guest Patching to IaaS virtual machine or virtual machines associated to virtual machine scale
	// set with OrchestrationMode as Flexible.
	// Possible values are:
	// Manual - You control the application of patches to a virtual machine. You do this by applying patches manually inside the
	// VM. In this mode, automatic updates are disabled; the property
	// WindowsConfiguration.enableAutomaticUpdates must be false
	// AutomaticByOS - The virtual machine will automatically be updated by the OS. The property WindowsConfiguration.enableAutomaticUpdates
	// must be true.
	// AutomaticByPlatform - the virtual machine will automatically updated by the platform. The properties provisionVMAgent and
	// WindowsConfiguration.enableAutomaticUpdates must be true
	PatchMode *WindowsVMGuestPatchMode `json:"patchMode,omitempty"`
}

// Plan - Specifies information about the marketplace image used to create the virtual machine. This element is only used
// for marketplace images. Before you can use a marketplace image from an API, you must
// enable the image for programmatic use. In the Azure portal, find the marketplace image that you want to use and then click
// Want to deploy programmatically, Get Started ->. Enter any required
// information and then click Save.
type Plan struct {
	// The plan ID.
	Name *string `json:"name,omitempty"`

	// Specifies the product of the image from the marketplace. This is the same value as Offer under the imageReference element.
	Product *string `json:"product,omitempty"`

	// The promotion code.
	PromotionCode *string `json:"promotionCode,omitempty"`

	// The publisher ID.
	Publisher *string `json:"publisher,omitempty"`
}

// PublicIPAddressSKU - Describes the public IP Sku. It can only be set with OrchestrationMode as Flexible.
type PublicIPAddressSKU struct {
	// Specify public IP sku name
	Name *PublicIPAddressSKUName `json:"name,omitempty"`

	// Specify public IP sku tier
	Tier *PublicIPAddressSKUTier `json:"tier,omitempty"`
}

// Resource - The Resource model definition.
type Resource struct {
	// REQUIRED; Resource location
	Location *string `json:"location,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// ResourceWithOptionalLocation - The Resource model definition with location property as optional.
type ResourceWithOptionalLocation struct {
	// Resource location
	Location *string `json:"location,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceWithOptionalLocation.
func (r ResourceWithOptionalLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// RetrieveBootDiagnosticsDataResult - The SAS URIs of the console screenshot and serial log blobs.
type RetrieveBootDiagnosticsDataResult struct {
	// READ-ONLY; The console screenshot blob URI
	ConsoleScreenshotBlobURI *string `json:"consoleScreenshotBlobUri,omitempty" azure:"ro"`

	// READ-ONLY; The serial console log blob URI.
	SerialConsoleLogBlobURI *string `json:"serialConsoleLogBlobUri,omitempty" azure:"ro"`
}

// RunCommandDocument - Describes the properties of a Run Command.
type RunCommandDocument struct {
	// REQUIRED; The VM run command description.
	Description *string `json:"description,omitempty"`

	// REQUIRED; The VM run command id.
	ID *string `json:"id,omitempty"`

	// REQUIRED; The VM run command label.
	Label *string `json:"label,omitempty"`

	// REQUIRED; The Operating System type.
	OSType *OperatingSystemTypes `json:"osType,omitempty"`

	// REQUIRED; The VM run command schema.
	Schema *string `json:"$schema,omitempty"`

	// REQUIRED; The script to be executed.
	Script []*string `json:"script,omitempty"`

	// The parameters used by the script.
	Parameters []*RunCommandParameterDefinition `json:"parameters,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RunCommandDocument.
func (r RunCommandDocument) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", r.Description)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "label", r.Label)
	populate(objectMap, "osType", r.OSType)
	populate(objectMap, "parameters", r.Parameters)
	populate(objectMap, "$schema", r.Schema)
	populate(objectMap, "script", r.Script)
	return json.Marshal(objectMap)
}

// RunCommandDocumentBase - Describes the properties of a Run Command metadata.
type RunCommandDocumentBase struct {
	// REQUIRED; The VM run command description.
	Description *string `json:"description,omitempty"`

	// REQUIRED; The VM run command id.
	ID *string `json:"id,omitempty"`

	// REQUIRED; The VM run command label.
	Label *string `json:"label,omitempty"`

	// REQUIRED; The Operating System type.
	OSType *OperatingSystemTypes `json:"osType,omitempty"`

	// REQUIRED; The VM run command schema.
	Schema *string `json:"$schema,omitempty"`
}

// RunCommandInput - Capture Virtual Machine parameters.
type RunCommandInput struct {
	// REQUIRED; The run command id.
	CommandID *string `json:"commandId,omitempty"`

	// The run command parameters.
	Parameters []*RunCommandInputParameter `json:"parameters,omitempty"`

	// Optional. The script to be executed. When this value is given, the given script will override the default script of the
	// command.
	Script []*string `json:"script,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RunCommandInput.
func (r RunCommandInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "commandId", r.CommandID)
	populate(objectMap, "parameters", r.Parameters)
	populate(objectMap, "script", r.Script)
	return json.Marshal(objectMap)
}

// RunCommandInputParameter - Describes the properties of a run command parameter.
type RunCommandInputParameter struct {
	// REQUIRED; The run command parameter name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The run command parameter value.
	Value *string `json:"value,omitempty"`
}

// RunCommandListResult - The List Virtual Machine operation response.
type RunCommandListResult struct {
	// REQUIRED; The list of virtual machine run commands.
	Value []*RunCommandDocumentBase `json:"value,omitempty"`

	// The uri to fetch the next page of run commands. Call ListNext() with this to fetch the next page of run commands.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RunCommandListResult.
func (r RunCommandListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// RunCommandParameterDefinition - Describes the properties of a run command parameter.
type RunCommandParameterDefinition struct {
	// REQUIRED; The run command parameter name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The run command parameter type.
	Type *string `json:"type,omitempty"`

	// The run command parameter default value.
	DefaultValue *string `json:"defaultValue,omitempty"`

	// The run command parameter required.
	Required *bool `json:"required,omitempty"`
}

type RunCommandResult struct {
	// Run command operation response.
	Value []*InstanceViewStatus `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RunCommandResult.
func (r RunCommandResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// SSHConfiguration - SSH configuration for Linux based VMs running on Azure
type SSHConfiguration struct {
	// The list of SSH public keys used to authenticate with linux based VMs.
	PublicKeys []*SSHPublicKey `json:"publicKeys,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SSHConfiguration.
func (s SSHConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "publicKeys", s.PublicKeys)
	return json.Marshal(objectMap)
}

// SSHPublicKey - Contains information about SSH certificate public key and the path on the Linux VM where the public key
// is placed.
type SSHPublicKey struct {
	// SSH public key certificate used to authenticate with the VM through ssh. The key needs to be at least 2048-bit and in ssh-rsa
	// format.
	// For creating ssh keys, see [Create SSH keys on Linux and Mac for Linux VMs in Azure]https://docs.microsoft.com/azure/virtual-machines/linux/create-ssh-keys-detailed).
	KeyData *string `json:"keyData,omitempty"`

	// Specifies the full path on the created VM where ssh public key is stored. If the file already exists, the specified key
	// is appended to the file. Example: /home/user/.ssh/authorized_keys
	Path *string `json:"path,omitempty"`
}

type ScheduledEventsProfile struct {
	// Specifies Terminate Scheduled Event related configurations.
	TerminateNotificationProfile *TerminateNotificationProfile `json:"terminateNotificationProfile,omitempty"`
}

// SecurityProfile - Specifies the Security profile settings for the virtual machine or virtual machine scale set.
type SecurityProfile struct {
	// This property can be used by user in the request to enable or disable the Host Encryption for the virtual machine or virtual
	// machine scale set. This will enable the encryption for all the disks
	// including Resource/Temp disk at host itself.
	// Default: The Encryption at host will be disabled unless this property is set to true for the resource.
	EncryptionAtHost *bool `json:"encryptionAtHost,omitempty"`

	// Specifies the SecurityType of the virtual machine. It has to be set to any specified value to enable UefiSettings.
	// Default: UefiSettings will not be enabled unless this property is set.
	SecurityType *SecurityTypes `json:"securityType,omitempty"`

	// Specifies the security settings like secure boot and vTPM used while creating the virtual machine.
	// Minimum api-version: 2020-12-01
	UefiSettings *UefiSettings `json:"uefiSettings,omitempty"`
}

// StorageProfile - Specifies the storage settings for the virtual machine disks.
type StorageProfile struct {
	// Specifies the parameters that are used to add a data disk to a virtual machine.
	// For more information about disks, see About disks and VHDs for Azure virtual machines [https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview].
	DataDisks []*DataDisk `json:"dataDisks,omitempty"`

	// Specifies information about the image to use. You can specify information about platform images, marketplace images, or
	// virtual machine images. This element is required when you want to use a platform
	// image, marketplace image, or virtual machine image, but is not used in other creation operations.
	ImageReference *ImageReference `json:"imageReference,omitempty"`

	// Specifies information about the operating system disk used by the virtual machine.
	// For more information about disks, see About disks and VHDs for Azure virtual machines [https://docs.microsoft.com/azure/virtual-machines/managed-disks-overview].
	OSDisk *OSDisk `json:"osDisk,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageProfile.
func (s StorageProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataDisks", s.DataDisks)
	populate(objectMap, "imageReference", s.ImageReference)
	populate(objectMap, "osDisk", s.OSDisk)
	return json.Marshal(objectMap)
}

type SubResource struct {
	// Resource Id
	ID *string `json:"id,omitempty"`
}

type SubResourceReadOnly struct {
	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`
}

type TerminateNotificationProfile struct {
	// Specifies whether the Terminate Scheduled event is enabled or disabled.
	Enable *bool `json:"enable,omitempty"`

	// Configurable length of time a Virtual Machine being deleted will have to potentially approve the Terminate Scheduled Event
	// before the event is auto approved (timed out). The configuration must be
	// specified in ISO 8601 format, the default value is 5 minutes (PT5M)
	NotBeforeTimeout *string `json:"notBeforeTimeout,omitempty"`
}

// UefiSettings - Specifies the security settings like secure boot and vTPM used while creating the virtual machine.
// Minimum api-version: 2020-12-01
type UefiSettings struct {
	// Specifies whether secure boot should be enabled on the virtual machine.
	// Minimum api-version: 2020-12-01
	SecureBootEnabled *bool `json:"secureBootEnabled,omitempty"`

	// Specifies whether vTPM should be enabled on the virtual machine.
	// Minimum api-version: 2020-12-01
	VTpmEnabled *bool `json:"vTpmEnabled,omitempty"`
}

// UpdateResource - The Update Resource model definition.
type UpdateResource struct {
	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UpdateResource.
func (u UpdateResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "tags", u.Tags)
	return json.Marshal(objectMap)
}

type UserAssignedIdentitiesValue struct {
	// READ-ONLY; The client id of user assigned identity.
	ClientID *string `json:"clientId,omitempty" azure:"ro"`

	// READ-ONLY; The principal id of user assigned identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`
}

// VMDiskSecurityProfile - Specifies the security profile settings for the managed disk.
// NOTE: It can only be set for Confidential VMs
type VMDiskSecurityProfile struct {
	// Specifies the customer managed disk encryption set resource id for the managed disk that is used for Customer Managed Key
	// encrypted ConfidentialVM OS Disk and VMGuest blob.
	DiskEncryptionSet *DiskEncryptionSetParameters `json:"diskEncryptionSet,omitempty"`

	// Specifies the EncryptionType of the managed disk.
	// It is set to DiskWithVMGuestState for encryption of the managed disk along with VMGuestState blob, and VMGuestStateOnly
	// for encryption of just the VMGuestState blob.
	// NOTE: It can be set for only Confidential VMs.
	SecurityEncryptionType *SecurityEncryptionTypes `json:"securityEncryptionType,omitempty"`
}

// VMGalleryApplication - Specifies the required information to reference a compute gallery application version
type VMGalleryApplication struct {
	// REQUIRED; Specifies the GalleryApplicationVersion resource id on the form of
	// /subscriptions/{SubscriptionId}/resourceGroups/{ResourceGroupName}/providers/Microsoft.Compute/galleries/{galleryName}/applications/{application}/versions/{version}
	PackageReferenceID *string `json:"packageReferenceId,omitempty"`

	// Optional, Specifies the uri to an azure blob that will replace the default configuration for the package if provided
	ConfigurationReference *string `json:"configurationReference,omitempty"`

	// If set to true, when a new Gallery Application version is available in PIR/SIG, it will be automatically updated for the
	// VM/VMSS
	EnableAutomaticUpgrade *bool `json:"enableAutomaticUpgrade,omitempty"`

	// Optional, Specifies the order in which the packages have to be installed
	Order *int32 `json:"order,omitempty"`

	// Optional, Specifies a passthrough value for more generic context.
	Tags *string `json:"tags,omitempty"`

	// Optional, If true, any failure for any operation in the VmApplication will fail the deployment
	TreatFailureAsDeploymentFailure *bool `json:"treatFailureAsDeploymentFailure,omitempty"`
}

// VMSizeProperties - Specifies VM Size Property settings on the virtual machine.
type VMSizeProperties struct {
	// Specifies the number of vCPUs available for the VM.
	// When this property is not specified in the request body the default behavior is to set it to the value of vCPUs available
	// for that VM size exposed in api response of List all available virtual machine
	// sizes in a region [https://docs.microsoft.com/en-us/rest/api/compute/resource-skus/list] .
	VCPUsAvailable *int32 `json:"vCPUsAvailable,omitempty"`

	// Specifies the vCPU to physical core ratio.
	// When this property is not specified in the request body the default behavior is set to the value of vCPUsPerCore for the
	// VM Size exposed in api response of List all available virtual machine sizes in
	// a region [https://docs.microsoft.com/en-us/rest/api/compute/resource-skus/list]
	// Setting this property to 1 also means that hyper-threading is disabled.
	VCPUsPerCore *int32 `json:"vCPUsPerCore,omitempty"`
}

// VaultCertificate - Describes a single certificate reference in a Key Vault, and where the certificate should reside on
// the VM.
type VaultCertificate struct {
	// For Windows VMs, specifies the certificate store on the Virtual Machine to which the certificate should be added. The specified
	// certificate store is implicitly in the LocalMachine account.
	// For Linux VMs, the certificate file is placed under the /var/lib/waagent directory, with the file name <UppercaseThumbprint>.crt
	// for the X509 certificate file and <UppercaseThumbprint>.prv for private
	// key. Both of these files are .pem formatted.
	CertificateStore *string `json:"certificateStore,omitempty"`

	// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault,
	// see Add a key or secret to the key vault
	// [https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add]. In this case, your certificate needs to be It
	// is the Base64 encoding of the following JSON Object which is encoded in UTF-8:
	// {
	// "data":"",
	// "dataType":"pfx",
	// "password":""
	// }
	// To install certificates on a virtual machine it is recommended to use the Azure Key Vault virtual machine extension for
	// Linux
	// [https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-linux] or the Azure Key Vault virtual machine extension
	// for Windows
	// [https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-windows].
	CertificateURL *string `json:"certificateUrl,omitempty"`
}

// VaultSecretGroup - Describes a set of certificates which are all in the same Key Vault.
type VaultSecretGroup struct {
	// The relative URL of the Key Vault containing all of the certificates in VaultCertificates.
	SourceVault *SubResource `json:"sourceVault,omitempty"`

	// The list of key vault references in SourceVault which contain certificates.
	VaultCertificates []*VaultCertificate `json:"vaultCertificates,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VaultSecretGroup.
func (v VaultSecretGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "sourceVault", v.SourceVault)
	populate(objectMap, "vaultCertificates", v.VaultCertificates)
	return json.Marshal(objectMap)
}

// VirtualHardDisk - Describes the uri of a disk.
type VirtualHardDisk struct {
	// Specifies the virtual hard disk's uri.
	URI *string `json:"uri,omitempty"`
}

// VirtualMachine - Describes a Virtual Machine.
type VirtualMachine struct {
	// REQUIRED; Resource location
	Location *string `json:"location,omitempty"`

	// The extended location of the Virtual Machine.
	ExtendedLocation *ExtendedLocation `json:"extendedLocation,omitempty"`

	// The identity of the virtual machine, if configured.
	Identity *VirtualMachineIdentity `json:"identity,omitempty"`

	// Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace
	// images. Before you can use a marketplace image from an API, you must
	// enable the image for programmatic use. In the Azure portal, find the marketplace image that you want to use and then click
	// Want to deploy programmatically, Get Started ->. Enter any required
	// information and then click Save.
	Plan *Plan `json:"plan,omitempty"`

	// Describes the properties of a Virtual Machine.
	Properties *VirtualMachineProperties `json:"properties,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`

	// The virtual machine zones.
	Zones []*string `json:"zones,omitempty"`

	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The virtual machine child extension resources.
	Resources []*VirtualMachineExtension `json:"resources,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachine.
func (v VirtualMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extendedLocation", v.ExtendedLocation)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "identity", v.Identity)
	populate(objectMap, "location", v.Location)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "plan", v.Plan)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "resources", v.Resources)
	populate(objectMap, "tags", v.Tags)
	populate(objectMap, "type", v.Type)
	populate(objectMap, "zones", v.Zones)
	return json.Marshal(objectMap)
}

// VirtualMachineAgentInstanceView - The instance view of the VM Agent running on the virtual machine.
type VirtualMachineAgentInstanceView struct {
	// The virtual machine extension handler instance view.
	ExtensionHandlers []*VirtualMachineExtensionHandlerInstanceView `json:"extensionHandlers,omitempty"`

	// The resource status information.
	Statuses []*InstanceViewStatus `json:"statuses,omitempty"`

	// The VM Agent full version.
	VMAgentVersion *string `json:"vmAgentVersion,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineAgentInstanceView.
func (v VirtualMachineAgentInstanceView) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extensionHandlers", v.ExtensionHandlers)
	populate(objectMap, "statuses", v.Statuses)
	populate(objectMap, "vmAgentVersion", v.VMAgentVersion)
	return json.Marshal(objectMap)
}

// VirtualMachineAssessPatchesResult - Describes the properties of an AssessPatches result.
type VirtualMachineAssessPatchesResult struct {
	// READ-ONLY; The activity ID of the operation that produced this result. It is used to correlate across CRP and extension
	// logs.
	AssessmentActivityID *string `json:"assessmentActivityId,omitempty" azure:"ro"`

	// READ-ONLY; The list of patches that have been detected as available for installation.
	AvailablePatches []*VirtualMachineSoftwarePatchProperties `json:"availablePatches,omitempty" azure:"ro"`

	// READ-ONLY; The number of critical or security patches that have been detected as available and not yet installed.
	CriticalAndSecurityPatchCount *int32 `json:"criticalAndSecurityPatchCount,omitempty" azure:"ro"`

	// READ-ONLY; The errors that were encountered during execution of the operation. The details array contains the list of them.
	Error *APIError `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; The number of all available patches excluding critical and security.
	OtherPatchCount *int32 `json:"otherPatchCount,omitempty" azure:"ro"`

	// READ-ONLY; The overall reboot status of the VM. It will be true when partially installed patches require a reboot to complete
	// installation but the reboot has not yet occurred.
	RebootPending *bool `json:"rebootPending,omitempty" azure:"ro"`

	// READ-ONLY; The UTC timestamp when the operation began.
	StartDateTime *time.Time `json:"startDateTime,omitempty" azure:"ro"`

	// READ-ONLY; The overall success or failure status of the operation. It remains "InProgress" until the operation completes.
	// At that point it will become "Unknown", "Failed", "Succeeded", or
	// "CompletedWithWarnings."
	Status *PatchOperationStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineAssessPatchesResult.
func (v VirtualMachineAssessPatchesResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assessmentActivityId", v.AssessmentActivityID)
	populate(objectMap, "availablePatches", v.AvailablePatches)
	populate(objectMap, "criticalAndSecurityPatchCount", v.CriticalAndSecurityPatchCount)
	populate(objectMap, "error", v.Error)
	populate(objectMap, "otherPatchCount", v.OtherPatchCount)
	populate(objectMap, "rebootPending", v.RebootPending)
	populateTimeRFC3339(objectMap, "startDateTime", v.StartDateTime)
	populate(objectMap, "status", v.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineAssessPatchesResult.
func (v *VirtualMachineAssessPatchesResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assessmentActivityId":
			err = unpopulate(val, &v.AssessmentActivityID)
			delete(rawMsg, key)
		case "availablePatches":
			err = unpopulate(val, &v.AvailablePatches)
			delete(rawMsg, key)
		case "criticalAndSecurityPatchCount":
			err = unpopulate(val, &v.CriticalAndSecurityPatchCount)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &v.Error)
			delete(rawMsg, key)
		case "otherPatchCount":
			err = unpopulate(val, &v.OtherPatchCount)
			delete(rawMsg, key)
		case "rebootPending":
			err = unpopulate(val, &v.RebootPending)
			delete(rawMsg, key)
		case "startDateTime":
			err = unpopulateTimeRFC3339(val, &v.StartDateTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &v.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// VirtualMachineCaptureParameters - Capture Virtual Machine parameters.
type VirtualMachineCaptureParameters struct {
	// REQUIRED; The destination container name.
	DestinationContainerName *string `json:"destinationContainerName,omitempty"`

	// REQUIRED; Specifies whether to overwrite the destination virtual hard disk, in case of conflict.
	OverwriteVhds *bool `json:"overwriteVhds,omitempty"`

	// REQUIRED; The captured virtual hard disk's name prefix.
	VhdPrefix *string `json:"vhdPrefix,omitempty"`
}

// VirtualMachineCaptureResult - Output of virtual machine capture operation.
type VirtualMachineCaptureResult struct {
	// Resource Id
	ID *string `json:"id,omitempty"`

	// READ-ONLY; the version of the content
	ContentVersion *string `json:"contentVersion,omitempty" azure:"ro"`

	// READ-ONLY; parameters of the captured virtual machine
	Parameters map[string]interface{} `json:"parameters,omitempty" azure:"ro"`

	// READ-ONLY; a list of resource items of the captured virtual machine
	Resources []map[string]interface{} `json:"resources,omitempty" azure:"ro"`

	// READ-ONLY; the schema of the captured virtual machine
	Schema *string `json:"$schema,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineCaptureResult.
func (v VirtualMachineCaptureResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "contentVersion", v.ContentVersion)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "parameters", v.Parameters)
	populate(objectMap, "resources", v.Resources)
	populate(objectMap, "$schema", v.Schema)
	return json.Marshal(objectMap)
}

// VirtualMachineExtension - Describes a Virtual Machine Extension.
type VirtualMachineExtension struct {
	// Resource location
	Location *string `json:"location,omitempty"`

	// Describes the properties of a Virtual Machine Extension.
	Properties *VirtualMachineExtensionProperties `json:"properties,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineExtension.
func (v VirtualMachineExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", v.ID)
	populate(objectMap, "location", v.Location)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "tags", v.Tags)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// VirtualMachineExtensionHandlerInstanceView - The instance view of a virtual machine extension handler.
type VirtualMachineExtensionHandlerInstanceView struct {
	// The extension handler status.
	Status *InstanceViewStatus `json:"status,omitempty"`

	// Specifies the type of the extension; an example is "CustomScriptExtension".
	Type *string `json:"type,omitempty"`

	// Specifies the version of the script handler.
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`
}

// VirtualMachineExtensionInstanceView - The instance view of a virtual machine extension.
type VirtualMachineExtensionInstanceView struct {
	// The virtual machine extension name.
	Name *string `json:"name,omitempty"`

	// The resource status information.
	Statuses []*InstanceViewStatus `json:"statuses,omitempty"`

	// The resource status information.
	Substatuses []*InstanceViewStatus `json:"substatuses,omitempty"`

	// Specifies the type of the extension; an example is "CustomScriptExtension".
	Type *string `json:"type,omitempty"`

	// Specifies the version of the script handler.
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineExtensionInstanceView.
func (v VirtualMachineExtensionInstanceView) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", v.Name)
	populate(objectMap, "statuses", v.Statuses)
	populate(objectMap, "substatuses", v.Substatuses)
	populate(objectMap, "type", v.Type)
	populate(objectMap, "typeHandlerVersion", v.TypeHandlerVersion)
	return json.Marshal(objectMap)
}

// VirtualMachineExtensionProperties - Describes the properties of a Virtual Machine Extension.
type VirtualMachineExtensionProperties struct {
	// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed,
	// however, the extension will not upgrade minor versions unless redeployed, even
	// with this property set to true.
	AutoUpgradeMinorVersion *bool `json:"autoUpgradeMinorVersion,omitempty"`

	// Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension
	// available.
	EnableAutomaticUpgrade *bool `json:"enableAutomaticUpgrade,omitempty"`

	// How the extension handler should be forced to update even if the extension configuration has not changed.
	ForceUpdateTag *string `json:"forceUpdateTag,omitempty"`

	// The virtual machine extension instance view.
	InstanceView *VirtualMachineExtensionInstanceView `json:"instanceView,omitempty"`

	// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings map[string]interface{} `json:"protectedSettings,omitempty"`

	// The extensions protected settings that are passed by reference, and consumed from key vault
	ProtectedSettingsFromKeyVault map[string]interface{} `json:"protectedSettingsFromKeyVault,omitempty"`

	// The name of the extension handler publisher.
	Publisher *string `json:"publisher,omitempty"`

	// Json formatted public settings for the extension.
	Settings map[string]interface{} `json:"settings,omitempty"`

	// Indicates whether failures stemming from the extension will be suppressed (Operational failures such as not connecting
	// to the VM will not be suppressed regardless of this value). The default is false.
	SuppressFailures *bool `json:"suppressFailures,omitempty"`

	// Specifies the type of the extension; an example is "CustomScriptExtension".
	Type *string `json:"type,omitempty"`

	// Specifies the version of the script handler.
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`

	// READ-ONLY; The provisioning state, which only appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`
}

// VirtualMachineExtensionUpdate - Describes a Virtual Machine Extension.
type VirtualMachineExtensionUpdate struct {
	// Describes the properties of a Virtual Machine Extension.
	Properties *VirtualMachineExtensionUpdateProperties `json:"properties,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineExtensionUpdate.
func (v VirtualMachineExtensionUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "tags", v.Tags)
	return json.Marshal(objectMap)
}

// VirtualMachineExtensionUpdateProperties - Describes the properties of a Virtual Machine Extension.
type VirtualMachineExtensionUpdateProperties struct {
	// Indicates whether the extension should use a newer minor version if one is available at deployment time. Once deployed,
	// however, the extension will not upgrade minor versions unless redeployed, even
	// with this property set to true.
	AutoUpgradeMinorVersion *bool `json:"autoUpgradeMinorVersion,omitempty"`

	// Indicates whether the extension should be automatically upgraded by the platform if there is a newer version of the extension
	// available.
	EnableAutomaticUpgrade *bool `json:"enableAutomaticUpgrade,omitempty"`

	// How the extension handler should be forced to update even if the extension configuration has not changed.
	ForceUpdateTag *string `json:"forceUpdateTag,omitempty"`

	// The extension can contain either protectedSettings or protectedSettingsFromKeyVault or no protected settings at all.
	ProtectedSettings map[string]interface{} `json:"protectedSettings,omitempty"`

	// The extensions protected settings that are passed by reference, and consumed from key vault
	ProtectedSettingsFromKeyVault map[string]interface{} `json:"protectedSettingsFromKeyVault,omitempty"`

	// The name of the extension handler publisher.
	Publisher *string `json:"publisher,omitempty"`

	// Json formatted public settings for the extension.
	Settings map[string]interface{} `json:"settings,omitempty"`

	// Indicates whether failures stemming from the extension will be suppressed (Operational failures such as not connecting
	// to the VM will not be suppressed regardless of this value). The default is false.
	SuppressFailures *bool `json:"suppressFailures,omitempty"`

	// Specifies the type of the extension; an example is "CustomScriptExtension".
	Type *string `json:"type,omitempty"`

	// Specifies the version of the script handler.
	TypeHandlerVersion *string `json:"typeHandlerVersion,omitempty"`
}

// VirtualMachineExtensionsClientBeginCreateOrUpdateOptions contains the optional parameters for the VirtualMachineExtensionsClient.BeginCreateOrUpdate
// method.
type VirtualMachineExtensionsClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachineExtensionsClientBeginDeleteOptions contains the optional parameters for the VirtualMachineExtensionsClient.BeginDelete
// method.
type VirtualMachineExtensionsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachineExtensionsClientBeginUpdateOptions contains the optional parameters for the VirtualMachineExtensionsClient.BeginUpdate
// method.
type VirtualMachineExtensionsClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachineExtensionsClientGetOptions contains the optional parameters for the VirtualMachineExtensionsClient.Get method.
type VirtualMachineExtensionsClientGetOptions struct {
	// The expand expression to apply on the operation.
	Expand *string
}

// VirtualMachineExtensionsClientListOptions contains the optional parameters for the VirtualMachineExtensionsClient.List
// method.
type VirtualMachineExtensionsClientListOptions struct {
	// The expand expression to apply on the operation.
	Expand *string
}

// VirtualMachineExtensionsListResult - The List Extension operation response
type VirtualMachineExtensionsListResult struct {
	// The list of extensions
	Value []*VirtualMachineExtension `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineExtensionsListResult.
func (v VirtualMachineExtensionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// VirtualMachineHealthStatus - The health status of the VM.
type VirtualMachineHealthStatus struct {
	// READ-ONLY; The health status information for the VM.
	Status *InstanceViewStatus `json:"status,omitempty" azure:"ro"`
}

// VirtualMachineIPTag - Contains the IP tag associated with the public IP address.
type VirtualMachineIPTag struct {
	// IP tag type. Example: FirstPartyUsage.
	IPTagType *string `json:"ipTagType,omitempty"`

	// IP tag associated with the public IP. Example: SQL, Storage etc.
	Tag *string `json:"tag,omitempty"`
}

// VirtualMachineIdentity - Identity for the virtual machine.
type VirtualMachineIdentity struct {
	// The type of identity used for the virtual machine. The type 'SystemAssigned, UserAssigned' includes both an implicitly
	// created identity and a set of user assigned identities. The type 'None' will
	// remove any identities from the virtual machine.
	Type *ResourceIdentityType `json:"type,omitempty"`

	// The list of user identities associated with the Virtual Machine. The user identity dictionary key references will be ARM
	// resource ids in the form:
	// '/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.ManagedIdentity/userAssignedIdentities/{identityName}'.
	UserAssignedIdentities map[string]*UserAssignedIdentitiesValue `json:"userAssignedIdentities,omitempty"`

	// READ-ONLY; The principal id of virtual machine identity. This property will only be provided for a system assigned identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The tenant id associated with the virtual machine. This property will only be provided for a system assigned
	// identity.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineIdentity.
func (v VirtualMachineIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", v.PrincipalID)
	populate(objectMap, "tenantId", v.TenantID)
	populate(objectMap, "type", v.Type)
	populate(objectMap, "userAssignedIdentities", v.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// VirtualMachineInstallPatchesParameters - Input for InstallPatches as directly received by the API
type VirtualMachineInstallPatchesParameters struct {
	// REQUIRED; Defines when it is acceptable to reboot a VM during a software update operation.
	RebootSetting *VMGuestPatchRebootSetting `json:"rebootSetting,omitempty"`

	// Input for InstallPatches on a Linux VM, as directly received by the API
	LinuxParameters *LinuxParameters `json:"linuxParameters,omitempty"`

	// Specifies the maximum amount of time that the operation will run. It must be an ISO 8601-compliant duration string such
	// as PT4H (4 hours)
	MaximumDuration *string `json:"maximumDuration,omitempty"`

	// Input for InstallPatches on a Windows VM, as directly received by the API
	WindowsParameters *WindowsParameters `json:"windowsParameters,omitempty"`
}

// VirtualMachineInstallPatchesResult - The result summary of an installation operation.
type VirtualMachineInstallPatchesResult struct {
	// READ-ONLY; The errors that were encountered during execution of the operation. The details array contains the list of them.
	Error *APIError `json:"error,omitempty" azure:"ro"`

	// READ-ONLY; The number of patches that were not installed due to the user blocking their installation.
	ExcludedPatchCount *int32 `json:"excludedPatchCount,omitempty" azure:"ro"`

	// READ-ONLY; The number of patches that could not be installed due to some issue. See errors for details.
	FailedPatchCount *int32 `json:"failedPatchCount,omitempty" azure:"ro"`

	// READ-ONLY; The activity ID of the operation that produced this result. It is used to correlate across CRP and extension
	// logs.
	InstallationActivityID *string `json:"installationActivityId,omitempty" azure:"ro"`

	// READ-ONLY; The number of patches successfully installed.
	InstalledPatchCount *int32 `json:"installedPatchCount,omitempty" azure:"ro"`

	// READ-ONLY; Whether the operation ran out of time before it completed all its intended actions.
	MaintenanceWindowExceeded *bool `json:"maintenanceWindowExceeded,omitempty" azure:"ro"`

	// READ-ONLY; The number of patches that were detected as available for install, but did not meet the operation's criteria.
	NotSelectedPatchCount *int32 `json:"notSelectedPatchCount,omitempty" azure:"ro"`

	// READ-ONLY; The patches that were installed during the operation.
	Patches []*PatchInstallationDetail `json:"patches,omitempty" azure:"ro"`

	// READ-ONLY; The number of patches that were identified as meeting the installation criteria, but were not able to be installed.
	// Typically this happens when maintenanceWindowExceeded == true.
	PendingPatchCount *int32 `json:"pendingPatchCount,omitempty" azure:"ro"`

	// READ-ONLY; The reboot state of the VM following completion of the operation.
	RebootStatus *VMGuestPatchRebootStatus `json:"rebootStatus,omitempty" azure:"ro"`

	// READ-ONLY; The UTC timestamp when the operation began.
	StartDateTime *time.Time `json:"startDateTime,omitempty" azure:"ro"`

	// READ-ONLY; The overall success or failure status of the operation. It remains "InProgress" until the operation completes.
	// At that point it will become "Failed", "Succeeded", "Unknown" or "CompletedWithWarnings."
	Status *PatchOperationStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineInstallPatchesResult.
func (v VirtualMachineInstallPatchesResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "error", v.Error)
	populate(objectMap, "excludedPatchCount", v.ExcludedPatchCount)
	populate(objectMap, "failedPatchCount", v.FailedPatchCount)
	populate(objectMap, "installationActivityId", v.InstallationActivityID)
	populate(objectMap, "installedPatchCount", v.InstalledPatchCount)
	populate(objectMap, "maintenanceWindowExceeded", v.MaintenanceWindowExceeded)
	populate(objectMap, "notSelectedPatchCount", v.NotSelectedPatchCount)
	populate(objectMap, "patches", v.Patches)
	populate(objectMap, "pendingPatchCount", v.PendingPatchCount)
	populate(objectMap, "rebootStatus", v.RebootStatus)
	populateTimeRFC3339(objectMap, "startDateTime", v.StartDateTime)
	populate(objectMap, "status", v.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineInstallPatchesResult.
func (v *VirtualMachineInstallPatchesResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &v.Error)
			delete(rawMsg, key)
		case "excludedPatchCount":
			err = unpopulate(val, &v.ExcludedPatchCount)
			delete(rawMsg, key)
		case "failedPatchCount":
			err = unpopulate(val, &v.FailedPatchCount)
			delete(rawMsg, key)
		case "installationActivityId":
			err = unpopulate(val, &v.InstallationActivityID)
			delete(rawMsg, key)
		case "installedPatchCount":
			err = unpopulate(val, &v.InstalledPatchCount)
			delete(rawMsg, key)
		case "maintenanceWindowExceeded":
			err = unpopulate(val, &v.MaintenanceWindowExceeded)
			delete(rawMsg, key)
		case "notSelectedPatchCount":
			err = unpopulate(val, &v.NotSelectedPatchCount)
			delete(rawMsg, key)
		case "patches":
			err = unpopulate(val, &v.Patches)
			delete(rawMsg, key)
		case "pendingPatchCount":
			err = unpopulate(val, &v.PendingPatchCount)
			delete(rawMsg, key)
		case "rebootStatus":
			err = unpopulate(val, &v.RebootStatus)
			delete(rawMsg, key)
		case "startDateTime":
			err = unpopulateTimeRFC3339(val, &v.StartDateTime)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &v.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// VirtualMachineInstanceView - The instance view of a virtual machine.
type VirtualMachineInstanceView struct {
	// Boot Diagnostics is a debugging feature which allows you to view Console Output and Screenshot to diagnose VM status.
	// You can easily view the output of your console log.
	// Azure also enables you to see a screenshot of the VM from the hypervisor.
	BootDiagnostics *BootDiagnosticsInstanceView `json:"bootDiagnostics,omitempty"`

	// The computer name assigned to the virtual machine.
	ComputerName *string `json:"computerName,omitempty"`

	// The virtual machine disk information.
	Disks []*DiskInstanceView `json:"disks,omitempty"`

	// The extensions information.
	Extensions []*VirtualMachineExtensionInstanceView `json:"extensions,omitempty"`

	// Specifies the HyperVGeneration Type associated with a resource
	HyperVGeneration *HyperVGenerationType `json:"hyperVGeneration,omitempty"`

	// The Maintenance Operation status on the virtual machine.
	MaintenanceRedeployStatus *MaintenanceRedeployStatus `json:"maintenanceRedeployStatus,omitempty"`

	// The Operating System running on the virtual machine.
	OSName *string `json:"osName,omitempty"`

	// The version of Operating System running on the virtual machine.
	OSVersion *string `json:"osVersion,omitempty"`

	// [Preview Feature] The status of virtual machine patch operations.
	PatchStatus *VirtualMachinePatchStatus `json:"patchStatus,omitempty"`

	// Specifies the fault domain of the virtual machine.
	PlatformFaultDomain *int32 `json:"platformFaultDomain,omitempty"`

	// Specifies the update domain of the virtual machine.
	PlatformUpdateDomain *int32 `json:"platformUpdateDomain,omitempty"`

	// The Remote desktop certificate thumbprint.
	RdpThumbPrint *string `json:"rdpThumbPrint,omitempty"`

	// The resource status information.
	Statuses []*InstanceViewStatus `json:"statuses,omitempty"`

	// The VM Agent running on the virtual machine.
	VMAgent *VirtualMachineAgentInstanceView `json:"vmAgent,omitempty"`

	// READ-ONLY; Resource id of the dedicated host, on which the virtual machine is allocated through automatic placement, when
	// the virtual machine is associated with a dedicated host group that has automatic
	// placement enabled.
	// Minimum api-version: 2020-06-01.
	AssignedHost *string `json:"assignedHost,omitempty" azure:"ro"`

	// READ-ONLY; The health status for the VM.
	VMHealth *VirtualMachineHealthStatus `json:"vmHealth,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineInstanceView.
func (v VirtualMachineInstanceView) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "assignedHost", v.AssignedHost)
	populate(objectMap, "bootDiagnostics", v.BootDiagnostics)
	populate(objectMap, "computerName", v.ComputerName)
	populate(objectMap, "disks", v.Disks)
	populate(objectMap, "extensions", v.Extensions)
	populate(objectMap, "hyperVGeneration", v.HyperVGeneration)
	populate(objectMap, "maintenanceRedeployStatus", v.MaintenanceRedeployStatus)
	populate(objectMap, "osName", v.OSName)
	populate(objectMap, "osVersion", v.OSVersion)
	populate(objectMap, "patchStatus", v.PatchStatus)
	populate(objectMap, "platformFaultDomain", v.PlatformFaultDomain)
	populate(objectMap, "platformUpdateDomain", v.PlatformUpdateDomain)
	populate(objectMap, "rdpThumbPrint", v.RdpThumbPrint)
	populate(objectMap, "statuses", v.Statuses)
	populate(objectMap, "vmAgent", v.VMAgent)
	populate(objectMap, "vmHealth", v.VMHealth)
	return json.Marshal(objectMap)
}

// VirtualMachineListResult - The List Virtual Machine operation response.
type VirtualMachineListResult struct {
	// REQUIRED; The list of virtual machines.
	Value []*VirtualMachine `json:"value,omitempty"`

	// The URI to fetch the next page of VMs. Call ListNext() with this URI to fetch the next page of Virtual Machines.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineListResult.
func (v VirtualMachineListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// VirtualMachineNetworkInterfaceConfiguration - Describes a virtual machine network interface configurations.
type VirtualMachineNetworkInterfaceConfiguration struct {
	// REQUIRED; The network interface configuration name.
	Name *string `json:"name,omitempty"`

	// Describes a virtual machine network profile's IP configuration.
	Properties *VirtualMachineNetworkInterfaceConfigurationProperties `json:"properties,omitempty"`
}

// VirtualMachineNetworkInterfaceConfigurationProperties - Describes a virtual machine network profile's IP configuration.
type VirtualMachineNetworkInterfaceConfigurationProperties struct {
	// REQUIRED; Specifies the IP configurations of the network interface.
	IPConfigurations []*VirtualMachineNetworkInterfaceIPConfiguration `json:"ipConfigurations,omitempty"`

	// The dns settings to be applied on the network interfaces.
	DNSSettings *VirtualMachineNetworkInterfaceDNSSettingsConfiguration `json:"dnsSettings,omitempty"`

	// Specify what happens to the network interface when the VM is deleted
	DeleteOption      *DeleteOptions `json:"deleteOption,omitempty"`
	DscpConfiguration *SubResource   `json:"dscpConfiguration,omitempty"`

	// Specifies whether the network interface is accelerated networking-enabled.
	EnableAcceleratedNetworking *bool `json:"enableAcceleratedNetworking,omitempty"`

	// Specifies whether the network interface is FPGA networking-enabled.
	EnableFpga *bool `json:"enableFpga,omitempty"`

	// Whether IP forwarding enabled on this NIC.
	EnableIPForwarding *bool `json:"enableIPForwarding,omitempty"`

	// The network security group.
	NetworkSecurityGroup *SubResource `json:"networkSecurityGroup,omitempty"`

	// Specifies the primary network interface in case the virtual machine has more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineNetworkInterfaceConfigurationProperties.
func (v VirtualMachineNetworkInterfaceConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dnsSettings", v.DNSSettings)
	populate(objectMap, "deleteOption", v.DeleteOption)
	populate(objectMap, "dscpConfiguration", v.DscpConfiguration)
	populate(objectMap, "enableAcceleratedNetworking", v.EnableAcceleratedNetworking)
	populate(objectMap, "enableFpga", v.EnableFpga)
	populate(objectMap, "enableIPForwarding", v.EnableIPForwarding)
	populate(objectMap, "ipConfigurations", v.IPConfigurations)
	populate(objectMap, "networkSecurityGroup", v.NetworkSecurityGroup)
	populate(objectMap, "primary", v.Primary)
	return json.Marshal(objectMap)
}

// VirtualMachineNetworkInterfaceDNSSettingsConfiguration - Describes a virtual machines network configuration's DNS settings.
type VirtualMachineNetworkInterfaceDNSSettingsConfiguration struct {
	// List of DNS servers IP addresses
	DNSServers []*string `json:"dnsServers,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineNetworkInterfaceDNSSettingsConfiguration.
func (v VirtualMachineNetworkInterfaceDNSSettingsConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dnsServers", v.DNSServers)
	return json.Marshal(objectMap)
}

// VirtualMachineNetworkInterfaceIPConfiguration - Describes a virtual machine network profile's IP configuration.
type VirtualMachineNetworkInterfaceIPConfiguration struct {
	// REQUIRED; The IP configuration name.
	Name *string `json:"name,omitempty"`

	// Describes a virtual machine network interface IP configuration properties.
	Properties *VirtualMachineNetworkInterfaceIPConfigurationProperties `json:"properties,omitempty"`
}

// VirtualMachineNetworkInterfaceIPConfigurationProperties - Describes a virtual machine network interface IP configuration
// properties.
type VirtualMachineNetworkInterfaceIPConfigurationProperties struct {
	// Specifies an array of references to backend address pools of application gateways. A virtual machine can reference backend
	// address pools of multiple application gateways. Multiple virtual machines
	// cannot use the same application gateway.
	ApplicationGatewayBackendAddressPools []*SubResource `json:"applicationGatewayBackendAddressPools,omitempty"`

	// Specifies an array of references to application security group.
	ApplicationSecurityGroups []*SubResource `json:"applicationSecurityGroups,omitempty"`

	// Specifies an array of references to backend address pools of load balancers. A virtual machine can reference backend address
	// pools of one public and one internal load balancer. [Multiple virtual
	// machines cannot use the same basic sku load balancer].
	LoadBalancerBackendAddressPools []*SubResource `json:"loadBalancerBackendAddressPools,omitempty"`

	// Specifies the primary network interface in case the virtual machine has more than 1 network interface.
	Primary *bool `json:"primary,omitempty"`

	// Available from Api-Version 2017-03-30 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Default
	// is taken as IPv4. Possible values are: 'IPv4' and 'IPv6'.
	PrivateIPAddressVersion *IPVersions `json:"privateIPAddressVersion,omitempty"`

	// The publicIPAddressConfiguration.
	PublicIPAddressConfiguration *VirtualMachinePublicIPAddressConfiguration `json:"publicIPAddressConfiguration,omitempty"`

	// Specifies the identifier of the subnet.
	Subnet *SubResource `json:"subnet,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineNetworkInterfaceIPConfigurationProperties.
func (v VirtualMachineNetworkInterfaceIPConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "applicationGatewayBackendAddressPools", v.ApplicationGatewayBackendAddressPools)
	populate(objectMap, "applicationSecurityGroups", v.ApplicationSecurityGroups)
	populate(objectMap, "loadBalancerBackendAddressPools", v.LoadBalancerBackendAddressPools)
	populate(objectMap, "primary", v.Primary)
	populate(objectMap, "privateIPAddressVersion", v.PrivateIPAddressVersion)
	populate(objectMap, "publicIPAddressConfiguration", v.PublicIPAddressConfiguration)
	populate(objectMap, "subnet", v.Subnet)
	return json.Marshal(objectMap)
}

// VirtualMachinePatchStatus - The status of virtual machine patch operations.
type VirtualMachinePatchStatus struct {
	// The available patch summary of the latest assessment operation for the virtual machine.
	AvailablePatchSummary *AvailablePatchSummary `json:"availablePatchSummary,omitempty"`

	// The installation summary of the latest installation operation for the virtual machine.
	LastPatchInstallationSummary *LastPatchInstallationSummary `json:"lastPatchInstallationSummary,omitempty"`

	// READ-ONLY; The enablement status of the specified patchMode
	ConfigurationStatuses []*InstanceViewStatus `json:"configurationStatuses,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachinePatchStatus.
func (v VirtualMachinePatchStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "availablePatchSummary", v.AvailablePatchSummary)
	populate(objectMap, "configurationStatuses", v.ConfigurationStatuses)
	populate(objectMap, "lastPatchInstallationSummary", v.LastPatchInstallationSummary)
	return json.Marshal(objectMap)
}

// VirtualMachineProperties - Describes the properties of a Virtual Machine.
type VirtualMachineProperties struct {
	// Specifies additional capabilities enabled or disabled on the virtual machine.
	AdditionalCapabilities *AdditionalCapabilities `json:"additionalCapabilities,omitempty"`

	// Specifies the gallery applications that should be made available to the VM/VMSS
	ApplicationProfile *ApplicationProfile `json:"applicationProfile,omitempty"`

	// Specifies information about the availability set that the virtual machine should be assigned to. Virtual machines specified
	// in the same availability set are allocated to different nodes to maximize
	// availability. For more information about availability sets, see Availability sets overview [https://docs.microsoft.com/azure/virtual-machines/availability-set-overview].
	// For more information on Azure planned maintenance, see Maintenance and updates for Virtual Machines in Azure [https://docs.microsoft.com/azure/virtual-machines/maintenance-and-updates]
	// Currently, a VM can only be added to availability set at creation time. The availability set to which the VM is being added
	// should be under the same resource group as the availability set resource. An
	// existing VM cannot be added to an availability set.
	// This property cannot exist along with a non-null properties.virtualMachineScaleSet reference.
	AvailabilitySet *SubResource `json:"availabilitySet,omitempty"`

	// Specifies the billing related details of a Azure Spot virtual machine.
	// Minimum api-version: 2019-03-01.
	BillingProfile *BillingProfile `json:"billingProfile,omitempty"`

	// Specifies information about the capacity reservation that is used to allocate virtual machine.
	// Minimum api-version: 2021-04-01.
	CapacityReservation *CapacityReservationProfile `json:"capacityReservation,omitempty"`

	// Specifies the boot diagnostic settings state.
	// Minimum api-version: 2015-06-15.
	DiagnosticsProfile *DiagnosticsProfile `json:"diagnosticsProfile,omitempty"`

	// Specifies the eviction policy for the Azure Spot virtual machine and Azure Spot scale set.
	// For Azure Spot virtual machines, both 'Deallocate' and 'Delete' are supported and the minimum api-version is 2019-03-01.
	// For Azure Spot scale sets, both 'Deallocate' and 'Delete' are supported and the minimum api-version is 2017-10-30-preview.
	EvictionPolicy *VirtualMachineEvictionPolicyTypes `json:"evictionPolicy,omitempty"`

	// Specifies the time alloted for all extensions to start. The time duration should be between 15 minutes and 120 minutes
	// (inclusive) and should be specified in ISO 8601 format. The default value is 90
	// minutes (PT1H30M).
	// Minimum api-version: 2020-06-01
	ExtensionsTimeBudget *string `json:"extensionsTimeBudget,omitempty"`

	// Specifies the hardware settings for the virtual machine.
	HardwareProfile *HardwareProfile `json:"hardwareProfile,omitempty"`

	// Specifies information about the dedicated host that the virtual machine resides in.
	// Minimum api-version: 2018-10-01.
	Host *SubResource `json:"host,omitempty"`

	// Specifies information about the dedicated host group that the virtual machine resides in.
	// Minimum api-version: 2020-06-01.
	// NOTE: User cannot specify both host and hostGroup properties.
	HostGroup *SubResource `json:"hostGroup,omitempty"`

	// Specifies that the image or disk that is being used was licensed on-premises.
	// Possible values for Windows Server operating system are:
	// WindowsClient
	// WindowsServer
	// Possible values for Linux Server operating system are:
	// RHELBYOS (for RHEL)
	// SLESBYOS (for SUSE)
	// For more information, see Azure Hybrid Use Benefit for Windows Server [https://docs.microsoft.com/azure/virtual-machines/windows/hybrid-use-benefit-licensing]
	// Azure Hybrid Use Benefit for Linux Server [https://docs.microsoft.com/azure/virtual-machines/linux/azure-hybrid-benefit-linux]
	// Minimum api-version: 2015-06-15
	LicenseType *string `json:"licenseType,omitempty"`

	// Specifies the network interfaces of the virtual machine.
	NetworkProfile *NetworkProfile `json:"networkProfile,omitempty"`

	// Specifies the operating system settings used while creating the virtual machine. Some of the settings cannot be changed
	// once VM is provisioned.
	OSProfile *OSProfile `json:"osProfile,omitempty"`

	// Specifies the scale set logical fault domain into which the Virtual Machine will be created. By default, the Virtual Machine
	// will by automatically assigned to a fault domain that best maintains
	// balance across available fault domains.
	// This is applicable only if the 'virtualMachineScaleSet' property of this Virtual Machine is set.The Virtual Machine Scale
	// Set that is referenced, must have 'platformFaultDomainCount' > 1.This property
	// cannot be updated once the Virtual Machine is created.Fault domain assignment can be viewed in the Virtual Machine Instance
	// View.
	// Minimum apiâ€version: 2020â€12â€01
	PlatformFaultDomain *int32 `json:"platformFaultDomain,omitempty"`

	// Specifies the priority for the virtual machine.
	// Minimum api-version: 2019-03-01
	Priority *VirtualMachinePriorityTypes `json:"priority,omitempty"`

	// Specifies information about the proximity placement group that the virtual machine should be assigned to.
	// Minimum api-version: 2018-04-01.
	ProximityPlacementGroup *SubResource `json:"proximityPlacementGroup,omitempty"`

	// Specifies Scheduled Event related configurations.
	ScheduledEventsProfile *ScheduledEventsProfile `json:"scheduledEventsProfile,omitempty"`

	// Specifies the Security related profile settings for the virtual machine.
	SecurityProfile *SecurityProfile `json:"securityProfile,omitempty"`

	// Specifies the storage settings for the virtual machine disks.
	StorageProfile *StorageProfile `json:"storageProfile,omitempty"`

	// UserData for the VM, which must be base-64 encoded. Customer should not pass any secrets in here.
	// Minimum api-version: 2021-03-01
	UserData *string `json:"userData,omitempty"`

	// Specifies information about the virtual machine scale set that the virtual machine should be assigned to. Virtual machines
	// specified in the same virtual machine scale set are allocated to different
	// nodes to maximize availability. Currently, a VM can only be added to virtual machine scale set at creation time. An existing
	// VM cannot be added to a virtual machine scale set.
	// This property cannot exist along with a non-null properties.availabilitySet reference.
	// Minimum apiâ€version: 2019â€03â€01
	VirtualMachineScaleSet *SubResource `json:"virtualMachineScaleSet,omitempty"`

	// READ-ONLY; The virtual machine instance view.
	InstanceView *VirtualMachineInstanceView `json:"instanceView,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning state, which only appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`

	// READ-ONLY; Specifies the time at which the Virtual Machine resource was created.
	// Minimum api-version: 2022-03-01.
	TimeCreated *time.Time `json:"timeCreated,omitempty" azure:"ro"`

	// READ-ONLY; Specifies the VM unique ID which is a 128-bits identifier that is encoded and stored in all Azure IaaS VMs SMBIOS
	// and can be read using platform BIOS commands.
	VMID *string `json:"vmId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineProperties.
func (v VirtualMachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalCapabilities", v.AdditionalCapabilities)
	populate(objectMap, "applicationProfile", v.ApplicationProfile)
	populate(objectMap, "availabilitySet", v.AvailabilitySet)
	populate(objectMap, "billingProfile", v.BillingProfile)
	populate(objectMap, "capacityReservation", v.CapacityReservation)
	populate(objectMap, "diagnosticsProfile", v.DiagnosticsProfile)
	populate(objectMap, "evictionPolicy", v.EvictionPolicy)
	populate(objectMap, "extensionsTimeBudget", v.ExtensionsTimeBudget)
	populate(objectMap, "hardwareProfile", v.HardwareProfile)
	populate(objectMap, "host", v.Host)
	populate(objectMap, "hostGroup", v.HostGroup)
	populate(objectMap, "instanceView", v.InstanceView)
	populate(objectMap, "licenseType", v.LicenseType)
	populate(objectMap, "networkProfile", v.NetworkProfile)
	populate(objectMap, "osProfile", v.OSProfile)
	populate(objectMap, "platformFaultDomain", v.PlatformFaultDomain)
	populate(objectMap, "priority", v.Priority)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "proximityPlacementGroup", v.ProximityPlacementGroup)
	populate(objectMap, "scheduledEventsProfile", v.ScheduledEventsProfile)
	populate(objectMap, "securityProfile", v.SecurityProfile)
	populate(objectMap, "storageProfile", v.StorageProfile)
	populateTimeRFC3339(objectMap, "timeCreated", v.TimeCreated)
	populate(objectMap, "userData", v.UserData)
	populate(objectMap, "vmId", v.VMID)
	populate(objectMap, "virtualMachineScaleSet", v.VirtualMachineScaleSet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineProperties.
func (v *VirtualMachineProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalCapabilities":
			err = unpopulate(val, &v.AdditionalCapabilities)
			delete(rawMsg, key)
		case "applicationProfile":
			err = unpopulate(val, &v.ApplicationProfile)
			delete(rawMsg, key)
		case "availabilitySet":
			err = unpopulate(val, &v.AvailabilitySet)
			delete(rawMsg, key)
		case "billingProfile":
			err = unpopulate(val, &v.BillingProfile)
			delete(rawMsg, key)
		case "capacityReservation":
			err = unpopulate(val, &v.CapacityReservation)
			delete(rawMsg, key)
		case "diagnosticsProfile":
			err = unpopulate(val, &v.DiagnosticsProfile)
			delete(rawMsg, key)
		case "evictionPolicy":
			err = unpopulate(val, &v.EvictionPolicy)
			delete(rawMsg, key)
		case "extensionsTimeBudget":
			err = unpopulate(val, &v.ExtensionsTimeBudget)
			delete(rawMsg, key)
		case "hardwareProfile":
			err = unpopulate(val, &v.HardwareProfile)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &v.Host)
			delete(rawMsg, key)
		case "hostGroup":
			err = unpopulate(val, &v.HostGroup)
			delete(rawMsg, key)
		case "instanceView":
			err = unpopulate(val, &v.InstanceView)
			delete(rawMsg, key)
		case "licenseType":
			err = unpopulate(val, &v.LicenseType)
			delete(rawMsg, key)
		case "networkProfile":
			err = unpopulate(val, &v.NetworkProfile)
			delete(rawMsg, key)
		case "osProfile":
			err = unpopulate(val, &v.OSProfile)
			delete(rawMsg, key)
		case "platformFaultDomain":
			err = unpopulate(val, &v.PlatformFaultDomain)
			delete(rawMsg, key)
		case "priority":
			err = unpopulate(val, &v.Priority)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &v.ProvisioningState)
			delete(rawMsg, key)
		case "proximityPlacementGroup":
			err = unpopulate(val, &v.ProximityPlacementGroup)
			delete(rawMsg, key)
		case "scheduledEventsProfile":
			err = unpopulate(val, &v.ScheduledEventsProfile)
			delete(rawMsg, key)
		case "securityProfile":
			err = unpopulate(val, &v.SecurityProfile)
			delete(rawMsg, key)
		case "storageProfile":
			err = unpopulate(val, &v.StorageProfile)
			delete(rawMsg, key)
		case "timeCreated":
			err = unpopulateTimeRFC3339(val, &v.TimeCreated)
			delete(rawMsg, key)
		case "userData":
			err = unpopulate(val, &v.UserData)
			delete(rawMsg, key)
		case "vmId":
			err = unpopulate(val, &v.VMID)
			delete(rawMsg, key)
		case "virtualMachineScaleSet":
			err = unpopulate(val, &v.VirtualMachineScaleSet)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// VirtualMachinePublicIPAddressConfiguration - Describes a virtual machines IP Configuration's PublicIPAddress configuration
type VirtualMachinePublicIPAddressConfiguration struct {
	// REQUIRED; The publicIP address configuration name.
	Name *string `json:"name,omitempty"`

	// Describes a virtual machines IP Configuration's PublicIPAddress configuration
	Properties *VirtualMachinePublicIPAddressConfigurationProperties `json:"properties,omitempty"`

	// Describes the public IP Sku. It can only be set with OrchestrationMode as Flexible.
	SKU *PublicIPAddressSKU `json:"sku,omitempty"`
}

// VirtualMachinePublicIPAddressConfigurationProperties - Describes a virtual machines IP Configuration's PublicIPAddress
// configuration
type VirtualMachinePublicIPAddressConfigurationProperties struct {
	// The dns settings to be applied on the publicIP addresses .
	DNSSettings *VirtualMachinePublicIPAddressDNSSettingsConfiguration `json:"dnsSettings,omitempty"`

	// Specify what happens to the public IP address when the VM is deleted
	DeleteOption *DeleteOptions `json:"deleteOption,omitempty"`

	// The list of IP tags associated with the public IP address.
	IPTags []*VirtualMachineIPTag `json:"ipTags,omitempty"`

	// The idle timeout of the public IP address.
	IdleTimeoutInMinutes *int32 `json:"idleTimeoutInMinutes,omitempty"`

	// Available from Api-Version 2019-07-01 onwards, it represents whether the specific ipconfiguration is IPv4 or IPv6. Default
	// is taken as IPv4. Possible values are: 'IPv4' and 'IPv6'.
	PublicIPAddressVersion *IPVersions `json:"publicIPAddressVersion,omitempty"`

	// Specify the public IP allocation type
	PublicIPAllocationMethod *PublicIPAllocationMethod `json:"publicIPAllocationMethod,omitempty"`

	// The PublicIPPrefix from which to allocate publicIP addresses.
	PublicIPPrefix *SubResource `json:"publicIPPrefix,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachinePublicIPAddressConfigurationProperties.
func (v VirtualMachinePublicIPAddressConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dnsSettings", v.DNSSettings)
	populate(objectMap, "deleteOption", v.DeleteOption)
	populate(objectMap, "ipTags", v.IPTags)
	populate(objectMap, "idleTimeoutInMinutes", v.IdleTimeoutInMinutes)
	populate(objectMap, "publicIPAddressVersion", v.PublicIPAddressVersion)
	populate(objectMap, "publicIPAllocationMethod", v.PublicIPAllocationMethod)
	populate(objectMap, "publicIPPrefix", v.PublicIPPrefix)
	return json.Marshal(objectMap)
}

// VirtualMachinePublicIPAddressDNSSettingsConfiguration - Describes a virtual machines network configuration's DNS settings.
type VirtualMachinePublicIPAddressDNSSettingsConfiguration struct {
	// REQUIRED; The Domain name label prefix of the PublicIPAddress resources that will be created. The generated name label
	// is the concatenation of the domain name label and vm network profile unique ID.
	DomainNameLabel *string `json:"domainNameLabel,omitempty"`
}

// VirtualMachineReimageParameters - Parameters for Reimaging Virtual Machine. NOTE: Virtual Machine OS disk will always be
// reimaged
type VirtualMachineReimageParameters struct {
	// Specifies whether to reimage temp disk. Default value: false. Note: This temp disk reimage parameter is only supported
	// for VM/VMSS with Ephemeral OS disk.
	TempDisk *bool `json:"tempDisk,omitempty"`
}

// VirtualMachineRunCommand - Describes a Virtual Machine run command.
type VirtualMachineRunCommand struct {
	// REQUIRED; Resource location
	Location *string `json:"location,omitempty"`

	// Describes the properties of a Virtual Machine run command.
	Properties *VirtualMachineRunCommandProperties `json:"properties,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Resource Id
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineRunCommand.
func (v VirtualMachineRunCommand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", v.ID)
	populate(objectMap, "location", v.Location)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "tags", v.Tags)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// VirtualMachineRunCommandInstanceView - The instance view of a virtual machine run command.
type VirtualMachineRunCommandInstanceView struct {
	// Script end time.
	EndTime *time.Time `json:"endTime,omitempty"`

	// Script error stream.
	Error *string `json:"error,omitempty"`

	// Communicate script configuration errors or execution messages.
	ExecutionMessage *string `json:"executionMessage,omitempty"`

	// Script execution status.
	ExecutionState *ExecutionState `json:"executionState,omitempty"`

	// Exit code returned from script execution.
	ExitCode *int32 `json:"exitCode,omitempty"`

	// Script output stream.
	Output *string `json:"output,omitempty"`

	// Script start time.
	StartTime *time.Time `json:"startTime,omitempty"`

	// The resource status information.
	Statuses []*InstanceViewStatus `json:"statuses,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineRunCommandInstanceView.
func (v VirtualMachineRunCommandInstanceView) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", v.EndTime)
	populate(objectMap, "error", v.Error)
	populate(objectMap, "executionMessage", v.ExecutionMessage)
	populate(objectMap, "executionState", v.ExecutionState)
	populate(objectMap, "exitCode", v.ExitCode)
	populate(objectMap, "output", v.Output)
	populateTimeRFC3339(objectMap, "startTime", v.StartTime)
	populate(objectMap, "statuses", v.Statuses)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineRunCommandInstanceView.
func (v *VirtualMachineRunCommandInstanceView) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			err = unpopulateTimeRFC3339(val, &v.EndTime)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &v.Error)
			delete(rawMsg, key)
		case "executionMessage":
			err = unpopulate(val, &v.ExecutionMessage)
			delete(rawMsg, key)
		case "executionState":
			err = unpopulate(val, &v.ExecutionState)
			delete(rawMsg, key)
		case "exitCode":
			err = unpopulate(val, &v.ExitCode)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &v.Output)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &v.StartTime)
			delete(rawMsg, key)
		case "statuses":
			err = unpopulate(val, &v.Statuses)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// VirtualMachineRunCommandProperties - Describes the properties of a Virtual Machine run command.
type VirtualMachineRunCommandProperties struct {
	// Optional. If set to true, provisioning will complete as soon as the script starts and will not wait for script to complete.
	AsyncExecution *bool `json:"asyncExecution,omitempty"`

	// Specifies the Azure storage blob where script error stream will be uploaded.
	ErrorBlobURI *string `json:"errorBlobUri,omitempty"`

	// Specifies the Azure storage blob where script output stream will be uploaded.
	OutputBlobURI *string `json:"outputBlobUri,omitempty"`

	// The parameters used by the script.
	Parameters []*RunCommandInputParameter `json:"parameters,omitempty"`

	// The parameters used by the script.
	ProtectedParameters []*RunCommandInputParameter `json:"protectedParameters,omitempty"`

	// Specifies the user account password on the VM when executing the run command.
	RunAsPassword *string `json:"runAsPassword,omitempty"`

	// Specifies the user account on the VM when executing the run command.
	RunAsUser *string `json:"runAsUser,omitempty"`

	// The source of the run command script.
	Source *VirtualMachineRunCommandScriptSource `json:"source,omitempty"`

	// The timeout in seconds to execute the run command.
	TimeoutInSeconds *int32 `json:"timeoutInSeconds,omitempty"`

	// READ-ONLY; The virtual machine run command instance view.
	InstanceView *VirtualMachineRunCommandInstanceView `json:"instanceView,omitempty" azure:"ro"`

	// READ-ONLY; The provisioning state, which only appears in the response.
	ProvisioningState *string `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineRunCommandProperties.
func (v VirtualMachineRunCommandProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "asyncExecution", v.AsyncExecution)
	populate(objectMap, "errorBlobUri", v.ErrorBlobURI)
	populate(objectMap, "instanceView", v.InstanceView)
	populate(objectMap, "outputBlobUri", v.OutputBlobURI)
	populate(objectMap, "parameters", v.Parameters)
	populate(objectMap, "protectedParameters", v.ProtectedParameters)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "runAsPassword", v.RunAsPassword)
	populate(objectMap, "runAsUser", v.RunAsUser)
	populate(objectMap, "source", v.Source)
	populate(objectMap, "timeoutInSeconds", v.TimeoutInSeconds)
	return json.Marshal(objectMap)
}

// VirtualMachineRunCommandScriptSource - Describes the script sources for run command.
type VirtualMachineRunCommandScriptSource struct {
	// Specifies a commandId of predefined built-in script.
	CommandID *string `json:"commandId,omitempty"`

	// Specifies the script content to be executed on the VM.
	Script *string `json:"script,omitempty"`

	// Specifies the script download location.
	ScriptURI *string `json:"scriptUri,omitempty"`
}

// VirtualMachineRunCommandUpdate - Describes a Virtual Machine run command.
type VirtualMachineRunCommandUpdate struct {
	// Describes the properties of a Virtual Machine run command.
	Properties *VirtualMachineRunCommandProperties `json:"properties,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineRunCommandUpdate.
func (v VirtualMachineRunCommandUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "tags", v.Tags)
	return json.Marshal(objectMap)
}

// VirtualMachineRunCommandsClientBeginCreateOrUpdateOptions contains the optional parameters for the VirtualMachineRunCommandsClient.BeginCreateOrUpdate
// method.
type VirtualMachineRunCommandsClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachineRunCommandsClientBeginDeleteOptions contains the optional parameters for the VirtualMachineRunCommandsClient.BeginDelete
// method.
type VirtualMachineRunCommandsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachineRunCommandsClientBeginUpdateOptions contains the optional parameters for the VirtualMachineRunCommandsClient.BeginUpdate
// method.
type VirtualMachineRunCommandsClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachineRunCommandsClientGetByVirtualMachineOptions contains the optional parameters for the VirtualMachineRunCommandsClient.GetByVirtualMachine
// method.
type VirtualMachineRunCommandsClientGetByVirtualMachineOptions struct {
	// The expand expression to apply on the operation.
	Expand *string
}

// VirtualMachineRunCommandsClientGetOptions contains the optional parameters for the VirtualMachineRunCommandsClient.Get
// method.
type VirtualMachineRunCommandsClientGetOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachineRunCommandsClientListByVirtualMachineOptions contains the optional parameters for the VirtualMachineRunCommandsClient.ListByVirtualMachine
// method.
type VirtualMachineRunCommandsClientListByVirtualMachineOptions struct {
	// The expand expression to apply on the operation.
	Expand *string
}

// VirtualMachineRunCommandsClientListOptions contains the optional parameters for the VirtualMachineRunCommandsClient.List
// method.
type VirtualMachineRunCommandsClientListOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachineRunCommandsListResult - The List run command operation response
type VirtualMachineRunCommandsListResult struct {
	// REQUIRED; The list of run commands
	Value []*VirtualMachineRunCommand `json:"value,omitempty"`

	// The uri to fetch the next page of run commands.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineRunCommandsListResult.
func (v VirtualMachineRunCommandsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// VirtualMachineScaleSetVMRunCommandsClientBeginCreateOrUpdateOptions contains the optional parameters for the VirtualMachineScaleSetVMRunCommandsClient.BeginCreateOrUpdate
// method.
type VirtualMachineScaleSetVMRunCommandsClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachineScaleSetVMRunCommandsClientBeginDeleteOptions contains the optional parameters for the VirtualMachineScaleSetVMRunCommandsClient.BeginDelete
// method.
type VirtualMachineScaleSetVMRunCommandsClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachineScaleSetVMRunCommandsClientBeginUpdateOptions contains the optional parameters for the VirtualMachineScaleSetVMRunCommandsClient.BeginUpdate
// method.
type VirtualMachineScaleSetVMRunCommandsClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachineScaleSetVMRunCommandsClientGetOptions contains the optional parameters for the VirtualMachineScaleSetVMRunCommandsClient.Get
// method.
type VirtualMachineScaleSetVMRunCommandsClientGetOptions struct {
	// The expand expression to apply on the operation.
	Expand *string
}

// VirtualMachineScaleSetVMRunCommandsClientListOptions contains the optional parameters for the VirtualMachineScaleSetVMRunCommandsClient.List
// method.
type VirtualMachineScaleSetVMRunCommandsClientListOptions struct {
	// The expand expression to apply on the operation.
	Expand *string
}

// VirtualMachineScaleSetVMsClientBeginRunCommandOptions contains the optional parameters for the VirtualMachineScaleSetVMsClient.BeginRunCommand
// method.
type VirtualMachineScaleSetVMsClientBeginRunCommandOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachineSize - Describes the properties of a VM size.
type VirtualMachineSize struct {
	// The maximum number of data disks that can be attached to the virtual machine size.
	MaxDataDiskCount *int32 `json:"maxDataDiskCount,omitempty"`

	// The amount of memory, in MB, supported by the virtual machine size.
	MemoryInMB *int32 `json:"memoryInMB,omitempty"`

	// The name of the virtual machine size.
	Name *string `json:"name,omitempty"`

	// The number of cores supported by the virtual machine size. For Constrained vCPU capable VM sizes, this number represents
	// the total vCPUs of quota that the VM uses. For accurate vCPU count, please
	// refer to https://docs.microsoft.com/azure/virtual-machines/constrained-vcpu or https://docs.microsoft.com/rest/api/compute/resourceskus/list
	NumberOfCores *int32 `json:"numberOfCores,omitempty"`

	// The OS disk size, in MB, allowed by the virtual machine size.
	OSDiskSizeInMB *int32 `json:"osDiskSizeInMB,omitempty"`

	// The resource disk size, in MB, allowed by the virtual machine size.
	ResourceDiskSizeInMB *int32 `json:"resourceDiskSizeInMB,omitempty"`
}

// VirtualMachineSizeListResult - The List Virtual Machine operation response.
type VirtualMachineSizeListResult struct {
	// The list of virtual machine sizes.
	Value []*VirtualMachineSize `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineSizeListResult.
func (v VirtualMachineSizeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// VirtualMachineSoftwarePatchProperties - Describes the properties of a Virtual Machine software patch.
type VirtualMachineSoftwarePatchProperties struct {
	// READ-ONLY; The activity ID of the operation that produced this result. It is used to correlate across CRP and extension
	// logs.
	ActivityID *string `json:"activityId,omitempty" azure:"ro"`

	// READ-ONLY; Describes the availability of a given patch.
	AssessmentState *PatchAssessmentState `json:"assessmentState,omitempty" azure:"ro"`

	// READ-ONLY; The classification(s) of the patch as provided by the patch publisher.
	Classifications []*string `json:"classifications,omitempty" azure:"ro"`

	// READ-ONLY; The KBID of the patch. Only applies to Windows patches.
	KbID *string `json:"kbId,omitempty" azure:"ro"`

	// READ-ONLY; The UTC timestamp of the last update to this patch record.
	LastModifiedDateTime *time.Time `json:"lastModifiedDateTime,omitempty" azure:"ro"`

	// READ-ONLY; The friendly name of the patch.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; A unique identifier for the patch.
	PatchID *string `json:"patchId,omitempty" azure:"ro"`

	// READ-ONLY; The UTC timestamp when the repository published this patch.
	PublishedDate *time.Time `json:"publishedDate,omitempty" azure:"ro"`

	// READ-ONLY; Describes the reboot requirements of the patch.
	RebootBehavior *VMGuestPatchRebootBehavior `json:"rebootBehavior,omitempty" azure:"ro"`

	// READ-ONLY; The version number of the patch. This property applies only to Linux patches.
	Version *string `json:"version,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineSoftwarePatchProperties.
func (v VirtualMachineSoftwarePatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activityId", v.ActivityID)
	populate(objectMap, "assessmentState", v.AssessmentState)
	populate(objectMap, "classifications", v.Classifications)
	populate(objectMap, "kbId", v.KbID)
	populateTimeRFC3339(objectMap, "lastModifiedDateTime", v.LastModifiedDateTime)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "patchId", v.PatchID)
	populateTimeRFC3339(objectMap, "publishedDate", v.PublishedDate)
	populate(objectMap, "rebootBehavior", v.RebootBehavior)
	populate(objectMap, "version", v.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineSoftwarePatchProperties.
func (v *VirtualMachineSoftwarePatchProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activityId":
			err = unpopulate(val, &v.ActivityID)
			delete(rawMsg, key)
		case "assessmentState":
			err = unpopulate(val, &v.AssessmentState)
			delete(rawMsg, key)
		case "classifications":
			err = unpopulate(val, &v.Classifications)
			delete(rawMsg, key)
		case "kbId":
			err = unpopulate(val, &v.KbID)
			delete(rawMsg, key)
		case "lastModifiedDateTime":
			err = unpopulateTimeRFC3339(val, &v.LastModifiedDateTime)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &v.Name)
			delete(rawMsg, key)
		case "patchId":
			err = unpopulate(val, &v.PatchID)
			delete(rawMsg, key)
		case "publishedDate":
			err = unpopulateTimeRFC3339(val, &v.PublishedDate)
			delete(rawMsg, key)
		case "rebootBehavior":
			err = unpopulate(val, &v.RebootBehavior)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &v.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// VirtualMachineUpdate - Describes a Virtual Machine Update.
type VirtualMachineUpdate struct {
	// The identity of the virtual machine, if configured.
	Identity *VirtualMachineIdentity `json:"identity,omitempty"`

	// Specifies information about the marketplace image used to create the virtual machine. This element is only used for marketplace
	// images. Before you can use a marketplace image from an API, you must
	// enable the image for programmatic use. In the Azure portal, find the marketplace image that you want to use and then click
	// Want to deploy programmatically, Get Started ->. Enter any required
	// information and then click Save.
	Plan *Plan `json:"plan,omitempty"`

	// Describes the properties of a Virtual Machine.
	Properties *VirtualMachineProperties `json:"properties,omitempty"`

	// Resource tags
	Tags map[string]*string `json:"tags,omitempty"`

	// The virtual machine zones.
	Zones []*string `json:"zones,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineUpdate.
func (v VirtualMachineUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", v.Identity)
	populate(objectMap, "plan", v.Plan)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "tags", v.Tags)
	populate(objectMap, "zones", v.Zones)
	return json.Marshal(objectMap)
}

// VirtualMachinesClientBeginAssessPatchesOptions contains the optional parameters for the VirtualMachinesClient.BeginAssessPatches
// method.
type VirtualMachinesClientBeginAssessPatchesOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesClientBeginCaptureOptions contains the optional parameters for the VirtualMachinesClient.BeginCapture method.
type VirtualMachinesClientBeginCaptureOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesClientBeginConvertToManagedDisksOptions contains the optional parameters for the VirtualMachinesClient.BeginConvertToManagedDisks
// method.
type VirtualMachinesClientBeginConvertToManagedDisksOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesClientBeginCreateOrUpdateOptions contains the optional parameters for the VirtualMachinesClient.BeginCreateOrUpdate
// method.
type VirtualMachinesClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesClientBeginDeallocateOptions contains the optional parameters for the VirtualMachinesClient.BeginDeallocate
// method.
type VirtualMachinesClientBeginDeallocateOptions struct {
	// Optional parameter to hibernate a virtual machine. (Feature in Preview)
	Hibernate *bool
}

// VirtualMachinesClientBeginDeleteOptions contains the optional parameters for the VirtualMachinesClient.BeginDelete method.
type VirtualMachinesClientBeginDeleteOptions struct {
	// Optional parameter to force delete virtual machines.
	ForceDeletion *bool
}

// VirtualMachinesClientBeginInstallPatchesOptions contains the optional parameters for the VirtualMachinesClient.BeginInstallPatches
// method.
type VirtualMachinesClientBeginInstallPatchesOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesClientBeginPerformMaintenanceOptions contains the optional parameters for the VirtualMachinesClient.BeginPerformMaintenance
// method.
type VirtualMachinesClientBeginPerformMaintenanceOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesClientBeginPowerOffOptions contains the optional parameters for the VirtualMachinesClient.BeginPowerOff
// method.
type VirtualMachinesClientBeginPowerOffOptions struct {
	// The parameter to request non-graceful VM shutdown. True value for this flag indicates non-graceful shutdown whereas false
	// indicates otherwise. Default value for this flag is false if not specified
	SkipShutdown *bool
}

// VirtualMachinesClientBeginReapplyOptions contains the optional parameters for the VirtualMachinesClient.BeginReapply method.
type VirtualMachinesClientBeginReapplyOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesClientBeginRedeployOptions contains the optional parameters for the VirtualMachinesClient.BeginRedeploy
// method.
type VirtualMachinesClientBeginRedeployOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesClientBeginReimageOptions contains the optional parameters for the VirtualMachinesClient.BeginReimage method.
type VirtualMachinesClientBeginReimageOptions struct {
	// Parameters supplied to the Reimage Virtual Machine operation.
	Parameters *VirtualMachineReimageParameters
}

// VirtualMachinesClientBeginRestartOptions contains the optional parameters for the VirtualMachinesClient.BeginRestart method.
type VirtualMachinesClientBeginRestartOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesClientBeginRunCommandOptions contains the optional parameters for the VirtualMachinesClient.BeginRunCommand
// method.
type VirtualMachinesClientBeginRunCommandOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesClientBeginStartOptions contains the optional parameters for the VirtualMachinesClient.BeginStart method.
type VirtualMachinesClientBeginStartOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesClientBeginUpdateOptions contains the optional parameters for the VirtualMachinesClient.BeginUpdate method.
type VirtualMachinesClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesClientGeneralizeOptions contains the optional parameters for the VirtualMachinesClient.Generalize method.
type VirtualMachinesClientGeneralizeOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesClientGetOptions contains the optional parameters for the VirtualMachinesClient.Get method.
type VirtualMachinesClientGetOptions struct {
	// The expand expression to apply on the operation. 'InstanceView' retrieves a snapshot of the runtime properties of the virtual
	// machine that is managed by the platform and can change outside of control
	// plane operations. 'UserData' retrieves the UserData property as part of the VM model view that was provided by the user
	// during the VM Create/Update operation.
	Expand *InstanceViewTypes
}

// VirtualMachinesClientInstanceViewOptions contains the optional parameters for the VirtualMachinesClient.InstanceView method.
type VirtualMachinesClientInstanceViewOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesClientListAllOptions contains the optional parameters for the VirtualMachinesClient.ListAll method.
type VirtualMachinesClientListAllOptions struct {
	// The system query option to filter VMs returned in the response. Allowed value is 'virtualMachineScaleSet/id' eq
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmssName}'
	Filter *string
	// statusOnly=true enables fetching run time status of all Virtual Machines in the subscription.
	StatusOnly *string
}

// VirtualMachinesClientListAvailableSizesOptions contains the optional parameters for the VirtualMachinesClient.ListAvailableSizes
// method.
type VirtualMachinesClientListAvailableSizesOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesClientListByLocationOptions contains the optional parameters for the VirtualMachinesClient.ListByLocation
// method.
type VirtualMachinesClientListByLocationOptions struct {
	// placeholder for future optional parameters
}

// VirtualMachinesClientListOptions contains the optional parameters for the VirtualMachinesClient.List method.
type VirtualMachinesClientListOptions struct {
	// The system query option to filter VMs returned in the response. Allowed value is 'virtualMachineScaleSet/id' eq
	// /subscriptions/{subId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Compute/virtualMachineScaleSets/{vmssName}'
	Filter *string
}

// VirtualMachinesClientRetrieveBootDiagnosticsDataOptions contains the optional parameters for the VirtualMachinesClient.RetrieveBootDiagnosticsData
// method.
type VirtualMachinesClientRetrieveBootDiagnosticsDataOptions struct {
	// Expiration duration in minutes for the SAS URIs with a value between 1 to 1440 minutes.
	// NOTE: If not specified, SAS URIs will be generated with a default expiration duration of 120 minutes.
	SasURIExpirationTimeInMinutes *int32
}

// VirtualMachinesClientSimulateEvictionOptions contains the optional parameters for the VirtualMachinesClient.SimulateEviction
// method.
type VirtualMachinesClientSimulateEvictionOptions struct {
	// placeholder for future optional parameters
}

// WinRMConfiguration - Describes Windows Remote Management configuration of the VM
type WinRMConfiguration struct {
	// The list of Windows Remote Management listeners
	Listeners []*WinRMListener `json:"listeners,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WinRMConfiguration.
func (w WinRMConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "listeners", w.Listeners)
	return json.Marshal(objectMap)
}

// WinRMListener - Describes Protocol and thumbprint of Windows Remote Management listener
type WinRMListener struct {
	// This is the URL of a certificate that has been uploaded to Key Vault as a secret. For adding a secret to the Key Vault,
	// see Add a key or secret to the key vault
	// [https://docs.microsoft.com/azure/key-vault/key-vault-get-started/#add]. In this case, your certificate needs to be It
	// is the Base64 encoding of the following JSON Object which is encoded in UTF-8:
	// {
	// "data":"",
	// "dataType":"pfx",
	// "password":""
	// }
	// To install certificates on a virtual machine it is recommended to use the Azure Key Vault virtual machine extension for
	// Linux
	// [https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-linux] or the Azure Key Vault virtual machine extension
	// for Windows
	// [https://docs.microsoft.com/azure/virtual-machines/extensions/key-vault-windows].
	CertificateURL *string `json:"certificateUrl,omitempty"`

	// Specifies the protocol of WinRM listener.
	// Possible values are:
	// http
	// https
	Protocol *ProtocolTypes `json:"protocol,omitempty"`
}

// WindowsConfiguration - Specifies Windows operating system settings on the virtual machine.
type WindowsConfiguration struct {
	// Specifies additional base-64 encoded XML formatted information that can be included in the Unattend.xml file, which is
	// used by Windows Setup.
	AdditionalUnattendContent []*AdditionalUnattendContent `json:"additionalUnattendContent,omitempty"`

	// Indicates whether Automatic Updates is enabled for the Windows virtual machine. Default value is true.
	// For virtual machine scale sets, this property can be updated and updates will take effect on OS reprovisioning.
	EnableAutomaticUpdates *bool `json:"enableAutomaticUpdates,omitempty"`

	// [Preview Feature] Specifies settings related to VM Guest Patching on Windows.
	PatchSettings *PatchSettings `json:"patchSettings,omitempty"`

	// Indicates whether virtual machine agent should be provisioned on the virtual machine.
	// When this property is not specified in the request body, default behavior is to set it to true. This will ensure that VM
	// Agent is installed on the VM so that extensions can be added to the VM later.
	ProvisionVMAgent *bool `json:"provisionVMAgent,omitempty"`

	// Specifies the time zone of the virtual machine. e.g. "Pacific Standard Time".
	// Possible values can be TimeZoneInfo.Id [https://docs.microsoft.com/dotnet/api/system.timezoneinfo.id?#System_TimeZoneInfo_Id]
	// value from time zones returned by TimeZoneInfo.GetSystemTimeZones
	// [https://docs.microsoft.com/dotnet/api/system.timezoneinfo.getsystemtimezones].
	TimeZone *string `json:"timeZone,omitempty"`

	// Specifies the Windows Remote Management listeners. This enables remote Windows PowerShell.
	WinRM *WinRMConfiguration `json:"winRM,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WindowsConfiguration.
func (w WindowsConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalUnattendContent", w.AdditionalUnattendContent)
	populate(objectMap, "enableAutomaticUpdates", w.EnableAutomaticUpdates)
	populate(objectMap, "patchSettings", w.PatchSettings)
	populate(objectMap, "provisionVMAgent", w.ProvisionVMAgent)
	populate(objectMap, "timeZone", w.TimeZone)
	populate(objectMap, "winRM", w.WinRM)
	return json.Marshal(objectMap)
}

// WindowsParameters - Input for InstallPatches on a Windows VM, as directly received by the API
type WindowsParameters struct {
	// The update classifications to select when installing patches for Windows.
	ClassificationsToInclude []*VMGuestPatchClassificationWindows `json:"classificationsToInclude,omitempty"`

	// Filters out Kbs that don't have an InstallationRebootBehavior of 'NeverReboots' when this is set to true.
	ExcludeKbsRequiringReboot *bool `json:"excludeKbsRequiringReboot,omitempty"`

	// Kbs to exclude in the patch operation
	KbNumbersToExclude []*string `json:"kbNumbersToExclude,omitempty"`

	// Kbs to include in the patch operation
	KbNumbersToInclude []*string `json:"kbNumbersToInclude,omitempty"`

	// This is used to install patches that were published on or before this given max published date.
	MaxPatchPublishDate *time.Time `json:"maxPatchPublishDate,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type WindowsParameters.
func (w WindowsParameters) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "classificationsToInclude", w.ClassificationsToInclude)
	populate(objectMap, "excludeKbsRequiringReboot", w.ExcludeKbsRequiringReboot)
	populate(objectMap, "kbNumbersToExclude", w.KbNumbersToExclude)
	populate(objectMap, "kbNumbersToInclude", w.KbNumbersToInclude)
	populateTimeRFC3339(objectMap, "maxPatchPublishDate", w.MaxPatchPublishDate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WindowsParameters.
func (w *WindowsParameters) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "classificationsToInclude":
			err = unpopulate(val, &w.ClassificationsToInclude)
			delete(rawMsg, key)
		case "excludeKbsRequiringReboot":
			err = unpopulate(val, &w.ExcludeKbsRequiringReboot)
			delete(rawMsg, key)
		case "kbNumbersToExclude":
			err = unpopulate(val, &w.KbNumbersToExclude)
			delete(rawMsg, key)
		case "kbNumbersToInclude":
			err = unpopulate(val, &w.KbNumbersToInclude)
			delete(rawMsg, key)
		case "maxPatchPublishDate":
			err = unpopulateTimeRFC3339(val, &w.MaxPatchPublishDate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// WindowsVMGuestPatchAutomaticByPlatformSettings - Specifies additional settings to be applied when patch mode AutomaticByPlatform
// is selected in Windows patch settings.
type WindowsVMGuestPatchAutomaticByPlatformSettings struct {
	// Specifies the reboot setting for all AutomaticByPlatform patch installation operations.
	RebootSetting *WindowsVMGuestPatchAutomaticByPlatformRebootSetting `json:"rebootSetting,omitempty"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
