//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcompute

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// VirtualMachineExtensionsClientCreateOrUpdatePollerResponse contains the response from method VirtualMachineExtensionsClient.CreateOrUpdate.
type VirtualMachineExtensionsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineExtensionsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineExtensionsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineExtensionsClientCreateOrUpdateResponse, error) {
	respType := VirtualMachineExtensionsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineExtension)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachineExtensionsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachineExtensionsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachineExtensionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineExtensionsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineExtensionsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachineExtensionsClientCreateOrUpdateResponse contains the response from method VirtualMachineExtensionsClient.CreateOrUpdate.
type VirtualMachineExtensionsClientCreateOrUpdateResponse struct {
	VirtualMachineExtensionsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineExtensionsClientCreateOrUpdateResult contains the result from method VirtualMachineExtensionsClient.CreateOrUpdate.
type VirtualMachineExtensionsClientCreateOrUpdateResult struct {
	VirtualMachineExtension
}

// VirtualMachineExtensionsClientDeletePollerResponse contains the response from method VirtualMachineExtensionsClient.Delete.
type VirtualMachineExtensionsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineExtensionsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineExtensionsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineExtensionsClientDeleteResponse, error) {
	respType := VirtualMachineExtensionsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachineExtensionsClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualMachineExtensionsClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualMachineExtensionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineExtensionsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineExtensionsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachineExtensionsClientDeleteResponse contains the response from method VirtualMachineExtensionsClient.Delete.
type VirtualMachineExtensionsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineExtensionsClientGetResponse contains the response from method VirtualMachineExtensionsClient.Get.
type VirtualMachineExtensionsClientGetResponse struct {
	VirtualMachineExtensionsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineExtensionsClientGetResult contains the result from method VirtualMachineExtensionsClient.Get.
type VirtualMachineExtensionsClientGetResult struct {
	VirtualMachineExtension
}

// VirtualMachineExtensionsClientListResponse contains the response from method VirtualMachineExtensionsClient.List.
type VirtualMachineExtensionsClientListResponse struct {
	VirtualMachineExtensionsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineExtensionsClientListResult contains the result from method VirtualMachineExtensionsClient.List.
type VirtualMachineExtensionsClientListResult struct {
	VirtualMachineExtensionsListResult
}

// VirtualMachineExtensionsClientUpdatePollerResponse contains the response from method VirtualMachineExtensionsClient.Update.
type VirtualMachineExtensionsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineExtensionsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineExtensionsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineExtensionsClientUpdateResponse, error) {
	respType := VirtualMachineExtensionsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineExtension)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachineExtensionsClientUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachineExtensionsClientUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachineExtensionsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineExtensionsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineExtensionsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachineExtensionsClientUpdateResponse contains the response from method VirtualMachineExtensionsClient.Update.
type VirtualMachineExtensionsClientUpdateResponse struct {
	VirtualMachineExtensionsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineExtensionsClientUpdateResult contains the result from method VirtualMachineExtensionsClient.Update.
type VirtualMachineExtensionsClientUpdateResult struct {
	VirtualMachineExtension
}

// VirtualMachineRunCommandsClientCreateOrUpdatePollerResponse contains the response from method VirtualMachineRunCommandsClient.CreateOrUpdate.
type VirtualMachineRunCommandsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineRunCommandsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineRunCommandsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineRunCommandsClientCreateOrUpdateResponse, error) {
	respType := VirtualMachineRunCommandsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineRunCommand)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachineRunCommandsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachineRunCommandsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachineRunCommandsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineRunCommandsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineRunCommandsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachineRunCommandsClientCreateOrUpdateResponse contains the response from method VirtualMachineRunCommandsClient.CreateOrUpdate.
type VirtualMachineRunCommandsClientCreateOrUpdateResponse struct {
	VirtualMachineRunCommandsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineRunCommandsClientCreateOrUpdateResult contains the result from method VirtualMachineRunCommandsClient.CreateOrUpdate.
type VirtualMachineRunCommandsClientCreateOrUpdateResult struct {
	VirtualMachineRunCommand
}

// VirtualMachineRunCommandsClientDeletePollerResponse contains the response from method VirtualMachineRunCommandsClient.Delete.
type VirtualMachineRunCommandsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineRunCommandsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineRunCommandsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineRunCommandsClientDeleteResponse, error) {
	respType := VirtualMachineRunCommandsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachineRunCommandsClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualMachineRunCommandsClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualMachineRunCommandsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineRunCommandsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineRunCommandsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachineRunCommandsClientDeleteResponse contains the response from method VirtualMachineRunCommandsClient.Delete.
type VirtualMachineRunCommandsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineRunCommandsClientGetByVirtualMachineResponse contains the response from method VirtualMachineRunCommandsClient.GetByVirtualMachine.
type VirtualMachineRunCommandsClientGetByVirtualMachineResponse struct {
	VirtualMachineRunCommandsClientGetByVirtualMachineResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineRunCommandsClientGetByVirtualMachineResult contains the result from method VirtualMachineRunCommandsClient.GetByVirtualMachine.
type VirtualMachineRunCommandsClientGetByVirtualMachineResult struct {
	VirtualMachineRunCommand
}

// VirtualMachineRunCommandsClientGetResponse contains the response from method VirtualMachineRunCommandsClient.Get.
type VirtualMachineRunCommandsClientGetResponse struct {
	VirtualMachineRunCommandsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineRunCommandsClientGetResult contains the result from method VirtualMachineRunCommandsClient.Get.
type VirtualMachineRunCommandsClientGetResult struct {
	RunCommandDocument
}

// VirtualMachineRunCommandsClientListByVirtualMachineResponse contains the response from method VirtualMachineRunCommandsClient.ListByVirtualMachine.
type VirtualMachineRunCommandsClientListByVirtualMachineResponse struct {
	VirtualMachineRunCommandsClientListByVirtualMachineResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineRunCommandsClientListByVirtualMachineResult contains the result from method VirtualMachineRunCommandsClient.ListByVirtualMachine.
type VirtualMachineRunCommandsClientListByVirtualMachineResult struct {
	VirtualMachineRunCommandsListResult
}

// VirtualMachineRunCommandsClientListResponse contains the response from method VirtualMachineRunCommandsClient.List.
type VirtualMachineRunCommandsClientListResponse struct {
	VirtualMachineRunCommandsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineRunCommandsClientListResult contains the result from method VirtualMachineRunCommandsClient.List.
type VirtualMachineRunCommandsClientListResult struct {
	RunCommandListResult
}

// VirtualMachineRunCommandsClientUpdatePollerResponse contains the response from method VirtualMachineRunCommandsClient.Update.
type VirtualMachineRunCommandsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineRunCommandsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineRunCommandsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineRunCommandsClientUpdateResponse, error) {
	respType := VirtualMachineRunCommandsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineRunCommand)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachineRunCommandsClientUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachineRunCommandsClientUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachineRunCommandsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineRunCommandsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineRunCommandsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachineRunCommandsClientUpdateResponse contains the response from method VirtualMachineRunCommandsClient.Update.
type VirtualMachineRunCommandsClientUpdateResponse struct {
	VirtualMachineRunCommandsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineRunCommandsClientUpdateResult contains the result from method VirtualMachineRunCommandsClient.Update.
type VirtualMachineRunCommandsClientUpdateResult struct {
	VirtualMachineRunCommand
}

// VirtualMachineScaleSetVMRunCommandsClientCreateOrUpdatePollerResponse contains the response from method VirtualMachineScaleSetVMRunCommandsClient.CreateOrUpdate.
type VirtualMachineScaleSetVMRunCommandsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMRunCommandsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMRunCommandsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMRunCommandsClientCreateOrUpdateResponse, error) {
	respType := VirtualMachineScaleSetVMRunCommandsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineRunCommand)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMRunCommandsClientCreateOrUpdatePollerResponse from the provided client and
// resume token.
func (l *VirtualMachineScaleSetVMRunCommandsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMRunCommandsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMRunCommandsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMRunCommandsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachineScaleSetVMRunCommandsClientCreateOrUpdateResponse contains the response from method VirtualMachineScaleSetVMRunCommandsClient.CreateOrUpdate.
type VirtualMachineScaleSetVMRunCommandsClientCreateOrUpdateResponse struct {
	VirtualMachineScaleSetVMRunCommandsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineScaleSetVMRunCommandsClientCreateOrUpdateResult contains the result from method VirtualMachineScaleSetVMRunCommandsClient.CreateOrUpdate.
type VirtualMachineScaleSetVMRunCommandsClientCreateOrUpdateResult struct {
	VirtualMachineRunCommand
}

// VirtualMachineScaleSetVMRunCommandsClientDeletePollerResponse contains the response from method VirtualMachineScaleSetVMRunCommandsClient.Delete.
type VirtualMachineScaleSetVMRunCommandsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMRunCommandsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMRunCommandsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMRunCommandsClientDeleteResponse, error) {
	respType := VirtualMachineScaleSetVMRunCommandsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMRunCommandsClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetVMRunCommandsClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMRunCommandsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMRunCommandsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMRunCommandsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachineScaleSetVMRunCommandsClientDeleteResponse contains the response from method VirtualMachineScaleSetVMRunCommandsClient.Delete.
type VirtualMachineScaleSetVMRunCommandsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineScaleSetVMRunCommandsClientGetResponse contains the response from method VirtualMachineScaleSetVMRunCommandsClient.Get.
type VirtualMachineScaleSetVMRunCommandsClientGetResponse struct {
	VirtualMachineScaleSetVMRunCommandsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineScaleSetVMRunCommandsClientGetResult contains the result from method VirtualMachineScaleSetVMRunCommandsClient.Get.
type VirtualMachineScaleSetVMRunCommandsClientGetResult struct {
	VirtualMachineRunCommand
}

// VirtualMachineScaleSetVMRunCommandsClientListResponse contains the response from method VirtualMachineScaleSetVMRunCommandsClient.List.
type VirtualMachineScaleSetVMRunCommandsClientListResponse struct {
	VirtualMachineScaleSetVMRunCommandsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineScaleSetVMRunCommandsClientListResult contains the result from method VirtualMachineScaleSetVMRunCommandsClient.List.
type VirtualMachineScaleSetVMRunCommandsClientListResult struct {
	VirtualMachineRunCommandsListResult
}

// VirtualMachineScaleSetVMRunCommandsClientUpdatePollerResponse contains the response from method VirtualMachineScaleSetVMRunCommandsClient.Update.
type VirtualMachineScaleSetVMRunCommandsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMRunCommandsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMRunCommandsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMRunCommandsClientUpdateResponse, error) {
	respType := VirtualMachineScaleSetVMRunCommandsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineRunCommand)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMRunCommandsClientUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetVMRunCommandsClientUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMRunCommandsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMRunCommandsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMRunCommandsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachineScaleSetVMRunCommandsClientUpdateResponse contains the response from method VirtualMachineScaleSetVMRunCommandsClient.Update.
type VirtualMachineScaleSetVMRunCommandsClientUpdateResponse struct {
	VirtualMachineScaleSetVMRunCommandsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineScaleSetVMRunCommandsClientUpdateResult contains the result from method VirtualMachineScaleSetVMRunCommandsClient.Update.
type VirtualMachineScaleSetVMRunCommandsClientUpdateResult struct {
	VirtualMachineRunCommand
}

// VirtualMachineScaleSetVMsClientRunCommandPollerResponse contains the response from method VirtualMachineScaleSetVMsClient.RunCommand.
type VirtualMachineScaleSetVMsClientRunCommandPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineScaleSetVMsClientRunCommandPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineScaleSetVMsClientRunCommandPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineScaleSetVMsClientRunCommandResponse, error) {
	respType := VirtualMachineScaleSetVMsClientRunCommandResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RunCommandResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachineScaleSetVMsClientRunCommandPollerResponse from the provided client and resume token.
func (l *VirtualMachineScaleSetVMsClientRunCommandPollerResponse) Resume(ctx context.Context, client *VirtualMachineScaleSetVMsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineScaleSetVMsClient.RunCommand", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineScaleSetVMsClientRunCommandPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachineScaleSetVMsClientRunCommandResponse contains the response from method VirtualMachineScaleSetVMsClient.RunCommand.
type VirtualMachineScaleSetVMsClientRunCommandResponse struct {
	VirtualMachineScaleSetVMsClientRunCommandResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachineScaleSetVMsClientRunCommandResult contains the result from method VirtualMachineScaleSetVMsClient.RunCommand.
type VirtualMachineScaleSetVMsClientRunCommandResult struct {
	RunCommandResult
}

// VirtualMachinesClientAssessPatchesPollerResponse contains the response from method VirtualMachinesClient.AssessPatches.
type VirtualMachinesClientAssessPatchesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientAssessPatchesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientAssessPatchesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientAssessPatchesResponse, error) {
	respType := VirtualMachinesClientAssessPatchesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineAssessPatchesResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientAssessPatchesPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientAssessPatchesPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.AssessPatches", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientAssessPatchesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesClientAssessPatchesResponse contains the response from method VirtualMachinesClient.AssessPatches.
type VirtualMachinesClientAssessPatchesResponse struct {
	VirtualMachinesClientAssessPatchesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientAssessPatchesResult contains the result from method VirtualMachinesClient.AssessPatches.
type VirtualMachinesClientAssessPatchesResult struct {
	VirtualMachineAssessPatchesResult
}

// VirtualMachinesClientCapturePollerResponse contains the response from method VirtualMachinesClient.Capture.
type VirtualMachinesClientCapturePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientCapturePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientCapturePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientCaptureResponse, error) {
	respType := VirtualMachinesClientCaptureResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineCaptureResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientCapturePollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientCapturePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Capture", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientCapturePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesClientCaptureResponse contains the response from method VirtualMachinesClient.Capture.
type VirtualMachinesClientCaptureResponse struct {
	VirtualMachinesClientCaptureResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientCaptureResult contains the result from method VirtualMachinesClient.Capture.
type VirtualMachinesClientCaptureResult struct {
	VirtualMachineCaptureResult
}

// VirtualMachinesClientConvertToManagedDisksPollerResponse contains the response from method VirtualMachinesClient.ConvertToManagedDisks.
type VirtualMachinesClientConvertToManagedDisksPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientConvertToManagedDisksPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientConvertToManagedDisksPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientConvertToManagedDisksResponse, error) {
	respType := VirtualMachinesClientConvertToManagedDisksResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientConvertToManagedDisksPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientConvertToManagedDisksPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.ConvertToManagedDisks", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientConvertToManagedDisksPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesClientConvertToManagedDisksResponse contains the response from method VirtualMachinesClient.ConvertToManagedDisks.
type VirtualMachinesClientConvertToManagedDisksResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientCreateOrUpdatePollerResponse contains the response from method VirtualMachinesClient.CreateOrUpdate.
type VirtualMachinesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientCreateOrUpdateResponse, error) {
	respType := VirtualMachinesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachine)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesClientCreateOrUpdateResponse contains the response from method VirtualMachinesClient.CreateOrUpdate.
type VirtualMachinesClientCreateOrUpdateResponse struct {
	VirtualMachinesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientCreateOrUpdateResult contains the result from method VirtualMachinesClient.CreateOrUpdate.
type VirtualMachinesClientCreateOrUpdateResult struct {
	VirtualMachine
}

// VirtualMachinesClientDeallocatePollerResponse contains the response from method VirtualMachinesClient.Deallocate.
type VirtualMachinesClientDeallocatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientDeallocatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientDeallocatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientDeallocateResponse, error) {
	respType := VirtualMachinesClientDeallocateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientDeallocatePollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientDeallocatePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Deallocate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientDeallocatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesClientDeallocateResponse contains the response from method VirtualMachinesClient.Deallocate.
type VirtualMachinesClientDeallocateResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientDeletePollerResponse contains the response from method VirtualMachinesClient.Delete.
type VirtualMachinesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientDeleteResponse, error) {
	respType := VirtualMachinesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesClientDeleteResponse contains the response from method VirtualMachinesClient.Delete.
type VirtualMachinesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientGeneralizeResponse contains the response from method VirtualMachinesClient.Generalize.
type VirtualMachinesClientGeneralizeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientGetResponse contains the response from method VirtualMachinesClient.Get.
type VirtualMachinesClientGetResponse struct {
	VirtualMachinesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientGetResult contains the result from method VirtualMachinesClient.Get.
type VirtualMachinesClientGetResult struct {
	VirtualMachine
}

// VirtualMachinesClientInstallPatchesPollerResponse contains the response from method VirtualMachinesClient.InstallPatches.
type VirtualMachinesClientInstallPatchesPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientInstallPatchesPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientInstallPatchesPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientInstallPatchesResponse, error) {
	respType := VirtualMachinesClientInstallPatchesResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachineInstallPatchesResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientInstallPatchesPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientInstallPatchesPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.InstallPatches", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientInstallPatchesPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesClientInstallPatchesResponse contains the response from method VirtualMachinesClient.InstallPatches.
type VirtualMachinesClientInstallPatchesResponse struct {
	VirtualMachinesClientInstallPatchesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientInstallPatchesResult contains the result from method VirtualMachinesClient.InstallPatches.
type VirtualMachinesClientInstallPatchesResult struct {
	VirtualMachineInstallPatchesResult
}

// VirtualMachinesClientInstanceViewResponse contains the response from method VirtualMachinesClient.InstanceView.
type VirtualMachinesClientInstanceViewResponse struct {
	VirtualMachinesClientInstanceViewResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientInstanceViewResult contains the result from method VirtualMachinesClient.InstanceView.
type VirtualMachinesClientInstanceViewResult struct {
	VirtualMachineInstanceView
}

// VirtualMachinesClientListAllResponse contains the response from method VirtualMachinesClient.ListAll.
type VirtualMachinesClientListAllResponse struct {
	VirtualMachinesClientListAllResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientListAllResult contains the result from method VirtualMachinesClient.ListAll.
type VirtualMachinesClientListAllResult struct {
	VirtualMachineListResult
}

// VirtualMachinesClientListAvailableSizesResponse contains the response from method VirtualMachinesClient.ListAvailableSizes.
type VirtualMachinesClientListAvailableSizesResponse struct {
	VirtualMachinesClientListAvailableSizesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientListAvailableSizesResult contains the result from method VirtualMachinesClient.ListAvailableSizes.
type VirtualMachinesClientListAvailableSizesResult struct {
	VirtualMachineSizeListResult
}

// VirtualMachinesClientListByLocationResponse contains the response from method VirtualMachinesClient.ListByLocation.
type VirtualMachinesClientListByLocationResponse struct {
	VirtualMachinesClientListByLocationResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientListByLocationResult contains the result from method VirtualMachinesClient.ListByLocation.
type VirtualMachinesClientListByLocationResult struct {
	VirtualMachineListResult
}

// VirtualMachinesClientListResponse contains the response from method VirtualMachinesClient.List.
type VirtualMachinesClientListResponse struct {
	VirtualMachinesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientListResult contains the result from method VirtualMachinesClient.List.
type VirtualMachinesClientListResult struct {
	VirtualMachineListResult
}

// VirtualMachinesClientPerformMaintenancePollerResponse contains the response from method VirtualMachinesClient.PerformMaintenance.
type VirtualMachinesClientPerformMaintenancePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientPerformMaintenancePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientPerformMaintenancePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientPerformMaintenanceResponse, error) {
	respType := VirtualMachinesClientPerformMaintenanceResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientPerformMaintenancePollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientPerformMaintenancePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.PerformMaintenance", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientPerformMaintenancePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesClientPerformMaintenanceResponse contains the response from method VirtualMachinesClient.PerformMaintenance.
type VirtualMachinesClientPerformMaintenanceResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientPowerOffPollerResponse contains the response from method VirtualMachinesClient.PowerOff.
type VirtualMachinesClientPowerOffPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientPowerOffPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientPowerOffPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientPowerOffResponse, error) {
	respType := VirtualMachinesClientPowerOffResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientPowerOffPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientPowerOffPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.PowerOff", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientPowerOffPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesClientPowerOffResponse contains the response from method VirtualMachinesClient.PowerOff.
type VirtualMachinesClientPowerOffResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientReapplyPollerResponse contains the response from method VirtualMachinesClient.Reapply.
type VirtualMachinesClientReapplyPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientReapplyPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientReapplyPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientReapplyResponse, error) {
	respType := VirtualMachinesClientReapplyResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientReapplyPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientReapplyPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Reapply", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientReapplyPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesClientReapplyResponse contains the response from method VirtualMachinesClient.Reapply.
type VirtualMachinesClientReapplyResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientRedeployPollerResponse contains the response from method VirtualMachinesClient.Redeploy.
type VirtualMachinesClientRedeployPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientRedeployPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientRedeployPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientRedeployResponse, error) {
	respType := VirtualMachinesClientRedeployResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientRedeployPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientRedeployPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Redeploy", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientRedeployPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesClientRedeployResponse contains the response from method VirtualMachinesClient.Redeploy.
type VirtualMachinesClientRedeployResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientReimagePollerResponse contains the response from method VirtualMachinesClient.Reimage.
type VirtualMachinesClientReimagePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientReimagePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientReimagePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientReimageResponse, error) {
	respType := VirtualMachinesClientReimageResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientReimagePollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientReimagePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Reimage", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientReimagePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesClientReimageResponse contains the response from method VirtualMachinesClient.Reimage.
type VirtualMachinesClientReimageResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientRestartPollerResponse contains the response from method VirtualMachinesClient.Restart.
type VirtualMachinesClientRestartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientRestartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientRestartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientRestartResponse, error) {
	respType := VirtualMachinesClientRestartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientRestartPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientRestartPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Restart", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientRestartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesClientRestartResponse contains the response from method VirtualMachinesClient.Restart.
type VirtualMachinesClientRestartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientRetrieveBootDiagnosticsDataResponse contains the response from method VirtualMachinesClient.RetrieveBootDiagnosticsData.
type VirtualMachinesClientRetrieveBootDiagnosticsDataResponse struct {
	VirtualMachinesClientRetrieveBootDiagnosticsDataResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientRetrieveBootDiagnosticsDataResult contains the result from method VirtualMachinesClient.RetrieveBootDiagnosticsData.
type VirtualMachinesClientRetrieveBootDiagnosticsDataResult struct {
	RetrieveBootDiagnosticsDataResult
}

// VirtualMachinesClientRunCommandPollerResponse contains the response from method VirtualMachinesClient.RunCommand.
type VirtualMachinesClientRunCommandPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientRunCommandPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientRunCommandPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientRunCommandResponse, error) {
	respType := VirtualMachinesClientRunCommandResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.RunCommandResult)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientRunCommandPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientRunCommandPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.RunCommand", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientRunCommandPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesClientRunCommandResponse contains the response from method VirtualMachinesClient.RunCommand.
type VirtualMachinesClientRunCommandResponse struct {
	VirtualMachinesClientRunCommandResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientRunCommandResult contains the result from method VirtualMachinesClient.RunCommand.
type VirtualMachinesClientRunCommandResult struct {
	RunCommandResult
}

// VirtualMachinesClientSimulateEvictionResponse contains the response from method VirtualMachinesClient.SimulateEviction.
type VirtualMachinesClientSimulateEvictionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientStartPollerResponse contains the response from method VirtualMachinesClient.Start.
type VirtualMachinesClientStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientStartPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientStartResponse, error) {
	respType := VirtualMachinesClientStartResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientStartPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientStartPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Start", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientStartPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesClientStartResponse contains the response from method VirtualMachinesClient.Start.
type VirtualMachinesClientStartResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientUpdatePollerResponse contains the response from method VirtualMachinesClient.Update.
type VirtualMachinesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientUpdateResponse, error) {
	respType := VirtualMachinesClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualMachine)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// VirtualMachinesClientUpdateResponse contains the response from method VirtualMachinesClient.Update.
type VirtualMachinesClientUpdateResponse struct {
	VirtualMachinesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// VirtualMachinesClientUpdateResult contains the result from method VirtualMachinesClient.Update.
type VirtualMachinesClientUpdateResult struct {
	VirtualMachine
}
