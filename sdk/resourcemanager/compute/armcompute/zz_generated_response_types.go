//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcompute

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// DiskAccessesClientCreateOrUpdatePollerResponse contains the response from method DiskAccessesClient.CreateOrUpdate.
type DiskAccessesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskAccessesClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskAccessesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskAccessesClientCreateOrUpdateResponse, error) {
	respType := DiskAccessesClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DiskAccess)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiskAccessesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DiskAccessesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DiskAccessesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskAccessesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskAccessesClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiskAccessesClientCreateOrUpdateResponse contains the response from method DiskAccessesClient.CreateOrUpdate.
type DiskAccessesClientCreateOrUpdateResponse struct {
	DiskAccessesClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskAccessesClientCreateOrUpdateResult contains the result from method DiskAccessesClient.CreateOrUpdate.
type DiskAccessesClientCreateOrUpdateResult struct {
	DiskAccess
}

// DiskAccessesClientDeleteAPrivateEndpointConnectionPollerResponse contains the response from method DiskAccessesClient.DeleteAPrivateEndpointConnection.
type DiskAccessesClientDeleteAPrivateEndpointConnectionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskAccessesClientDeleteAPrivateEndpointConnectionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskAccessesClientDeleteAPrivateEndpointConnectionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskAccessesClientDeleteAPrivateEndpointConnectionResponse, error) {
	respType := DiskAccessesClientDeleteAPrivateEndpointConnectionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiskAccessesClientDeleteAPrivateEndpointConnectionPollerResponse from the provided client and resume
// token.
func (l *DiskAccessesClientDeleteAPrivateEndpointConnectionPollerResponse) Resume(ctx context.Context, client *DiskAccessesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskAccessesClient.DeleteAPrivateEndpointConnection", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskAccessesClientDeleteAPrivateEndpointConnectionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiskAccessesClientDeleteAPrivateEndpointConnectionResponse contains the response from method DiskAccessesClient.DeleteAPrivateEndpointConnection.
type DiskAccessesClientDeleteAPrivateEndpointConnectionResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskAccessesClientDeletePollerResponse contains the response from method DiskAccessesClient.Delete.
type DiskAccessesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskAccessesClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskAccessesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskAccessesClientDeleteResponse, error) {
	respType := DiskAccessesClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiskAccessesClientDeletePollerResponse from the provided client and resume token.
func (l *DiskAccessesClientDeletePollerResponse) Resume(ctx context.Context, client *DiskAccessesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskAccessesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskAccessesClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiskAccessesClientDeleteResponse contains the response from method DiskAccessesClient.Delete.
type DiskAccessesClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskAccessesClientGetAPrivateEndpointConnectionResponse contains the response from method DiskAccessesClient.GetAPrivateEndpointConnection.
type DiskAccessesClientGetAPrivateEndpointConnectionResponse struct {
	DiskAccessesClientGetAPrivateEndpointConnectionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskAccessesClientGetAPrivateEndpointConnectionResult contains the result from method DiskAccessesClient.GetAPrivateEndpointConnection.
type DiskAccessesClientGetAPrivateEndpointConnectionResult struct {
	PrivateEndpointConnection
}

// DiskAccessesClientGetPrivateLinkResourcesResponse contains the response from method DiskAccessesClient.GetPrivateLinkResources.
type DiskAccessesClientGetPrivateLinkResourcesResponse struct {
	DiskAccessesClientGetPrivateLinkResourcesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskAccessesClientGetPrivateLinkResourcesResult contains the result from method DiskAccessesClient.GetPrivateLinkResources.
type DiskAccessesClientGetPrivateLinkResourcesResult struct {
	PrivateLinkResourceListResult
}

// DiskAccessesClientGetResponse contains the response from method DiskAccessesClient.Get.
type DiskAccessesClientGetResponse struct {
	DiskAccessesClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskAccessesClientGetResult contains the result from method DiskAccessesClient.Get.
type DiskAccessesClientGetResult struct {
	DiskAccess
}

// DiskAccessesClientListByResourceGroupResponse contains the response from method DiskAccessesClient.ListByResourceGroup.
type DiskAccessesClientListByResourceGroupResponse struct {
	DiskAccessesClientListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskAccessesClientListByResourceGroupResult contains the result from method DiskAccessesClient.ListByResourceGroup.
type DiskAccessesClientListByResourceGroupResult struct {
	DiskAccessList
}

// DiskAccessesClientListPrivateEndpointConnectionsResponse contains the response from method DiskAccessesClient.ListPrivateEndpointConnections.
type DiskAccessesClientListPrivateEndpointConnectionsResponse struct {
	DiskAccessesClientListPrivateEndpointConnectionsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskAccessesClientListPrivateEndpointConnectionsResult contains the result from method DiskAccessesClient.ListPrivateEndpointConnections.
type DiskAccessesClientListPrivateEndpointConnectionsResult struct {
	PrivateEndpointConnectionListResult
}

// DiskAccessesClientListResponse contains the response from method DiskAccessesClient.List.
type DiskAccessesClientListResponse struct {
	DiskAccessesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskAccessesClientListResult contains the result from method DiskAccessesClient.List.
type DiskAccessesClientListResult struct {
	DiskAccessList
}

// DiskAccessesClientUpdateAPrivateEndpointConnectionPollerResponse contains the response from method DiskAccessesClient.UpdateAPrivateEndpointConnection.
type DiskAccessesClientUpdateAPrivateEndpointConnectionPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskAccessesClientUpdateAPrivateEndpointConnectionPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskAccessesClientUpdateAPrivateEndpointConnectionPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskAccessesClientUpdateAPrivateEndpointConnectionResponse, error) {
	respType := DiskAccessesClientUpdateAPrivateEndpointConnectionResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PrivateEndpointConnection)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiskAccessesClientUpdateAPrivateEndpointConnectionPollerResponse from the provided client and resume
// token.
func (l *DiskAccessesClientUpdateAPrivateEndpointConnectionPollerResponse) Resume(ctx context.Context, client *DiskAccessesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskAccessesClient.UpdateAPrivateEndpointConnection", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskAccessesClientUpdateAPrivateEndpointConnectionPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiskAccessesClientUpdateAPrivateEndpointConnectionResponse contains the response from method DiskAccessesClient.UpdateAPrivateEndpointConnection.
type DiskAccessesClientUpdateAPrivateEndpointConnectionResponse struct {
	DiskAccessesClientUpdateAPrivateEndpointConnectionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskAccessesClientUpdateAPrivateEndpointConnectionResult contains the result from method DiskAccessesClient.UpdateAPrivateEndpointConnection.
type DiskAccessesClientUpdateAPrivateEndpointConnectionResult struct {
	PrivateEndpointConnection
}

// DiskAccessesClientUpdatePollerResponse contains the response from method DiskAccessesClient.Update.
type DiskAccessesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskAccessesClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskAccessesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskAccessesClientUpdateResponse, error) {
	respType := DiskAccessesClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DiskAccess)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiskAccessesClientUpdatePollerResponse from the provided client and resume token.
func (l *DiskAccessesClientUpdatePollerResponse) Resume(ctx context.Context, client *DiskAccessesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskAccessesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskAccessesClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiskAccessesClientUpdateResponse contains the response from method DiskAccessesClient.Update.
type DiskAccessesClientUpdateResponse struct {
	DiskAccessesClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskAccessesClientUpdateResult contains the result from method DiskAccessesClient.Update.
type DiskAccessesClientUpdateResult struct {
	DiskAccess
}

// DiskEncryptionSetsClientCreateOrUpdatePollerResponse contains the response from method DiskEncryptionSetsClient.CreateOrUpdate.
type DiskEncryptionSetsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskEncryptionSetsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskEncryptionSetsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskEncryptionSetsClientCreateOrUpdateResponse, error) {
	respType := DiskEncryptionSetsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DiskEncryptionSet)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiskEncryptionSetsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DiskEncryptionSetsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DiskEncryptionSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskEncryptionSetsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskEncryptionSetsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiskEncryptionSetsClientCreateOrUpdateResponse contains the response from method DiskEncryptionSetsClient.CreateOrUpdate.
type DiskEncryptionSetsClientCreateOrUpdateResponse struct {
	DiskEncryptionSetsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskEncryptionSetsClientCreateOrUpdateResult contains the result from method DiskEncryptionSetsClient.CreateOrUpdate.
type DiskEncryptionSetsClientCreateOrUpdateResult struct {
	DiskEncryptionSet
}

// DiskEncryptionSetsClientDeletePollerResponse contains the response from method DiskEncryptionSetsClient.Delete.
type DiskEncryptionSetsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskEncryptionSetsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskEncryptionSetsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskEncryptionSetsClientDeleteResponse, error) {
	respType := DiskEncryptionSetsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiskEncryptionSetsClientDeletePollerResponse from the provided client and resume token.
func (l *DiskEncryptionSetsClientDeletePollerResponse) Resume(ctx context.Context, client *DiskEncryptionSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskEncryptionSetsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskEncryptionSetsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiskEncryptionSetsClientDeleteResponse contains the response from method DiskEncryptionSetsClient.Delete.
type DiskEncryptionSetsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskEncryptionSetsClientGetResponse contains the response from method DiskEncryptionSetsClient.Get.
type DiskEncryptionSetsClientGetResponse struct {
	DiskEncryptionSetsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskEncryptionSetsClientGetResult contains the result from method DiskEncryptionSetsClient.Get.
type DiskEncryptionSetsClientGetResult struct {
	DiskEncryptionSet
}

// DiskEncryptionSetsClientListAssociatedResourcesResponse contains the response from method DiskEncryptionSetsClient.ListAssociatedResources.
type DiskEncryptionSetsClientListAssociatedResourcesResponse struct {
	DiskEncryptionSetsClientListAssociatedResourcesResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskEncryptionSetsClientListAssociatedResourcesResult contains the result from method DiskEncryptionSetsClient.ListAssociatedResources.
type DiskEncryptionSetsClientListAssociatedResourcesResult struct {
	ResourceURIList
}

// DiskEncryptionSetsClientListByResourceGroupResponse contains the response from method DiskEncryptionSetsClient.ListByResourceGroup.
type DiskEncryptionSetsClientListByResourceGroupResponse struct {
	DiskEncryptionSetsClientListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskEncryptionSetsClientListByResourceGroupResult contains the result from method DiskEncryptionSetsClient.ListByResourceGroup.
type DiskEncryptionSetsClientListByResourceGroupResult struct {
	DiskEncryptionSetList
}

// DiskEncryptionSetsClientListResponse contains the response from method DiskEncryptionSetsClient.List.
type DiskEncryptionSetsClientListResponse struct {
	DiskEncryptionSetsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskEncryptionSetsClientListResult contains the result from method DiskEncryptionSetsClient.List.
type DiskEncryptionSetsClientListResult struct {
	DiskEncryptionSetList
}

// DiskEncryptionSetsClientUpdatePollerResponse contains the response from method DiskEncryptionSetsClient.Update.
type DiskEncryptionSetsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskEncryptionSetsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskEncryptionSetsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskEncryptionSetsClientUpdateResponse, error) {
	respType := DiskEncryptionSetsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DiskEncryptionSet)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiskEncryptionSetsClientUpdatePollerResponse from the provided client and resume token.
func (l *DiskEncryptionSetsClientUpdatePollerResponse) Resume(ctx context.Context, client *DiskEncryptionSetsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskEncryptionSetsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskEncryptionSetsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiskEncryptionSetsClientUpdateResponse contains the response from method DiskEncryptionSetsClient.Update.
type DiskEncryptionSetsClientUpdateResponse struct {
	DiskEncryptionSetsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskEncryptionSetsClientUpdateResult contains the result from method DiskEncryptionSetsClient.Update.
type DiskEncryptionSetsClientUpdateResult struct {
	DiskEncryptionSet
}

// DiskRestorePointClientGetResponse contains the response from method DiskRestorePointClient.Get.
type DiskRestorePointClientGetResponse struct {
	DiskRestorePointClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskRestorePointClientGetResult contains the result from method DiskRestorePointClient.Get.
type DiskRestorePointClientGetResult struct {
	DiskRestorePoint
}

// DiskRestorePointClientGrantAccessPollerResponse contains the response from method DiskRestorePointClient.GrantAccess.
type DiskRestorePointClientGrantAccessPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskRestorePointClientGrantAccessPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskRestorePointClientGrantAccessPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskRestorePointClientGrantAccessResponse, error) {
	respType := DiskRestorePointClientGrantAccessResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AccessURI)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiskRestorePointClientGrantAccessPollerResponse from the provided client and resume token.
func (l *DiskRestorePointClientGrantAccessPollerResponse) Resume(ctx context.Context, client *DiskRestorePointClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskRestorePointClient.GrantAccess", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskRestorePointClientGrantAccessPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiskRestorePointClientGrantAccessResponse contains the response from method DiskRestorePointClient.GrantAccess.
type DiskRestorePointClientGrantAccessResponse struct {
	DiskRestorePointClientGrantAccessResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskRestorePointClientGrantAccessResult contains the result from method DiskRestorePointClient.GrantAccess.
type DiskRestorePointClientGrantAccessResult struct {
	AccessURI
}

// DiskRestorePointClientListByRestorePointResponse contains the response from method DiskRestorePointClient.ListByRestorePoint.
type DiskRestorePointClientListByRestorePointResponse struct {
	DiskRestorePointClientListByRestorePointResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DiskRestorePointClientListByRestorePointResult contains the result from method DiskRestorePointClient.ListByRestorePoint.
type DiskRestorePointClientListByRestorePointResult struct {
	DiskRestorePointList
}

// DiskRestorePointClientRevokeAccessPollerResponse contains the response from method DiskRestorePointClient.RevokeAccess.
type DiskRestorePointClientRevokeAccessPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DiskRestorePointClientRevokeAccessPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DiskRestorePointClientRevokeAccessPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DiskRestorePointClientRevokeAccessResponse, error) {
	respType := DiskRestorePointClientRevokeAccessResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DiskRestorePointClientRevokeAccessPollerResponse from the provided client and resume token.
func (l *DiskRestorePointClientRevokeAccessPollerResponse) Resume(ctx context.Context, client *DiskRestorePointClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DiskRestorePointClient.RevokeAccess", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DiskRestorePointClientRevokeAccessPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DiskRestorePointClientRevokeAccessResponse contains the response from method DiskRestorePointClient.RevokeAccess.
type DiskRestorePointClientRevokeAccessResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DisksClientCreateOrUpdatePollerResponse contains the response from method DisksClient.CreateOrUpdate.
type DisksClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientCreateOrUpdateResponse, error) {
	respType := DisksClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Disk)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DisksClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DisksClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DisksClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DisksClientCreateOrUpdateResponse contains the response from method DisksClient.CreateOrUpdate.
type DisksClientCreateOrUpdateResponse struct {
	DisksClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DisksClientCreateOrUpdateResult contains the result from method DisksClient.CreateOrUpdate.
type DisksClientCreateOrUpdateResult struct {
	Disk
}

// DisksClientDeletePollerResponse contains the response from method DisksClient.Delete.
type DisksClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientDeleteResponse, error) {
	respType := DisksClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DisksClientDeletePollerResponse from the provided client and resume token.
func (l *DisksClientDeletePollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DisksClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DisksClientDeleteResponse contains the response from method DisksClient.Delete.
type DisksClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DisksClientGetResponse contains the response from method DisksClient.Get.
type DisksClientGetResponse struct {
	DisksClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DisksClientGetResult contains the result from method DisksClient.Get.
type DisksClientGetResult struct {
	Disk
}

// DisksClientGrantAccessPollerResponse contains the response from method DisksClient.GrantAccess.
type DisksClientGrantAccessPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksClientGrantAccessPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksClientGrantAccessPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientGrantAccessResponse, error) {
	respType := DisksClientGrantAccessResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AccessURI)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DisksClientGrantAccessPollerResponse from the provided client and resume token.
func (l *DisksClientGrantAccessPollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.GrantAccess", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DisksClientGrantAccessPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DisksClientGrantAccessResponse contains the response from method DisksClient.GrantAccess.
type DisksClientGrantAccessResponse struct {
	DisksClientGrantAccessResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DisksClientGrantAccessResult contains the result from method DisksClient.GrantAccess.
type DisksClientGrantAccessResult struct {
	AccessURI
}

// DisksClientListByResourceGroupResponse contains the response from method DisksClient.ListByResourceGroup.
type DisksClientListByResourceGroupResponse struct {
	DisksClientListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DisksClientListByResourceGroupResult contains the result from method DisksClient.ListByResourceGroup.
type DisksClientListByResourceGroupResult struct {
	DiskList
}

// DisksClientListResponse contains the response from method DisksClient.List.
type DisksClientListResponse struct {
	DisksClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DisksClientListResult contains the result from method DisksClient.List.
type DisksClientListResult struct {
	DiskList
}

// DisksClientRevokeAccessPollerResponse contains the response from method DisksClient.RevokeAccess.
type DisksClientRevokeAccessPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksClientRevokeAccessPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksClientRevokeAccessPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientRevokeAccessResponse, error) {
	respType := DisksClientRevokeAccessResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DisksClientRevokeAccessPollerResponse from the provided client and resume token.
func (l *DisksClientRevokeAccessPollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.RevokeAccess", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DisksClientRevokeAccessPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DisksClientRevokeAccessResponse contains the response from method DisksClient.RevokeAccess.
type DisksClientRevokeAccessResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DisksClientUpdatePollerResponse contains the response from method DisksClient.Update.
type DisksClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientUpdateResponse, error) {
	respType := DisksClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Disk)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a DisksClientUpdatePollerResponse from the provided client and resume token.
func (l *DisksClientUpdatePollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DisksClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// DisksClientUpdateResponse contains the response from method DisksClient.Update.
type DisksClientUpdateResponse struct {
	DisksClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// DisksClientUpdateResult contains the result from method DisksClient.Update.
type DisksClientUpdateResult struct {
	Disk
}

// SnapshotsClientCreateOrUpdatePollerResponse contains the response from method SnapshotsClient.CreateOrUpdate.
type SnapshotsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SnapshotsClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SnapshotsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsClientCreateOrUpdateResponse, error) {
	respType := SnapshotsClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Snapshot)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SnapshotsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SnapshotsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SnapshotsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SnapshotsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SnapshotsClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SnapshotsClientCreateOrUpdateResponse contains the response from method SnapshotsClient.CreateOrUpdate.
type SnapshotsClientCreateOrUpdateResponse struct {
	SnapshotsClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotsClientCreateOrUpdateResult contains the result from method SnapshotsClient.CreateOrUpdate.
type SnapshotsClientCreateOrUpdateResult struct {
	Snapshot
}

// SnapshotsClientDeletePollerResponse contains the response from method SnapshotsClient.Delete.
type SnapshotsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SnapshotsClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SnapshotsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsClientDeleteResponse, error) {
	respType := SnapshotsClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SnapshotsClientDeletePollerResponse from the provided client and resume token.
func (l *SnapshotsClientDeletePollerResponse) Resume(ctx context.Context, client *SnapshotsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SnapshotsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SnapshotsClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SnapshotsClientDeleteResponse contains the response from method SnapshotsClient.Delete.
type SnapshotsClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotsClientGetResponse contains the response from method SnapshotsClient.Get.
type SnapshotsClientGetResponse struct {
	SnapshotsClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotsClientGetResult contains the result from method SnapshotsClient.Get.
type SnapshotsClientGetResult struct {
	Snapshot
}

// SnapshotsClientGrantAccessPollerResponse contains the response from method SnapshotsClient.GrantAccess.
type SnapshotsClientGrantAccessPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SnapshotsClientGrantAccessPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SnapshotsClientGrantAccessPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsClientGrantAccessResponse, error) {
	respType := SnapshotsClientGrantAccessResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AccessURI)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SnapshotsClientGrantAccessPollerResponse from the provided client and resume token.
func (l *SnapshotsClientGrantAccessPollerResponse) Resume(ctx context.Context, client *SnapshotsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SnapshotsClient.GrantAccess", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SnapshotsClientGrantAccessPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SnapshotsClientGrantAccessResponse contains the response from method SnapshotsClient.GrantAccess.
type SnapshotsClientGrantAccessResponse struct {
	SnapshotsClientGrantAccessResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotsClientGrantAccessResult contains the result from method SnapshotsClient.GrantAccess.
type SnapshotsClientGrantAccessResult struct {
	AccessURI
}

// SnapshotsClientListByResourceGroupResponse contains the response from method SnapshotsClient.ListByResourceGroup.
type SnapshotsClientListByResourceGroupResponse struct {
	SnapshotsClientListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotsClientListByResourceGroupResult contains the result from method SnapshotsClient.ListByResourceGroup.
type SnapshotsClientListByResourceGroupResult struct {
	SnapshotList
}

// SnapshotsClientListResponse contains the response from method SnapshotsClient.List.
type SnapshotsClientListResponse struct {
	SnapshotsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotsClientListResult contains the result from method SnapshotsClient.List.
type SnapshotsClientListResult struct {
	SnapshotList
}

// SnapshotsClientRevokeAccessPollerResponse contains the response from method SnapshotsClient.RevokeAccess.
type SnapshotsClientRevokeAccessPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SnapshotsClientRevokeAccessPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SnapshotsClientRevokeAccessPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsClientRevokeAccessResponse, error) {
	respType := SnapshotsClientRevokeAccessResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SnapshotsClientRevokeAccessPollerResponse from the provided client and resume token.
func (l *SnapshotsClientRevokeAccessPollerResponse) Resume(ctx context.Context, client *SnapshotsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SnapshotsClient.RevokeAccess", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SnapshotsClientRevokeAccessPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SnapshotsClientRevokeAccessResponse contains the response from method SnapshotsClient.RevokeAccess.
type SnapshotsClientRevokeAccessResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotsClientUpdatePollerResponse contains the response from method SnapshotsClient.Update.
type SnapshotsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SnapshotsClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SnapshotsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SnapshotsClientUpdateResponse, error) {
	respType := SnapshotsClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Snapshot)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a SnapshotsClientUpdatePollerResponse from the provided client and resume token.
func (l *SnapshotsClientUpdatePollerResponse) Resume(ctx context.Context, client *SnapshotsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SnapshotsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SnapshotsClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// SnapshotsClientUpdateResponse contains the response from method SnapshotsClient.Update.
type SnapshotsClientUpdateResponse struct {
	SnapshotsClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SnapshotsClientUpdateResult contains the result from method SnapshotsClient.Update.
type SnapshotsClientUpdateResult struct {
	Snapshot
}
