//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsingularity

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"net/http"
	"time"
)

// AccountClientCreateOrUpdatePollerResponse contains the response from method AccountClient.CreateOrUpdate.
type AccountClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AccountClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AccountClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AccountClientCreateOrUpdateResponse, error) {
	respType := AccountClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AccountResourceDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AccountClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *AccountClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *AccountClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AccountClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AccountClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AccountClientCreateOrUpdateResponse contains the response from method AccountClient.CreateOrUpdate.
type AccountClientCreateOrUpdateResponse struct {
	AccountClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountClientCreateOrUpdateResult contains the result from method AccountClient.CreateOrUpdate.
type AccountClientCreateOrUpdateResult struct {
	AccountResourceDescription
}

// AccountClientDeletePollerResponse contains the response from method AccountClient.Delete.
type AccountClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AccountClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AccountClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AccountClientDeleteResponse, error) {
	respType := AccountClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AccountClientDeletePollerResponse from the provided client and resume token.
func (l *AccountClientDeletePollerResponse) Resume(ctx context.Context, client *AccountClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AccountClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AccountClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AccountClientDeleteResponse contains the response from method AccountClient.Delete.
type AccountClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountClientGetResponse contains the response from method AccountClient.Get.
type AccountClientGetResponse struct {
	AccountClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountClientGetResult contains the result from method AccountClient.Get.
type AccountClientGetResult struct {
	AccountResourceDescription
}

// AccountClientListByResourceGroupResponse contains the response from method AccountClient.ListByResourceGroup.
type AccountClientListByResourceGroupResponse struct {
	AccountClientListByResourceGroupResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountClientListByResourceGroupResult contains the result from method AccountClient.ListByResourceGroup.
type AccountClientListByResourceGroupResult struct {
	AccountResourceDescriptionList
}

// AccountClientListBySubscriptionResponse contains the response from method AccountClient.ListBySubscription.
type AccountClientListBySubscriptionResponse struct {
	AccountClientListBySubscriptionResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountClientListBySubscriptionResult contains the result from method AccountClient.ListBySubscription.
type AccountClientListBySubscriptionResult struct {
	AccountResourceDescriptionList
}

// AccountClientUpdatePollerResponse contains the response from method AccountClient.Update.
type AccountClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AccountClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AccountClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AccountClientUpdateResponse, error) {
	respType := AccountClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AccountResourceDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AccountClientUpdatePollerResponse from the provided client and resume token.
func (l *AccountClientUpdatePollerResponse) Resume(ctx context.Context, client *AccountClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AccountClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AccountClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AccountClientUpdateResponse contains the response from method AccountClient.Update.
type AccountClientUpdateResponse struct {
	AccountClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountClientUpdateResult contains the result from method AccountClient.Update.
type AccountClientUpdateResult struct {
	AccountResourceDescription
}

// AccountQuotaPolicyClientCreateOrUpdatePollerResponse contains the response from method AccountQuotaPolicyClient.CreateOrUpdate.
type AccountQuotaPolicyClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AccountQuotaPolicyClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AccountQuotaPolicyClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AccountQuotaPolicyClientCreateOrUpdateResponse, error) {
	respType := AccountQuotaPolicyClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AccountQuotaPolicyResourceDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AccountQuotaPolicyClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *AccountQuotaPolicyClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *AccountQuotaPolicyClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AccountQuotaPolicyClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AccountQuotaPolicyClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AccountQuotaPolicyClientCreateOrUpdateResponse contains the response from method AccountQuotaPolicyClient.CreateOrUpdate.
type AccountQuotaPolicyClientCreateOrUpdateResponse struct {
	AccountQuotaPolicyClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountQuotaPolicyClientCreateOrUpdateResult contains the result from method AccountQuotaPolicyClient.CreateOrUpdate.
type AccountQuotaPolicyClientCreateOrUpdateResult struct {
	AccountQuotaPolicyResourceDescription
}

// AccountQuotaPolicyClientGetResponse contains the response from method AccountQuotaPolicyClient.Get.
type AccountQuotaPolicyClientGetResponse struct {
	AccountQuotaPolicyClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountQuotaPolicyClientGetResult contains the result from method AccountQuotaPolicyClient.Get.
type AccountQuotaPolicyClientGetResult struct {
	AccountQuotaPolicyResourceDescription
}

// AccountQuotaPolicyClientListByAccountResponse contains the response from method AccountQuotaPolicyClient.ListByAccount.
type AccountQuotaPolicyClientListByAccountResponse struct {
	AccountQuotaPolicyClientListByAccountResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountQuotaPolicyClientListByAccountResult contains the result from method AccountQuotaPolicyClient.ListByAccount.
type AccountQuotaPolicyClientListByAccountResult struct {
	AccountQuotaPolicyResourceDescriptionList
}

// AccountQuotaPolicyClientUpdatePollerResponse contains the response from method AccountQuotaPolicyClient.Update.
type AccountQuotaPolicyClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AccountQuotaPolicyClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AccountQuotaPolicyClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AccountQuotaPolicyClientUpdateResponse, error) {
	respType := AccountQuotaPolicyClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AccountQuotaPolicyResourceDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a AccountQuotaPolicyClientUpdatePollerResponse from the provided client and resume token.
func (l *AccountQuotaPolicyClientUpdatePollerResponse) Resume(ctx context.Context, client *AccountQuotaPolicyClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AccountQuotaPolicyClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AccountQuotaPolicyClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// AccountQuotaPolicyClientUpdateResponse contains the response from method AccountQuotaPolicyClient.Update.
type AccountQuotaPolicyClientUpdateResponse struct {
	AccountQuotaPolicyClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// AccountQuotaPolicyClientUpdateResult contains the result from method AccountQuotaPolicyClient.Update.
type AccountQuotaPolicyClientUpdateResult struct {
	AccountQuotaPolicyResourceDescription
}

// GroupPolicyClientCreateOrUpdatePollerResponse contains the response from method GroupPolicyClient.CreateOrUpdate.
type GroupPolicyClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GroupPolicyClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GroupPolicyClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GroupPolicyClientCreateOrUpdateResponse, error) {
	respType := GroupPolicyClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GroupPolicyResourceDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GroupPolicyClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *GroupPolicyClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *GroupPolicyClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GroupPolicyClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GroupPolicyClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GroupPolicyClientCreateOrUpdateResponse contains the response from method GroupPolicyClient.CreateOrUpdate.
type GroupPolicyClientCreateOrUpdateResponse struct {
	GroupPolicyClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GroupPolicyClientCreateOrUpdateResult contains the result from method GroupPolicyClient.CreateOrUpdate.
type GroupPolicyClientCreateOrUpdateResult struct {
	GroupPolicyResourceDescription
}

// GroupPolicyClientDeletePollerResponse contains the response from method GroupPolicyClient.Delete.
type GroupPolicyClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GroupPolicyClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GroupPolicyClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GroupPolicyClientDeleteResponse, error) {
	respType := GroupPolicyClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GroupPolicyClientDeletePollerResponse from the provided client and resume token.
func (l *GroupPolicyClientDeletePollerResponse) Resume(ctx context.Context, client *GroupPolicyClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GroupPolicyClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GroupPolicyClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GroupPolicyClientDeleteResponse contains the response from method GroupPolicyClient.Delete.
type GroupPolicyClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GroupPolicyClientGetResponse contains the response from method GroupPolicyClient.Get.
type GroupPolicyClientGetResponse struct {
	GroupPolicyClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GroupPolicyClientGetResult contains the result from method GroupPolicyClient.Get.
type GroupPolicyClientGetResult struct {
	GroupPolicyResourceDescription
}

// GroupPolicyClientListByAccountResponse contains the response from method GroupPolicyClient.ListByAccount.
type GroupPolicyClientListByAccountResponse struct {
	GroupPolicyClientListByAccountResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GroupPolicyClientListByAccountResult contains the result from method GroupPolicyClient.ListByAccount.
type GroupPolicyClientListByAccountResult struct {
	GroupPolicyResourceDescriptionList
}

// GroupPolicyClientUpdatePollerResponse contains the response from method GroupPolicyClient.Update.
type GroupPolicyClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GroupPolicyClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GroupPolicyClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GroupPolicyClientUpdateResponse, error) {
	respType := GroupPolicyClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.GroupPolicyResourceDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a GroupPolicyClientUpdatePollerResponse from the provided client and resume token.
func (l *GroupPolicyClientUpdatePollerResponse) Resume(ctx context.Context, client *GroupPolicyClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GroupPolicyClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GroupPolicyClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// GroupPolicyClientUpdateResponse contains the response from method GroupPolicyClient.Update.
type GroupPolicyClientUpdateResponse struct {
	GroupPolicyClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// GroupPolicyClientUpdateResult contains the result from method GroupPolicyClient.Update.
type GroupPolicyClientUpdateResult struct {
	GroupPolicyResourceDescription
}

// ImagesClientListResponse contains the response from method ImagesClient.List.
type ImagesClientListResponse struct {
	ImagesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ImagesClientListResult contains the result from method ImagesClient.List.
type ImagesClientListResult struct {
	AvailablePlatformImageDescriptionList
}

// InstanceTypeSeriesClientListInstanceTypeResponse contains the response from method InstanceTypeSeriesClient.ListInstanceType.
type InstanceTypeSeriesClientListInstanceTypeResponse struct {
	InstanceTypeSeriesClientListInstanceTypeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InstanceTypeSeriesClientListInstanceTypeResult contains the result from method InstanceTypeSeriesClient.ListInstanceType.
type InstanceTypeSeriesClientListInstanceTypeResult struct {
	AvailableInstanceTypeDescriptionList
}

// InstanceTypeSeriesClientListResponse contains the response from method InstanceTypeSeriesClient.List.
type InstanceTypeSeriesClientListResponse struct {
	InstanceTypeSeriesClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// InstanceTypeSeriesClientListResult contains the result from method InstanceTypeSeriesClient.List.
type InstanceTypeSeriesClientListResult struct {
	AvailableInstanceTypeSeriesDescriptionList
}

// JobClientApprovePollerResponse contains the response from method JobClient.Approve.
type JobClientApprovePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *JobClientApprovePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l JobClientApprovePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (JobClientApproveResponse, error) {
	respType := JobClientApproveResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a JobClientApprovePollerResponse from the provided client and resume token.
func (l *JobClientApprovePollerResponse) Resume(ctx context.Context, client *JobClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("JobClient.Approve", token, client.pl)
	if err != nil {
		return err
	}
	poller := &JobClientApprovePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// JobClientApproveResponse contains the response from method JobClient.Approve.
type JobClientApproveResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobClientCancelPollerResponse contains the response from method JobClient.Cancel.
type JobClientCancelPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *JobClientCancelPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l JobClientCancelPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (JobClientCancelResponse, error) {
	respType := JobClientCancelResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a JobClientCancelPollerResponse from the provided client and resume token.
func (l *JobClientCancelPollerResponse) Resume(ctx context.Context, client *JobClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("JobClient.Cancel", token, client.pl)
	if err != nil {
		return err
	}
	poller := &JobClientCancelPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// JobClientCancelResponse contains the response from method JobClient.Cancel.
type JobClientCancelResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobClientCreateOrUpdatePollerResponse contains the response from method JobClient.CreateOrUpdate.
type JobClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *JobClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l JobClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (JobClientCreateOrUpdateResponse, error) {
	respType := JobClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.JobResourceDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a JobClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *JobClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *JobClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("JobClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &JobClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// JobClientCreateOrUpdateResponse contains the response from method JobClient.CreateOrUpdate.
type JobClientCreateOrUpdateResponse struct {
	JobClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobClientCreateOrUpdateResult contains the result from method JobClient.CreateOrUpdate.
type JobClientCreateOrUpdateResult struct {
	JobResourceDescription
}

// JobClientCreateSasTokenPollerResponse contains the response from method JobClient.CreateSasToken.
type JobClientCreateSasTokenPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *JobClientCreateSasTokenPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l JobClientCreateSasTokenPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (JobClientCreateSasTokenResponse, error) {
	respType := JobClientCreateSasTokenResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.JobSasTokenDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a JobClientCreateSasTokenPollerResponse from the provided client and resume token.
func (l *JobClientCreateSasTokenPollerResponse) Resume(ctx context.Context, client *JobClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("JobClient.CreateSasToken", token, client.pl)
	if err != nil {
		return err
	}
	poller := &JobClientCreateSasTokenPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// JobClientCreateSasTokenResponse contains the response from method JobClient.CreateSasToken.
type JobClientCreateSasTokenResponse struct {
	JobClientCreateSasTokenResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobClientCreateSasTokenResult contains the result from method JobClient.CreateSasToken.
type JobClientCreateSasTokenResult struct {
	JobSasTokenDescription
}

// JobClientDeletePollerResponse contains the response from method JobClient.Delete.
type JobClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *JobClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l JobClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (JobClientDeleteResponse, error) {
	respType := JobClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a JobClientDeletePollerResponse from the provided client and resume token.
func (l *JobClientDeletePollerResponse) Resume(ctx context.Context, client *JobClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("JobClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &JobClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// JobClientDeleteResponse contains the response from method JobClient.Delete.
type JobClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobClientGetResponse contains the response from method JobClient.Get.
type JobClientGetResponse struct {
	JobClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobClientGetResult contains the result from method JobClient.Get.
type JobClientGetResult struct {
	JobResourceDescription
}

// JobClientListByAccountResponse contains the response from method JobClient.ListByAccount.
type JobClientListByAccountResponse struct {
	JobClientListByAccountResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobClientListByAccountResult contains the result from method JobClient.ListByAccount.
type JobClientListByAccountResult struct {
	JobResourceDescriptionList
}

// JobClientRemovePollerResponse contains the response from method JobClient.Remove.
type JobClientRemovePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *JobClientRemovePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l JobClientRemovePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (JobClientRemoveResponse, error) {
	respType := JobClientRemoveResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a JobClientRemovePollerResponse from the provided client and resume token.
func (l *JobClientRemovePollerResponse) Resume(ctx context.Context, client *JobClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("JobClient.Remove", token, client.pl)
	if err != nil {
		return err
	}
	poller := &JobClientRemovePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// JobClientRemoveResponse contains the response from method JobClient.Remove.
type JobClientRemoveResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobClientRenewKeyResponse contains the response from method JobClient.RenewKey.
type JobClientRenewKeyResponse struct {
	JobClientRenewKeyResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobClientRenewKeyResult contains the result from method JobClient.RenewKey.
type JobClientRenewKeyResult struct {
	JobSasTokenDescription
}

// JobClientResumePollerResponse contains the response from method JobClient.Resume.
type JobClientResumePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *JobClientResumePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l JobClientResumePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (JobClientResumeResponse, error) {
	respType := JobClientResumeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a JobClientResumePollerResponse from the provided client and resume token.
func (l *JobClientResumePollerResponse) Resume(ctx context.Context, client *JobClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("JobClient.Resume", token, client.pl)
	if err != nil {
		return err
	}
	poller := &JobClientResumePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// JobClientResumeResponse contains the response from method JobClient.Resume.
type JobClientResumeResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobClientSuspendPollerResponse contains the response from method JobClient.Suspend.
type JobClientSuspendPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *JobClientSuspendPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l JobClientSuspendPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (JobClientSuspendResponse, error) {
	respType := JobClientSuspendResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a JobClientSuspendPollerResponse from the provided client and resume token.
func (l *JobClientSuspendPollerResponse) Resume(ctx context.Context, client *JobClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("JobClient.Suspend", token, client.pl)
	if err != nil {
		return err
	}
	poller := &JobClientSuspendPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// JobClientSuspendResponse contains the response from method JobClient.Suspend.
type JobClientSuspendResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobClientUpdatePollerResponse contains the response from method JobClient.Update.
type JobClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *JobClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l JobClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (JobClientUpdateResponse, error) {
	respType := JobClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.JobResourceDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a JobClientUpdatePollerResponse from the provided client and resume token.
func (l *JobClientUpdatePollerResponse) Resume(ctx context.Context, client *JobClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("JobClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &JobClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// JobClientUpdateResponse contains the response from method JobClient.Update.
type JobClientUpdateResponse struct {
	JobClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// JobClientUpdateResult contains the result from method JobClient.Update.
type JobClientUpdateResult struct {
	JobResourceDescription
}

// ModelClientCreateOrUpdatePollerResponse contains the response from method ModelClient.CreateOrUpdate.
type ModelClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ModelClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ModelClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ModelClientCreateOrUpdateResponse, error) {
	respType := ModelClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ModelResourceDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ModelClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ModelClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ModelClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ModelClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ModelClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ModelClientCreateOrUpdateResponse contains the response from method ModelClient.CreateOrUpdate.
type ModelClientCreateOrUpdateResponse struct {
	ModelClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ModelClientCreateOrUpdateResult contains the result from method ModelClient.CreateOrUpdate.
type ModelClientCreateOrUpdateResult struct {
	ModelResourceDescription
}

// ModelClientDeletePollerResponse contains the response from method ModelClient.Delete.
type ModelClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ModelClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ModelClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ModelClientDeleteResponse, error) {
	respType := ModelClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ModelClientDeletePollerResponse from the provided client and resume token.
func (l *ModelClientDeletePollerResponse) Resume(ctx context.Context, client *ModelClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ModelClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ModelClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ModelClientDeleteResponse contains the response from method ModelClient.Delete.
type ModelClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ModelClientGetResponse contains the response from method ModelClient.Get.
type ModelClientGetResponse struct {
	ModelClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ModelClientGetResult contains the result from method ModelClient.Get.
type ModelClientGetResult struct {
	ModelResourceDescription
}

// ModelClientListByAccountResponse contains the response from method ModelClient.ListByAccount.
type ModelClientListByAccountResponse struct {
	ModelClientListByAccountResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ModelClientListByAccountResult contains the result from method ModelClient.ListByAccount.
type ModelClientListByAccountResult struct {
	ModelResourceDescriptionList
}

// ModelClientUpdatePollerResponse contains the response from method ModelClient.Update.
type ModelClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ModelClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ModelClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ModelClientUpdateResponse, error) {
	respType := ModelClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ModelResourceDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ModelClientUpdatePollerResponse from the provided client and resume token.
func (l *ModelClientUpdatePollerResponse) Resume(ctx context.Context, client *ModelClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ModelClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ModelClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ModelClientUpdateResponse contains the response from method ModelClient.Update.
type ModelClientUpdateResponse struct {
	ModelClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// ModelClientUpdateResult contains the result from method ModelClient.Update.
type ModelClientUpdateResult struct {
	ModelResourceDescription
}

// ModelClientValidatePollerResponse contains the response from method ModelClient.Validate.
type ModelClientValidatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ModelClientValidatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ModelClientValidatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ModelClientValidateResponse, error) {
	respType := ModelClientValidateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a ModelClientValidatePollerResponse from the provided client and resume token.
func (l *ModelClientValidatePollerResponse) Resume(ctx context.Context, client *ModelClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ModelClient.Validate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ModelClientValidatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// ModelClientValidateResponse contains the response from method ModelClient.Validate.
type ModelClientValidateResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkClientCreateOrUpdatePollerResponse contains the response from method NetworkClient.CreateOrUpdate.
type NetworkClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkClientCreateOrUpdateResponse, error) {
	respType := NetworkClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NetworkResourceDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *NetworkClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *NetworkClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &NetworkClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkClientCreateOrUpdateResponse contains the response from method NetworkClient.CreateOrUpdate.
type NetworkClientCreateOrUpdateResponse struct {
	NetworkClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkClientCreateOrUpdateResult contains the result from method NetworkClient.CreateOrUpdate.
type NetworkClientCreateOrUpdateResult struct {
	NetworkResourceDescription
}

// NetworkClientDeletePollerResponse contains the response from method NetworkClient.Delete.
type NetworkClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkClientDeleteResponse, error) {
	respType := NetworkClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkClientDeletePollerResponse from the provided client and resume token.
func (l *NetworkClientDeletePollerResponse) Resume(ctx context.Context, client *NetworkClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &NetworkClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkClientDeleteResponse contains the response from method NetworkClient.Delete.
type NetworkClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkClientGetResponse contains the response from method NetworkClient.Get.
type NetworkClientGetResponse struct {
	NetworkClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkClientGetResult contains the result from method NetworkClient.Get.
type NetworkClientGetResult struct {
	NetworkResourceDescription
}

// NetworkClientListByAccountResponse contains the response from method NetworkClient.ListByAccount.
type NetworkClientListByAccountResponse struct {
	NetworkClientListByAccountResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkClientListByAccountResult contains the result from method NetworkClient.ListByAccount.
type NetworkClientListByAccountResult struct {
	NetworkResourceDescriptionList
}

// NetworkClientUpdatePollerResponse contains the response from method NetworkClient.Update.
type NetworkClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *NetworkClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l NetworkClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (NetworkClientUpdateResponse, error) {
	respType := NetworkClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.NetworkResourceDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a NetworkClientUpdatePollerResponse from the provided client and resume token.
func (l *NetworkClientUpdatePollerResponse) Resume(ctx context.Context, client *NetworkClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("NetworkClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &NetworkClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// NetworkClientUpdateResponse contains the response from method NetworkClient.Update.
type NetworkClientUpdateResponse struct {
	NetworkClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// NetworkClientUpdateResult contains the result from method NetworkClient.Update.
type NetworkClientUpdateResult struct {
	NetworkResourceDescription
}

// OperationsClientListResponse contains the response from method OperationsClient.List.
type OperationsClientListResponse struct {
	OperationsClientListResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// OperationsClientListResult contains the result from method OperationsClient.List.
type OperationsClientListResult struct {
	OperationListResult
}

// StorageCacheClientCreateOrUpdatePollerResponse contains the response from method StorageCacheClient.CreateOrUpdate.
type StorageCacheClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *StorageCacheClientCreateOrUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l StorageCacheClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (StorageCacheClientCreateOrUpdateResponse, error) {
	respType := StorageCacheClientCreateOrUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.StorageCacheResourceDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a StorageCacheClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *StorageCacheClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *StorageCacheClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("StorageCacheClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &StorageCacheClientCreateOrUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// StorageCacheClientCreateOrUpdateResponse contains the response from method StorageCacheClient.CreateOrUpdate.
type StorageCacheClientCreateOrUpdateResponse struct {
	StorageCacheClientCreateOrUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageCacheClientCreateOrUpdateResult contains the result from method StorageCacheClient.CreateOrUpdate.
type StorageCacheClientCreateOrUpdateResult struct {
	StorageCacheResourceDescription
}

// StorageCacheClientDeletePollerResponse contains the response from method StorageCacheClient.Delete.
type StorageCacheClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *StorageCacheClientDeletePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l StorageCacheClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (StorageCacheClientDeleteResponse, error) {
	respType := StorageCacheClientDeleteResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a StorageCacheClientDeletePollerResponse from the provided client and resume token.
func (l *StorageCacheClientDeletePollerResponse) Resume(ctx context.Context, client *StorageCacheClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("StorageCacheClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &StorageCacheClientDeletePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// StorageCacheClientDeleteResponse contains the response from method StorageCacheClient.Delete.
type StorageCacheClientDeleteResponse struct {
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageCacheClientGetDiagnosticsResponse contains the response from method StorageCacheClient.GetDiagnostics.
type StorageCacheClientGetDiagnosticsResponse struct {
	StorageCacheClientGetDiagnosticsResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageCacheClientGetDiagnosticsResult contains the result from method StorageCacheClient.GetDiagnostics.
type StorageCacheClientGetDiagnosticsResult struct {
	StorageCacheResourceDiagnosticsInfo
}

// StorageCacheClientGetResponse contains the response from method StorageCacheClient.Get.
type StorageCacheClientGetResponse struct {
	StorageCacheClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageCacheClientGetResult contains the result from method StorageCacheClient.Get.
type StorageCacheClientGetResult struct {
	StorageCacheResourceDescription
}

// StorageCacheClientListByAccountResponse contains the response from method StorageCacheClient.ListByAccount.
type StorageCacheClientListByAccountResponse struct {
	StorageCacheClientListByAccountResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageCacheClientListByAccountResult contains the result from method StorageCacheClient.ListByAccount.
type StorageCacheClientListByAccountResult struct {
	StorageCacheResourceDescriptionList
}

// StorageCacheClientResumePollerResponse contains the response from method StorageCacheClient.Resume.
type StorageCacheClientResumePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *StorageCacheClientResumePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l StorageCacheClientResumePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (StorageCacheClientResumeResponse, error) {
	respType := StorageCacheClientResumeResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.StorageCacheResourceDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a StorageCacheClientResumePollerResponse from the provided client and resume token.
func (l *StorageCacheClientResumePollerResponse) Resume(ctx context.Context, client *StorageCacheClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("StorageCacheClient.Resume", token, client.pl)
	if err != nil {
		return err
	}
	poller := &StorageCacheClientResumePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// StorageCacheClientResumeResponse contains the response from method StorageCacheClient.Resume.
type StorageCacheClientResumeResponse struct {
	StorageCacheClientResumeResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageCacheClientResumeResult contains the result from method StorageCacheClient.Resume.
type StorageCacheClientResumeResult struct {
	StorageCacheResourceDescription
}

// StorageCacheClientSuspendPollerResponse contains the response from method StorageCacheClient.Suspend.
type StorageCacheClientSuspendPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *StorageCacheClientSuspendPoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l StorageCacheClientSuspendPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (StorageCacheClientSuspendResponse, error) {
	respType := StorageCacheClientSuspendResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.StorageCacheResourceDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a StorageCacheClientSuspendPollerResponse from the provided client and resume token.
func (l *StorageCacheClientSuspendPollerResponse) Resume(ctx context.Context, client *StorageCacheClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("StorageCacheClient.Suspend", token, client.pl)
	if err != nil {
		return err
	}
	poller := &StorageCacheClientSuspendPoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// StorageCacheClientSuspendResponse contains the response from method StorageCacheClient.Suspend.
type StorageCacheClientSuspendResponse struct {
	StorageCacheClientSuspendResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageCacheClientSuspendResult contains the result from method StorageCacheClient.Suspend.
type StorageCacheClientSuspendResult struct {
	StorageCacheResourceDescription
}

// StorageCacheClientUpdatePollerResponse contains the response from method StorageCacheClient.Update.
type StorageCacheClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *StorageCacheClientUpdatePoller

	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l StorageCacheClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (StorageCacheClientUpdateResponse, error) {
	respType := StorageCacheClientUpdateResponse{}
	resp, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.StorageCacheResourceDescription)
	if err != nil {
		return respType, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// Resume rehydrates a StorageCacheClientUpdatePollerResponse from the provided client and resume token.
func (l *StorageCacheClientUpdatePollerResponse) Resume(ctx context.Context, client *StorageCacheClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("StorageCacheClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &StorageCacheClientUpdatePoller{
		pt: pt,
	}
	resp, err := poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	l.RawResponse = resp
	return nil
}

// StorageCacheClientUpdateResponse contains the response from method StorageCacheClient.Update.
type StorageCacheClientUpdateResponse struct {
	StorageCacheClientUpdateResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// StorageCacheClientUpdateResult contains the result from method StorageCacheClient.Update.
type StorageCacheClientUpdateResult struct {
	StorageCacheResourceDescription
}

// SubscriptionQuotaClientGetResponse contains the response from method SubscriptionQuotaClient.Get.
type SubscriptionQuotaClientGetResponse struct {
	SubscriptionQuotaClientGetResult
	// RawResponse contains the underlying HTTP response.
	RawResponse *http.Response
}

// SubscriptionQuotaClientGetResult contains the result from method SubscriptionQuotaClient.Get.
type SubscriptionQuotaClientGetResult struct {
	InstanceTypeSeriesQuotaList
}
