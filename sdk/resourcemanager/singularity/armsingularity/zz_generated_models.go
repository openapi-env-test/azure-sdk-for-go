//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsingularity

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
	"time"
)

// AccountClientBeginCreateOrUpdateOptions contains the optional parameters for the AccountClient.BeginCreateOrUpdate method.
type AccountClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// AccountClientBeginDeleteOptions contains the optional parameters for the AccountClient.BeginDelete method.
type AccountClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// AccountClientBeginUpdateOptions contains the optional parameters for the AccountClient.BeginUpdate method.
type AccountClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// AccountClientGetOptions contains the optional parameters for the AccountClient.Get method.
type AccountClientGetOptions struct {
	// placeholder for future optional parameters
}

// AccountClientListByResourceGroupOptions contains the optional parameters for the AccountClient.ListByResourceGroup method.
type AccountClientListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// AccountClientListBySubscriptionOptions contains the optional parameters for the AccountClient.ListBySubscription method.
type AccountClientListBySubscriptionOptions struct {
	// placeholder for future optional parameters
}

// AccountLocation - Describes the properties of an Account location resource.
type AccountLocation struct {
	// REQUIRED; The failover priority of the location. Failover priority values must be unique for each of the locations associated
	// with the account.
	FailoverPriority *int32 `json:"failoverPriority,omitempty"`

	// REQUIRED; Name of the account location.
	Name *string `json:"name,omitempty"`

	// READ-ONLY; Indicates whether or not this location has AvailabilityZone enabled.
	IsZoneRedundant *bool `json:"isZoneRedundant,omitempty" azure:"ro"`
}

// AccountPatchProperties - Describes all properties which can be updated for a Singularity account resource.
type AccountPatchProperties struct {
	// User-friendly description of an account.
	Description *string `json:"description,omitempty"`

	// Describes the properties of idle resources handling policy.
	IdleResourcesHandlingPolicy *IdleResourcesHandlingPolicy `json:"idleResourcesHandlingPolicy,omitempty"`

	// The collection of account locations.
	Locations []*AccountLocation `json:"locations,omitempty"`

	// Describes the network settings for the account.
	NetworkSettings *NetworkSettings `json:"networkSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountPatchProperties.
func (a AccountPatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", a.Description)
	populate(objectMap, "idleResourcesHandlingPolicy", a.IdleResourcesHandlingPolicy)
	populate(objectMap, "locations", a.Locations)
	populate(objectMap, "networkSettings", a.NetworkSettings)
	return json.Marshal(objectMap)
}

// AccountProperties - Describes the properties of an Account resource.
type AccountProperties struct {
	// User-friendly description of an account.
	Description *string `json:"description,omitempty"`

	// Describes the properties of idle resources handling policy.
	IdleResourcesHandlingPolicy *IdleResourcesHandlingPolicy `json:"idleResourcesHandlingPolicy,omitempty"`

	// The collection of account locations.
	Locations []*AccountLocation `json:"locations,omitempty"`

	// Describes the network settings for the account.
	NetworkSettings   *NetworkSettings   `json:"networkSettings,omitempty"`
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty"`
	Status            *AccountStatus     `json:"status,omitempty"`

	// READ-ONLY; Gives additional information about the current status of an account.
	StatusDetails *string `json:"statusDetails,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountProperties.
func (a AccountProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", a.Description)
	populate(objectMap, "idleResourcesHandlingPolicy", a.IdleResourcesHandlingPolicy)
	populate(objectMap, "locations", a.Locations)
	populate(objectMap, "networkSettings", a.NetworkSettings)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "status", a.Status)
	populate(objectMap, "statusDetails", a.StatusDetails)
	return json.Marshal(objectMap)
}

// AccountQuotaPolicyClientBeginCreateOrUpdateOptions contains the optional parameters for the AccountQuotaPolicyClient.BeginCreateOrUpdate
// method.
type AccountQuotaPolicyClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// AccountQuotaPolicyClientBeginUpdateOptions contains the optional parameters for the AccountQuotaPolicyClient.BeginUpdate
// method.
type AccountQuotaPolicyClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// AccountQuotaPolicyClientGetOptions contains the optional parameters for the AccountQuotaPolicyClient.Get method.
type AccountQuotaPolicyClientGetOptions struct {
	// placeholder for future optional parameters
}

// AccountQuotaPolicyClientListByAccountOptions contains the optional parameters for the AccountQuotaPolicyClient.ListByAccount
// method.
type AccountQuotaPolicyClientListByAccountOptions struct {
	ContinuationToken *string
}

// AccountQuotaPolicyPatchProperties - Describes all properties which can be updated for a Singularity account quota policy
// resource.
type AccountQuotaPolicyPatchProperties struct {
	// User-friendly description of an AccountQuotaPolicy.
	Description *string `json:"description,omitempty"`

	// A list of quota policy per instance type series.
	Quotas []*InstanceTypeSeriesQuota `json:"quotas,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountQuotaPolicyPatchProperties.
func (a AccountQuotaPolicyPatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", a.Description)
	populate(objectMap, "quotas", a.Quotas)
	return json.Marshal(objectMap)
}

// AccountQuotaPolicyProperties - Describes properties of AccountQuotaPolicy resource.
type AccountQuotaPolicyProperties struct {
	// User-friendly description of an AccountQuotaPolicy.
	Description       *string            `json:"description,omitempty"`
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty"`

	// A list of quota policy per instance type series.
	Quotas []*InstanceTypeSeriesQuota `json:"quotas,omitempty"`
	Status *PolicyStatus              `json:"status,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountQuotaPolicyProperties.
func (a AccountQuotaPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", a.Description)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "quotas", a.Quotas)
	populate(objectMap, "status", a.Status)
	return json.Marshal(objectMap)
}

// AccountQuotaPolicyResourceDescription - Describes an account quota policy resource in Singularity.
type AccountQuotaPolicyResourceDescription struct {
	// REQUIRED
	Properties *AccountQuotaPolicyResourceDescriptionProperties `json:"properties,omitempty"`
	SystemData *ResourceSystemData                              `json:"systemData,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier for the resource. For example, /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. For example, Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountQuotaPolicyResourceDescription.
func (a AccountQuotaPolicyResourceDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// AccountQuotaPolicyResourceDescriptionList - A pageable list of AccountQuotaPolicy resources.
type AccountQuotaPolicyResourceDescriptionList struct {
	// READ-ONLY; URI to fetch the next page of the list.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; One page of the list.
	Value []*AccountQuotaPolicyResourceDescription `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountQuotaPolicyResourceDescriptionList.
func (a AccountQuotaPolicyResourceDescriptionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

type AccountQuotaPolicyResourceDescriptionProperties struct {
	// User-friendly description of an AccountQuotaPolicy.
	Description       *string            `json:"description,omitempty"`
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty"`

	// A list of quota policy per instance type series.
	Quotas []*InstanceTypeSeriesQuota `json:"quotas,omitempty"`
	Status *PolicyStatus              `json:"status,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountQuotaPolicyResourceDescriptionProperties.
func (a AccountQuotaPolicyResourceDescriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", a.Description)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "quotas", a.Quotas)
	populate(objectMap, "status", a.Status)
	return json.Marshal(objectMap)
}

// AccountQuotaPolicyResourcePatchDescription - Describes all properties which can be updated for a Singularity account quota
// policy resource.
type AccountQuotaPolicyResourcePatchDescription struct {
	// REQUIRED
	Properties *AccountQuotaPolicyResourcePatchDescriptionProperties `json:"properties,omitempty"`
	SystemData *ResourceSystemData                                   `json:"systemData,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier for the resource. For example, /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. For example, Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountQuotaPolicyResourcePatchDescription.
func (a AccountQuotaPolicyResourcePatchDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

type AccountQuotaPolicyResourcePatchDescriptionProperties struct {
	// User-friendly description of an AccountQuotaPolicy.
	Description *string `json:"description,omitempty"`

	// A list of quota policy per instance type series.
	Quotas []*InstanceTypeSeriesQuota `json:"quotas,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountQuotaPolicyResourcePatchDescriptionProperties.
func (a AccountQuotaPolicyResourcePatchDescriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", a.Description)
	populate(objectMap, "quotas", a.Quotas)
	return json.Marshal(objectMap)
}

// AccountResourceDescription - Describes an account resource in Singularity.
type AccountResourceDescription struct {
	// REQUIRED; The geo-location where the resource lives.
	Location   *string                               `json:"location,omitempty"`
	Properties *AccountResourceDescriptionProperties `json:"properties,omitempty"`
	SystemData *ResourceSystemData                   `json:"systemData,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier for the resource. For example, /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. For example, Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountResourceDescription.
func (a AccountResourceDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// AccountResourceDescriptionList - A pageable list of Account resources.
type AccountResourceDescriptionList struct {
	// READ-ONLY; URI to fetch the next page of the list.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; One page of the list.
	Value []*AccountResourceDescription `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountResourceDescriptionList.
func (a AccountResourceDescriptionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

type AccountResourceDescriptionProperties struct {
	// User-friendly description of an account.
	Description *string `json:"description,omitempty"`

	// Describes the properties of idle resources handling policy.
	IdleResourcesHandlingPolicy *IdleResourcesHandlingPolicy `json:"idleResourcesHandlingPolicy,omitempty"`

	// The collection of account locations.
	Locations []*AccountLocation `json:"locations,omitempty"`

	// Describes the network settings for the account.
	NetworkSettings   *NetworkSettings   `json:"networkSettings,omitempty"`
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty"`
	Status            *AccountStatus     `json:"status,omitempty"`

	// READ-ONLY; Gives additional information about the current status of an account.
	StatusDetails *string `json:"statusDetails,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountResourceDescriptionProperties.
func (a AccountResourceDescriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", a.Description)
	populate(objectMap, "idleResourcesHandlingPolicy", a.IdleResourcesHandlingPolicy)
	populate(objectMap, "locations", a.Locations)
	populate(objectMap, "networkSettings", a.NetworkSettings)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "status", a.Status)
	populate(objectMap, "statusDetails", a.StatusDetails)
	return json.Marshal(objectMap)
}

// AccountResourcePatchDescription - Describes all properties which can be updated for a Singularity account resource.
type AccountResourcePatchDescription struct {
	// REQUIRED
	Properties *AccountResourcePatchDescriptionProperties `json:"properties,omitempty"`
	SystemData *ResourceSystemData                        `json:"systemData,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier for the resource. For example, /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. For example, Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountResourcePatchDescription.
func (a AccountResourcePatchDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "systemData", a.SystemData)
	populate(objectMap, "tags", a.Tags)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

type AccountResourcePatchDescriptionProperties struct {
	// User-friendly description of an account.
	Description *string `json:"description,omitempty"`

	// Describes the properties of idle resources handling policy.
	IdleResourcesHandlingPolicy *IdleResourcesHandlingPolicy `json:"idleResourcesHandlingPolicy,omitempty"`

	// The collection of account locations.
	Locations []*AccountLocation `json:"locations,omitempty"`

	// Describes the network settings for the account.
	NetworkSettings *NetworkSettings `json:"networkSettings,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccountResourcePatchDescriptionProperties.
func (a AccountResourcePatchDescriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", a.Description)
	populate(objectMap, "idleResourcesHandlingPolicy", a.IdleResourcesHandlingPolicy)
	populate(objectMap, "locations", a.Locations)
	populate(objectMap, "networkSettings", a.NetworkSettings)
	return json.Marshal(objectMap)
}

// AdlsFuseMountOptions - Describes options to use when mounting a storage cache container backed by ADLS Gen1 through FUSE.
type AdlsFuseMountOptions struct {
	// REQUIRED
	Kind *MountOptionsKind `json:"kind,omitempty"`
}

// GetAdlsMountOptionsBase implements the AdlsMountOptionsBaseClassification interface for type AdlsFuseMountOptions.
func (a *AdlsFuseMountOptions) GetAdlsMountOptionsBase() *AdlsMountOptionsBase {
	return &AdlsMountOptionsBase{
		Kind: a.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AdlsFuseMountOptions.
func (a AdlsFuseMountOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = MountOptionsKindFuse
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AdlsFuseMountOptions.
func (a *AdlsFuseMountOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AdlsInterceptionMountOptions - Describes options to use when accessing a storage cache container backed by ADLS Gen1 through
// file system interception.
type AdlsInterceptionMountOptions struct {
	// REQUIRED
	Kind *MountOptionsKind `json:"kind,omitempty"`
}

// GetAdlsMountOptionsBase implements the AdlsMountOptionsBaseClassification interface for type AdlsInterceptionMountOptions.
func (a *AdlsInterceptionMountOptions) GetAdlsMountOptionsBase() *AdlsMountOptionsBase {
	return &AdlsMountOptionsBase{
		Kind: a.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AdlsInterceptionMountOptions.
func (a AdlsInterceptionMountOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = MountOptionsKindInterception
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AdlsInterceptionMountOptions.
func (a *AdlsInterceptionMountOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AdlsMountOptionsBaseClassification provides polymorphic access to related types.
// Call the interface's GetAdlsMountOptionsBase() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AdlsFuseMountOptions, *AdlsInterceptionMountOptions, *AdlsMountOptionsBase
type AdlsMountOptionsBaseClassification interface {
	// GetAdlsMountOptionsBase returns the AdlsMountOptionsBase content of the underlying type.
	GetAdlsMountOptionsBase() *AdlsMountOptionsBase
}

// AdlsMountOptionsBase - Describes options to use when mounting a storage cache container backed by ADLS Gen1.
type AdlsMountOptionsBase struct {
	// REQUIRED
	Kind *MountOptionsKind `json:"kind,omitempty"`
}

// GetAdlsMountOptionsBase implements the AdlsMountOptionsBaseClassification interface for type AdlsMountOptionsBase.
func (a *AdlsMountOptionsBase) GetAdlsMountOptionsBase() *AdlsMountOptionsBase { return a }

// AdlsStorageCacheProperties - Describes the properties of a storage cache resource backed by ADLS Gen 1.
type AdlsStorageCacheProperties struct {
	// REQUIRED; Service principal client (application) ID
	ClientID *string `json:"clientId,omitempty"`

	// REQUIRED; Service principal client secret
	ClientSecret *string `json:"clientSecret,omitempty"`

	// REQUIRED
	Kind *StorageCacheKind `json:"kind,omitempty"`

	// REQUIRED; ADLS path (e.g. adl://.azuredatalakestore.net/)
	Path *string `json:"path,omitempty"`

	// REQUIRED; Service principal tenant ID
	TenantID *string `json:"tenantId,omitempty"`

	// Description of the storage cache resource.
	Description *string `json:"description,omitempty"`

	// Describes options to use when mounting a storage cache container backed by ADLS Gen1.
	MountOptions      AdlsMountOptionsBaseClassification `json:"mountOptions,omitempty"`
	ProvisioningState *ProvisioningState                 `json:"provisioningState,omitempty"`

	// Optional region for managed storage resources (if any).
	Region *string             `json:"region,omitempty"`
	Status *StorageCacheStatus `json:"status,omitempty"`

	// READ-ONLY; Default mount path that will be used within a job or model if none is specified.
	DefaultMountPath *string `json:"defaultMountPath,omitempty" azure:"ro"`
}

// GetStorageCachePropertiesBase implements the StorageCachePropertiesBaseClassification interface for type AdlsStorageCacheProperties.
func (a *AdlsStorageCacheProperties) GetStorageCachePropertiesBase() *StorageCachePropertiesBase {
	return &StorageCachePropertiesBase{
		Kind:              a.Kind,
		Description:       a.Description,
		Region:            a.Region,
		ProvisioningState: a.ProvisioningState,
		Status:            a.Status,
		DefaultMountPath:  a.DefaultMountPath,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AdlsStorageCacheProperties.
func (a AdlsStorageCacheProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientId", a.ClientID)
	populate(objectMap, "clientSecret", a.ClientSecret)
	populate(objectMap, "defaultMountPath", a.DefaultMountPath)
	populate(objectMap, "description", a.Description)
	objectMap["kind"] = StorageCacheKindADLS
	populate(objectMap, "mountOptions", a.MountOptions)
	populate(objectMap, "path", a.Path)
	populate(objectMap, "provisioningState", a.ProvisioningState)
	populate(objectMap, "region", a.Region)
	populate(objectMap, "status", a.Status)
	populate(objectMap, "tenantId", a.TenantID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AdlsStorageCacheProperties.
func (a *AdlsStorageCacheProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
			err = unpopulate(val, &a.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
			err = unpopulate(val, &a.ClientSecret)
			delete(rawMsg, key)
		case "defaultMountPath":
			err = unpopulate(val, &a.DefaultMountPath)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &a.Description)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &a.Kind)
			delete(rawMsg, key)
		case "mountOptions":
			a.MountOptions, err = unmarshalAdlsMountOptionsBaseClassification(val)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, &a.Path)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &a.ProvisioningState)
			delete(rawMsg, key)
		case "region":
			err = unpopulate(val, &a.Region)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &a.Status)
			delete(rawMsg, key)
		case "tenantId":
			err = unpopulate(val, &a.TenantID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AvailableInstanceTypeDescription - Instance type available in the location.
type AvailableInstanceTypeDescription struct {
	// READ-ONLY; Description for the instance type.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; Name for the instance type.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Quota count for the instance type.
	QuotaCount *int32 `json:"quotaCount,omitempty" azure:"ro"`
}

// AvailableInstanceTypeDescriptionList - A pageable list of available instance types.
type AvailableInstanceTypeDescriptionList struct {
	// READ-ONLY; URI to fetch the next page of the list.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; One page of the list.
	Value []*AvailableInstanceTypeDescription `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AvailableInstanceTypeDescriptionList.
func (a AvailableInstanceTypeDescriptionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AvailableInstanceTypeSeriesDescription - Instance type series available in the location.
type AvailableInstanceTypeSeriesDescription struct {
	// READ-ONLY; Unique identifier for the instance type series.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Descriptive name for the instance type series.
	Name *string `json:"name,omitempty" azure:"ro"`
}

// AvailableInstanceTypeSeriesDescriptionList - A pageable list of available instance type series.
type AvailableInstanceTypeSeriesDescriptionList struct {
	// READ-ONLY; URI to fetch the next page of the list.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; One page of the list.
	Value []*AvailableInstanceTypeSeriesDescription `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AvailableInstanceTypeSeriesDescriptionList.
func (a AvailableInstanceTypeSeriesDescriptionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AvailableOperationDisplay - An operation available at the listed Azure resource provider.
type AvailableOperationDisplay struct {
	// READ-ONLY; Description of the available operation.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; Name of the available operation.
	Operation *string `json:"operation,omitempty" azure:"ro"`

	// READ-ONLY; Name of the operation provider.
	Provider *string `json:"provider,omitempty" azure:"ro"`

	// READ-ONLY; Name of the resource on which the operation is available.
	Resource *string `json:"resource,omitempty" azure:"ro"`
}

// AvailablePlatformImageDescription - Platform supported container image types available.
type AvailablePlatformImageDescription struct {
	// READ-ONLY; Description of the container image.
	Description *string `json:"description,omitempty" azure:"ro"`

	// READ-ONLY; Fully qualifed Id for the container image.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Image names
	Names []*string `json:"names,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AvailablePlatformImageDescription.
func (a AvailablePlatformImageDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", a.Description)
	populate(objectMap, "id", a.ID)
	populate(objectMap, "names", a.Names)
	return json.Marshal(objectMap)
}

// AvailablePlatformImageDescriptionList - A pageable list of available images.
type AvailablePlatformImageDescriptionList struct {
	// READ-ONLY; URI to fetch the next page of the list.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; One page of the list.
	Value []*AvailablePlatformImageDescription `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type AvailablePlatformImageDescriptionList.
func (a AvailablePlatformImageDescriptionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// BlobFuseMountOptions - Describes options to use when mounting a storage cache container backed by Azure blob storage through
// FUSE.
type BlobFuseMountOptions struct {
	// REQUIRED
	Kind *MountOptionsKind `json:"kind,omitempty"`

	// --file-cache-timeout-in-seconds option as described at https://github.com/Azure/azure-storage-fuse
	FileCacheTimeoutSeconds *int32 `json:"fileCacheTimeoutSeconds,omitempty"`

	// --invalidate-on-sync option as described at https://github.com/Azure/azure-storage-fuse
	InvalidateOnSync *bool `json:"invalidateOnSync,omitempty"`

	// --max-concurrency option as described at https://github.com/Azure/azure-storage-fuse
	MaxConcurrency *int32 `json:"maxConcurrency,omitempty"`

	// --streaming option as described at https://github.com/Azure/azure-storage-fuse
	Streaming *bool `json:"streaming,omitempty"`

	// --block-size-mb option as described at https://github.com/Azure/azure-storage-fuse
	StreamingBlockSizeMiB *int32 `json:"streamingBlockSizeMiB,omitempty"`

	// --stream-cache-mb option as described at https://github.com/Azure/azure-storage-fuse
	StreamingCacheLimitMiB *int32 `json:"streamingCacheLimitMiB,omitempty"`

	// --max-blocks-per-file option as described at https://github.com/Azure/azure-storage-fuse
	StreamingMaxBlocksPerFile *int32 `json:"streamingMaxBlocksPerFile,omitempty"`
}

// GetBlobMountOptionsBase implements the BlobMountOptionsBaseClassification interface for type BlobFuseMountOptions.
func (b *BlobFuseMountOptions) GetBlobMountOptionsBase() *BlobMountOptionsBase {
	return &BlobMountOptionsBase{
		Kind: b.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BlobFuseMountOptions.
func (b BlobFuseMountOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fileCacheTimeoutSeconds", b.FileCacheTimeoutSeconds)
	populate(objectMap, "invalidateOnSync", b.InvalidateOnSync)
	objectMap["kind"] = MountOptionsKindFuse
	populate(objectMap, "maxConcurrency", b.MaxConcurrency)
	populate(objectMap, "streaming", b.Streaming)
	populate(objectMap, "streamingBlockSizeMiB", b.StreamingBlockSizeMiB)
	populate(objectMap, "streamingCacheLimitMiB", b.StreamingCacheLimitMiB)
	populate(objectMap, "streamingMaxBlocksPerFile", b.StreamingMaxBlocksPerFile)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobFuseMountOptions.
func (b *BlobFuseMountOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "fileCacheTimeoutSeconds":
			err = unpopulate(val, &b.FileCacheTimeoutSeconds)
			delete(rawMsg, key)
		case "invalidateOnSync":
			err = unpopulate(val, &b.InvalidateOnSync)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &b.Kind)
			delete(rawMsg, key)
		case "maxConcurrency":
			err = unpopulate(val, &b.MaxConcurrency)
			delete(rawMsg, key)
		case "streaming":
			err = unpopulate(val, &b.Streaming)
			delete(rawMsg, key)
		case "streamingBlockSizeMiB":
			err = unpopulate(val, &b.StreamingBlockSizeMiB)
			delete(rawMsg, key)
		case "streamingCacheLimitMiB":
			err = unpopulate(val, &b.StreamingCacheLimitMiB)
			delete(rawMsg, key)
		case "streamingMaxBlocksPerFile":
			err = unpopulate(val, &b.StreamingMaxBlocksPerFile)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BlobInterceptionMountOptions - Describes options to use when accessing a storage cache container backed by Azure blob storage
// through file system interception.
type BlobInterceptionMountOptions struct {
	// REQUIRED
	Kind *MountOptionsKind `json:"kind,omitempty"`
}

// GetBlobMountOptionsBase implements the BlobMountOptionsBaseClassification interface for type BlobInterceptionMountOptions.
func (b *BlobInterceptionMountOptions) GetBlobMountOptionsBase() *BlobMountOptionsBase {
	return &BlobMountOptionsBase{
		Kind: b.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BlobInterceptionMountOptions.
func (b BlobInterceptionMountOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = MountOptionsKindInterception
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobInterceptionMountOptions.
func (b *BlobInterceptionMountOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &b.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BlobMountOptionsBaseClassification provides polymorphic access to related types.
// Call the interface's GetBlobMountOptionsBase() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *BlobFuseMountOptions, *BlobInterceptionMountOptions, *BlobMountOptionsBase
type BlobMountOptionsBaseClassification interface {
	// GetBlobMountOptionsBase returns the BlobMountOptionsBase content of the underlying type.
	GetBlobMountOptionsBase() *BlobMountOptionsBase
}

// BlobMountOptionsBase - Describes options to use when mounting a storage cache container backed by Azure blob storage.
type BlobMountOptionsBase struct {
	// REQUIRED
	Kind *MountOptionsKind `json:"kind,omitempty"`
}

// GetBlobMountOptionsBase implements the BlobMountOptionsBaseClassification interface for type BlobMountOptionsBase.
func (b *BlobMountOptionsBase) GetBlobMountOptionsBase() *BlobMountOptionsBase { return b }

// BlobStorageCacheProperties - Describes the properties of a storage cache resource backed by Azure blob.
type BlobStorageCacheProperties struct {
	// REQUIRED
	Kind *StorageCacheKind `json:"kind,omitempty"`

	// Description of the storage cache resource.
	Description *string `json:"description,omitempty"`

	// Describes options to use when mounting a storage cache container backed by Azure blob storage.
	MountOptions      BlobMountOptionsBaseClassification `json:"mountOptions,omitempty"`
	ProvisioningState *ProvisioningState                 `json:"provisioningState,omitempty"`

	// Optional region for managed storage resources (if any).
	Region        *string             `json:"region,omitempty"`
	Status        *StorageCacheStatus `json:"status,omitempty"`
	StorageTarget *BlobStorageTarget  `json:"storageTarget,omitempty"`

	// READ-ONLY; Default mount path that will be used within a job or model if none is specified.
	DefaultMountPath *string `json:"defaultMountPath,omitempty" azure:"ro"`
}

// GetStorageCachePropertiesBase implements the StorageCachePropertiesBaseClassification interface for type BlobStorageCacheProperties.
func (b *BlobStorageCacheProperties) GetStorageCachePropertiesBase() *StorageCachePropertiesBase {
	return &StorageCachePropertiesBase{
		Kind:              b.Kind,
		Description:       b.Description,
		Region:            b.Region,
		ProvisioningState: b.ProvisioningState,
		Status:            b.Status,
		DefaultMountPath:  b.DefaultMountPath,
	}
}

// MarshalJSON implements the json.Marshaller interface for type BlobStorageCacheProperties.
func (b BlobStorageCacheProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "defaultMountPath", b.DefaultMountPath)
	populate(objectMap, "description", b.Description)
	objectMap["kind"] = StorageCacheKindBlob
	populate(objectMap, "mountOptions", b.MountOptions)
	populate(objectMap, "provisioningState", b.ProvisioningState)
	populate(objectMap, "region", b.Region)
	populate(objectMap, "status", b.Status)
	populate(objectMap, "storageTarget", b.StorageTarget)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobStorageCacheProperties.
func (b *BlobStorageCacheProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "defaultMountPath":
			err = unpopulate(val, &b.DefaultMountPath)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &b.Description)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &b.Kind)
			delete(rawMsg, key)
		case "mountOptions":
			b.MountOptions, err = unmarshalBlobMountOptionsBaseClassification(val)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &b.ProvisioningState)
			delete(rawMsg, key)
		case "region":
			err = unpopulate(val, &b.Region)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &b.Status)
			delete(rawMsg, key)
		case "storageTarget":
			err = unpopulate(val, &b.StorageTarget)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type BlobStorageTarget struct {
	// REQUIRED; Storage container endpoint (e.g. https://.blob.core.windows.net/
	ContainerEndpoint *string `json:"containerEndpoint,omitempty"`

	// Optional model blob name within container for FPGA inferencing deployments.
	BlobName *string `json:"blobName,omitempty"`

	// SAS token to use for authentication.
	SasToken *string `json:"sasToken,omitempty"`

	// User assigned managed identity resource ID to use for authentication.
	UserAssignedIdentity *string `json:"userAssignedIdentity,omitempty"`
}

// CheckpointPolicy - Describes the checkpointing policy for job
type CheckpointPolicy struct {
	// Maximum elapsed duration between subsequent checkpoints. The value should be in ISO 8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations).
	CheckpointInterval *string `json:"checkpointInterval,omitempty"`

	// Maximum elapsed iteration count between the subsequent checkpoints.
	CheckpointIterationCount *int32 `json:"checkpointIterationCount,omitempty"`

	// The relative path in the platform storage.
	CheckpointRelativePath *string `json:"checkpointRelativePath,omitempty"`

	// Describes the checkpointing retention policy for job
	CheckpointRetentionPolicy *CheckpointRetentionPolicy `json:"checkpointRetentionPolicy,omitempty"`

	// Enables automatic checkpointing of training job.
	EnableCheckpoint *bool `json:"enableCheckpoint,omitempty"`
}

// CheckpointRetentionPolicy - Describes the checkpointing retention policy for job
type CheckpointRetentionPolicy struct {
	// REQUIRED
	Mode *CheckpointRetentionMode `json:"mode,omitempty"`

	// Maximum storage size for checkpoint files to retain. Checkpoint files will be purged in FIFO manner.
	MaxStorage *int32 `json:"maxStorage,omitempty"`

	// Minimum elapsed duration before deleting checkpoint. The value should be in ISO 8601 format (http://en.wikipedia.org/wiki/ISO_8601#Durations).
	TTL *string `json:"ttl,omitempty"`
}

// CompilationPolicyBase - This type describes the Compilation Policy of the model for training / inferencing.
type CompilationPolicyBase struct {
	// REQUIRED
	Kind *CompilationPolicyKind `json:"kind,omitempty"`
}

// ContainerEntryPoint - Describes container's entry-point.
type ContainerEntryPoint struct {
	// The entry point program.
	Program *string `json:"program,omitempty"`

	// Command line arguments to be passed to the program.
	ProgramArgs *string `json:"programArgs,omitempty"`
}

// ContainerImageBaseClassification provides polymorphic access to related types.
// Call the interface's GetContainerImageBase() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ContainerImageBase, *CustomContainerImage, *PlatformContainerImage
type ContainerImageBaseClassification interface {
	// GetContainerImageBase returns the ContainerImageBase content of the underlying type.
	GetContainerImageBase() *ContainerImageBase
}

// ContainerImageBase - Describes the container image for the job resource.
type ContainerImageBase struct {
	// REQUIRED
	Kind *ContainerImageKind `json:"kind,omitempty"`
}

// GetContainerImageBase implements the ContainerImageBaseClassification interface for type ContainerImageBase.
func (c *ContainerImageBase) GetContainerImageBase() *ContainerImageBase { return c }

// ContainerSetting - Describes the settings of container.
type ContainerSetting struct {
	// Describes container's entry-point.
	CleanupEntryPoint *ContainerEntryPoint `json:"cleanupEntryPoint,omitempty"`

	// Environment variables.
	EnvironmentVariables map[string]*string `json:"environmentVariables,omitempty"`

	// Describes the container image for the job resource.
	Image ContainerImageBaseClassification `json:"image,omitempty"`

	// Describes the settings of the probe.
	LivenessProbeSetting ProbeSettingClassification `json:"livenessProbeSetting,omitempty"`

	// Describes container's entry-point.
	MainEntryPoint *ContainerEntryPoint `json:"mainEntryPoint,omitempty"`

	// Describes container's entry-point.
	SetupEntryPoint *ContainerEntryPoint `json:"setupEntryPoint,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ContainerSetting.
func (c ContainerSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cleanupEntryPoint", c.CleanupEntryPoint)
	populate(objectMap, "environmentVariables", c.EnvironmentVariables)
	populate(objectMap, "image", c.Image)
	populate(objectMap, "livenessProbeSetting", c.LivenessProbeSetting)
	populate(objectMap, "mainEntryPoint", c.MainEntryPoint)
	populate(objectMap, "setupEntryPoint", c.SetupEntryPoint)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerSetting.
func (c *ContainerSetting) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cleanupEntryPoint":
			err = unpopulate(val, &c.CleanupEntryPoint)
			delete(rawMsg, key)
		case "environmentVariables":
			err = unpopulate(val, &c.EnvironmentVariables)
			delete(rawMsg, key)
		case "image":
			c.Image, err = unmarshalContainerImageBaseClassification(val)
			delete(rawMsg, key)
		case "livenessProbeSetting":
			c.LivenessProbeSetting, err = unmarshalProbeSettingClassification(val)
			delete(rawMsg, key)
		case "mainEntryPoint":
			err = unpopulate(val, &c.MainEntryPoint)
			delete(rawMsg, key)
		case "setupEntryPoint":
			err = unpopulate(val, &c.SetupEntryPoint)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// CustomContainerImage - Describes a custom image.
type CustomContainerImage struct {
	// REQUIRED; Location of image to use for training.
	Image *string `json:"image,omitempty"`

	// REQUIRED
	Kind *ContainerImageKind `json:"kind,omitempty"`

	// Password of the container registry account. Required if UserAssignedIdentity is omitted.
	ContainerRegistryPassword *string `json:"containerRegistryPassword,omitempty"`

	// Username of the container registry account. Required if UserAssignedIdentity is omitted.
	ContainerRegistryUsername *string `json:"containerRegistryUsername,omitempty"`

	// User assigned identity with access to the container registry. Required if ContainerRegistryUsername and ContainerRegistryPassword
	// are omitted.
	UserAssignedIdentity *string `json:"userAssignedIdentity,omitempty"`
}

// GetContainerImageBase implements the ContainerImageBaseClassification interface for type CustomContainerImage.
func (c *CustomContainerImage) GetContainerImageBase() *ContainerImageBase {
	return &ContainerImageBase{
		Kind: c.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type CustomContainerImage.
func (c CustomContainerImage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "containerRegistryPassword", c.ContainerRegistryPassword)
	populate(objectMap, "containerRegistryUsername", c.ContainerRegistryUsername)
	populate(objectMap, "image", c.Image)
	objectMap["kind"] = ContainerImageKindCustom
	populate(objectMap, "userAssignedIdentity", c.UserAssignedIdentity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CustomContainerImage.
func (c *CustomContainerImage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerRegistryPassword":
			err = unpopulate(val, &c.ContainerRegistryPassword)
			delete(rawMsg, key)
		case "containerRegistryUsername":
			err = unpopulate(val, &c.ContainerRegistryUsername)
			delete(rawMsg, key)
		case "image":
			err = unpopulate(val, &c.Image)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &c.Kind)
			delete(rawMsg, key)
		case "userAssignedIdentity":
			err = unpopulate(val, &c.UserAssignedIdentity)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DelegatedSubnetProperties - Describes the properties of a delegated subnet resource.
type DelegatedSubnetProperties struct {
	// REQUIRED
	Kind *NetworkKind `json:"kind,omitempty"`

	// Subnet resource ID (e.g. /subscriptions/{subscriptionId}/resourceGroups/{groupName}/providers/Microsoft.Network/virtualNetworks/{virtualNetworkName}/subnets/{subnetName}
	DelegatedSubnetResourceID *string                `json:"delegatedSubnetResourceId,omitempty"`
	ProvisioningState         *ProvisioningState     `json:"provisioningState,omitempty"`
	Status                    *NetworkResourceStatus `json:"status,omitempty"`
}

// GetNetworkPropertiesBase implements the NetworkPropertiesBaseClassification interface for type DelegatedSubnetProperties.
func (d *DelegatedSubnetProperties) GetNetworkPropertiesBase() *NetworkPropertiesBase {
	return &NetworkPropertiesBase{
		Kind:              d.Kind,
		ProvisioningState: d.ProvisioningState,
		Status:            d.Status,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DelegatedSubnetProperties.
func (d DelegatedSubnetProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "delegatedSubnetResourceId", d.DelegatedSubnetResourceID)
	objectMap["kind"] = NetworkKindDelegatedSubnet
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "status", d.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DelegatedSubnetProperties.
func (d *DelegatedSubnetProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "delegatedSubnetResourceId":
			err = unpopulate(val, &d.DelegatedSubnetResourceID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &d.Kind)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &d.ProvisioningState)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &d.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// Endpoint - Describes the named endpoint of a job or model.
type Endpoint struct {
	// READ-ONLY; The address of the endpoint.
	Address *string `json:"address,omitempty" azure:"ro"`

	// READ-ONLY; The name of the endpoint.
	Name *string `json:"name,omitempty" azure:"ro"`
}

type ErrorDetailsModel struct {
	Code    *string `json:"code,omitempty"`
	Message *string `json:"message,omitempty"`
}

type ErrorModel struct {
	Error *ErrorModelProperties `json:"error,omitempty"`
}

type ErrorModelProperties struct {
	Code       *string              `json:"code,omitempty"`
	Details    []*ErrorDetailsModel `json:"details,omitempty"`
	InnerError *string              `json:"innerError,omitempty"`
	Message    *string              `json:"message,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ErrorModelProperties.
func (e ErrorModelProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "innerError", e.InnerError)
	populate(objectMap, "message", e.Message)
	return json.Marshal(objectMap)
}

// ExecProbeSetting - Describes probe settings based on executing a program.
type ExecProbeSetting struct {
	// REQUIRED
	Kind *ProbeSettingKind `json:"kind,omitempty"`

	// REQUIRED; Program to be executed for the probe.
	Program *string `json:"program,omitempty"`

	// Number of consecutive failures for the probe after which the container is restarted.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The period in seconds to specify the frequency of the probe.
	FrequencyInSeconds *int32 `json:"frequencyInSeconds,omitempty"`

	// The initial delay in seconds to start executing the probe after the container has started.
	InitialDelayInSeconds *int32 `json:"initialDelayInSeconds,omitempty"`

	// Arguments passed into the Program.
	ProgramArgs *string `json:"programArgs,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after having failed.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The period in seconds after which we consider the probe as failed, if it hasn't finished successfully.
	TimeoutInSeconds *int32 `json:"timeoutInSeconds,omitempty"`
}

// GetProbeSetting implements the ProbeSettingClassification interface for type ExecProbeSetting.
func (e *ExecProbeSetting) GetProbeSetting() *ProbeSetting {
	return &ProbeSetting{
		Kind:                  e.Kind,
		InitialDelayInSeconds: e.InitialDelayInSeconds,
		SuccessThreshold:      e.SuccessThreshold,
		FailureThreshold:      e.FailureThreshold,
		FrequencyInSeconds:    e.FrequencyInSeconds,
		TimeoutInSeconds:      e.TimeoutInSeconds,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ExecProbeSetting.
func (e ExecProbeSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "failureThreshold", e.FailureThreshold)
	populate(objectMap, "frequencyInSeconds", e.FrequencyInSeconds)
	populate(objectMap, "initialDelayInSeconds", e.InitialDelayInSeconds)
	objectMap["kind"] = ProbeSettingKindExec
	populate(objectMap, "program", e.Program)
	populate(objectMap, "programArgs", e.ProgramArgs)
	populate(objectMap, "successThreshold", e.SuccessThreshold)
	populate(objectMap, "timeoutInSeconds", e.TimeoutInSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExecProbeSetting.
func (e *ExecProbeSetting) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "failureThreshold":
			err = unpopulate(val, &e.FailureThreshold)
			delete(rawMsg, key)
		case "frequencyInSeconds":
			err = unpopulate(val, &e.FrequencyInSeconds)
			delete(rawMsg, key)
		case "initialDelayInSeconds":
			err = unpopulate(val, &e.InitialDelayInSeconds)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &e.Kind)
			delete(rawMsg, key)
		case "program":
			err = unpopulate(val, &e.Program)
			delete(rawMsg, key)
		case "programArgs":
			err = unpopulate(val, &e.ProgramArgs)
			delete(rawMsg, key)
		case "successThreshold":
			err = unpopulate(val, &e.SuccessThreshold)
			delete(rawMsg, key)
		case "timeoutInSeconds":
			err = unpopulate(val, &e.TimeoutInSeconds)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GroupPolicyClientBeginCreateOrUpdateOptions contains the optional parameters for the GroupPolicyClient.BeginCreateOrUpdate
// method.
type GroupPolicyClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// GroupPolicyClientBeginDeleteOptions contains the optional parameters for the GroupPolicyClient.BeginDelete method.
type GroupPolicyClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// GroupPolicyClientBeginUpdateOptions contains the optional parameters for the GroupPolicyClient.BeginUpdate method.
type GroupPolicyClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// GroupPolicyClientGetOptions contains the optional parameters for the GroupPolicyClient.Get method.
type GroupPolicyClientGetOptions struct {
	// placeholder for future optional parameters
}

// GroupPolicyClientListByAccountOptions contains the optional parameters for the GroupPolicyClient.ListByAccount method.
type GroupPolicyClientListByAccountOptions struct {
	ContinuationToken *string
}

// GroupPolicyPatchProperties - Describes all properties which can be updated for a Singularity group policy resource.
type GroupPolicyPatchProperties struct {
	// User-friendly description of the resource.
	Description *string `json:"description,omitempty"`

	// Maximum allowed bandwidth from shared storageContainer expressed in MB/s.
	MaxSharedStorageBandwidth *int32 `json:"maxSharedStorageBandwidth,omitempty"`

	// Maximum allowed IOPS from shared storageContainer.
	MaxSharedStorageIOPs *int32 `json:"maxSharedStorageIOPs,omitempty"`

	// A list of quota policy per instance type series.
	Quotas []*InstanceTypeSeriesQuota `json:"quotas,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GroupPolicyPatchProperties.
func (g GroupPolicyPatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", g.Description)
	populate(objectMap, "maxSharedStorageBandwidth", g.MaxSharedStorageBandwidth)
	populate(objectMap, "maxSharedStorageIOPs", g.MaxSharedStorageIOPs)
	populate(objectMap, "quotas", g.Quotas)
	return json.Marshal(objectMap)
}

// GroupPolicyProperties - Describes the properties of a GroupPolicy resource.
type GroupPolicyProperties struct {
	// User-friendly description of the resource.
	Description *string `json:"description,omitempty"`

	// Maximum allowed bandwidth from shared storageContainer expressed in MB/s.
	MaxSharedStorageBandwidth *int32 `json:"maxSharedStorageBandwidth,omitempty"`

	// Maximum allowed IOPS from shared storageContainer.
	MaxSharedStorageIOPs *int32             `json:"maxSharedStorageIOPs,omitempty"`
	ProvisioningState    *ProvisioningState `json:"provisioningState,omitempty"`

	// A list of quota policy per instance type series.
	Quotas []*InstanceTypeSeriesQuota `json:"quotas,omitempty"`
	Status *PolicyStatus              `json:"status,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GroupPolicyProperties.
func (g GroupPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", g.Description)
	populate(objectMap, "maxSharedStorageBandwidth", g.MaxSharedStorageBandwidth)
	populate(objectMap, "maxSharedStorageIOPs", g.MaxSharedStorageIOPs)
	populate(objectMap, "provisioningState", g.ProvisioningState)
	populate(objectMap, "quotas", g.Quotas)
	populate(objectMap, "status", g.Status)
	return json.Marshal(objectMap)
}

// GroupPolicyResourceDescription - Describes a GroupPolicy resource in Singularity.
type GroupPolicyResourceDescription struct {
	Properties *GroupPolicyResourceDescriptionProperties `json:"properties,omitempty"`
	SystemData *ResourceSystemData                       `json:"systemData,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier for the resource. For example, /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. For example, Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GroupPolicyResourceDescription.
func (g GroupPolicyResourceDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", g.ID)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "properties", g.Properties)
	populate(objectMap, "systemData", g.SystemData)
	populate(objectMap, "tags", g.Tags)
	populate(objectMap, "type", g.Type)
	return json.Marshal(objectMap)
}

// GroupPolicyResourceDescriptionList - A pageable list of GroupPolicy resources.
type GroupPolicyResourceDescriptionList struct {
	// READ-ONLY; URI to fetch the next page of the list.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; One page of the list.
	Value []*GroupPolicyResourceDescription `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GroupPolicyResourceDescriptionList.
func (g GroupPolicyResourceDescriptionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", g.NextLink)
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

type GroupPolicyResourceDescriptionProperties struct {
	// User-friendly description of the resource.
	Description *string `json:"description,omitempty"`

	// Maximum allowed bandwidth from shared storageContainer expressed in MB/s.
	MaxSharedStorageBandwidth *int32 `json:"maxSharedStorageBandwidth,omitempty"`

	// Maximum allowed IOPS from shared storageContainer.
	MaxSharedStorageIOPs *int32             `json:"maxSharedStorageIOPs,omitempty"`
	ProvisioningState    *ProvisioningState `json:"provisioningState,omitempty"`

	// A list of quota policy per instance type series.
	Quotas []*InstanceTypeSeriesQuota `json:"quotas,omitempty"`
	Status *PolicyStatus              `json:"status,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GroupPolicyResourceDescriptionProperties.
func (g GroupPolicyResourceDescriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", g.Description)
	populate(objectMap, "maxSharedStorageBandwidth", g.MaxSharedStorageBandwidth)
	populate(objectMap, "maxSharedStorageIOPs", g.MaxSharedStorageIOPs)
	populate(objectMap, "provisioningState", g.ProvisioningState)
	populate(objectMap, "quotas", g.Quotas)
	populate(objectMap, "status", g.Status)
	return json.Marshal(objectMap)
}

// GroupPolicyResourcePatchDescription - Describes all properties which can be updated for a Singularity group policy resource.
type GroupPolicyResourcePatchDescription struct {
	// REQUIRED
	Properties *GroupPolicyResourcePatchDescriptionProperties `json:"properties,omitempty"`
	SystemData *ResourceSystemData                            `json:"systemData,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier for the resource. For example, /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. For example, Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GroupPolicyResourcePatchDescription.
func (g GroupPolicyResourcePatchDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", g.ID)
	populate(objectMap, "name", g.Name)
	populate(objectMap, "properties", g.Properties)
	populate(objectMap, "systemData", g.SystemData)
	populate(objectMap, "tags", g.Tags)
	populate(objectMap, "type", g.Type)
	return json.Marshal(objectMap)
}

type GroupPolicyResourcePatchDescriptionProperties struct {
	// User-friendly description of the resource.
	Description *string `json:"description,omitempty"`

	// Maximum allowed bandwidth from shared storageContainer expressed in MB/s.
	MaxSharedStorageBandwidth *int32 `json:"maxSharedStorageBandwidth,omitempty"`

	// Maximum allowed IOPS from shared storageContainer.
	MaxSharedStorageIOPs *int32 `json:"maxSharedStorageIOPs,omitempty"`

	// A list of quota policy per instance type series.
	Quotas []*InstanceTypeSeriesQuota `json:"quotas,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GroupPolicyResourcePatchDescriptionProperties.
func (g GroupPolicyResourcePatchDescriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", g.Description)
	populate(objectMap, "maxSharedStorageBandwidth", g.MaxSharedStorageBandwidth)
	populate(objectMap, "maxSharedStorageIOPs", g.MaxSharedStorageIOPs)
	populate(objectMap, "quotas", g.Quotas)
	return json.Marshal(objectMap)
}

// HTTPProbeSetting - Describes probe settings based on HTTP request.
type HTTPProbeSetting struct {
	// REQUIRED
	Kind *ProbeSettingKind `json:"kind,omitempty"`

	// Number of consecutive failures for the probe after which the container is restarted.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The period in seconds to specify the frequency of the probe.
	FrequencyInSeconds *int32 `json:"frequencyInSeconds,omitempty"`

	// The initial delay in seconds to start executing the probe after the container has started.
	InitialDelayInSeconds *int32 `json:"initialDelayInSeconds,omitempty"`

	// The path relative to the endpoint domain name used to probe.
	Path *string `json:"path,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after having failed.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The period in seconds after which we consider the probe as failed, if it hasn't finished successfully.
	TimeoutInSeconds *int32 `json:"timeoutInSeconds,omitempty"`
}

// GetProbeSetting implements the ProbeSettingClassification interface for type HTTPProbeSetting.
func (h *HTTPProbeSetting) GetProbeSetting() *ProbeSetting {
	return &ProbeSetting{
		Kind:                  h.Kind,
		InitialDelayInSeconds: h.InitialDelayInSeconds,
		SuccessThreshold:      h.SuccessThreshold,
		FailureThreshold:      h.FailureThreshold,
		FrequencyInSeconds:    h.FrequencyInSeconds,
		TimeoutInSeconds:      h.TimeoutInSeconds,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HTTPProbeSetting.
func (h HTTPProbeSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "failureThreshold", h.FailureThreshold)
	populate(objectMap, "frequencyInSeconds", h.FrequencyInSeconds)
	populate(objectMap, "initialDelayInSeconds", h.InitialDelayInSeconds)
	objectMap["kind"] = ProbeSettingKindHTTP
	populate(objectMap, "path", h.Path)
	populate(objectMap, "successThreshold", h.SuccessThreshold)
	populate(objectMap, "timeoutInSeconds", h.TimeoutInSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPProbeSetting.
func (h *HTTPProbeSetting) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "failureThreshold":
			err = unpopulate(val, &h.FailureThreshold)
			delete(rawMsg, key)
		case "frequencyInSeconds":
			err = unpopulate(val, &h.FrequencyInSeconds)
			delete(rawMsg, key)
		case "initialDelayInSeconds":
			err = unpopulate(val, &h.InitialDelayInSeconds)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &h.Kind)
			delete(rawMsg, key)
		case "path":
			err = unpopulate(val, &h.Path)
			delete(rawMsg, key)
		case "successThreshold":
			err = unpopulate(val, &h.SuccessThreshold)
			delete(rawMsg, key)
		case "timeoutInSeconds":
			err = unpopulate(val, &h.TimeoutInSeconds)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// IdleResourcesHandlingPolicy - Describes the properties of idle resources handling policy.
type IdleResourcesHandlingPolicy struct {
	IdleResourcesHandlingMode *IdleResourcesHandlingMode `json:"idleResourcesHandlingMode,omitempty"`
}

// ImagesClientListOptions contains the optional parameters for the ImagesClient.List method.
type ImagesClientListOptions struct {
	// placeholder for future optional parameters
}

// InstanceTypeSeriesClientListInstanceTypeOptions contains the optional parameters for the InstanceTypeSeriesClient.ListInstanceType
// method.
type InstanceTypeSeriesClientListInstanceTypeOptions struct {
	// placeholder for future optional parameters
}

// InstanceTypeSeriesClientListOptions contains the optional parameters for the InstanceTypeSeriesClient.List method.
type InstanceTypeSeriesClientListOptions struct {
	// placeholder for future optional parameters
}

// InstanceTypeSeriesQuota - Describes the quota for the InstanceType series.
type InstanceTypeSeriesQuota struct {
	// REQUIRED; The identifier for instance type series quota.
	ID *string `json:"id,omitempty"`

	// REQUIRED; Maximum allowed units for the instance type series.
	Limit   *int64   `json:"limit,omitempty"`
	SLATier *SLATier `json:"slaTier,omitempty"`

	// READ-ONLY; User friendly description for the instance type series.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Number of units currently in use.
	Used *int64 `json:"used,omitempty" azure:"ro"`
}

// InstanceTypeSeriesQuotaList - A pageable list of quotas.
type InstanceTypeSeriesQuotaList struct {
	// READ-ONLY; URI to fetch the next page of the list.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; One page of the list.
	Value []*InstanceTypeSeriesQuota `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type InstanceTypeSeriesQuotaList.
func (i InstanceTypeSeriesQuotaList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// InstanceTypeSetting - Describes setting for a Singularity Instance Type
type InstanceTypeSetting struct {
	// Describes the settings of container.
	ContainerSetting *ContainerSetting `json:"containerSetting,omitempty"`

	// The instance type name.
	InstanceType *string `json:"instanceType,omitempty"`

	// Specifies the name of this instance type setting. This name can be used to identify the instance of an instanceType. Resources
	// referencing the same name are collocated on the same instance of the
	// instance type.
	Name *string `json:"name,omitempty"`
}

// InstanceTypeSettings - Describes the instance type settings.
type InstanceTypeSettings struct {
	// REQUIRED; The instance type belonging to the same series.
	InstanceType *string `json:"instanceType,omitempty"`

	// REQUIRED; Describes the scale policy for a Job or a Model.
	ScalePolicy *ScalePolicy `json:"scalePolicy,omitempty"`
}

// JobClientBeginApproveOptions contains the optional parameters for the JobClient.BeginApprove method.
type JobClientBeginApproveOptions struct {
	Body *JobUserActionDescription
}

// JobClientBeginCancelOptions contains the optional parameters for the JobClient.BeginCancel method.
type JobClientBeginCancelOptions struct {
	Body *JobUserActionDescription
}

// JobClientBeginCreateOrUpdateOptions contains the optional parameters for the JobClient.BeginCreateOrUpdate method.
type JobClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// JobClientBeginCreateSasTokenOptions contains the optional parameters for the JobClient.BeginCreateSasToken method.
type JobClientBeginCreateSasTokenOptions struct {
	// Singularity job Shared Access Signature (SAS) token information.
	Body *JobSasTokenDescription
}

// JobClientBeginDeleteOptions contains the optional parameters for the JobClient.BeginDelete method.
type JobClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// JobClientBeginRemoveOptions contains the optional parameters for the JobClient.BeginRemove method.
type JobClientBeginRemoveOptions struct {
	Body *JobUserActionDescription
}

// JobClientBeginResumeOptions contains the optional parameters for the JobClient.BeginResume method.
type JobClientBeginResumeOptions struct {
	Body *JobUserActionDescription
}

// JobClientBeginSuspendOptions contains the optional parameters for the JobClient.BeginSuspend method.
type JobClientBeginSuspendOptions struct {
	Body *JobUserActionDescription
}

// JobClientBeginUpdateOptions contains the optional parameters for the JobClient.BeginUpdate method.
type JobClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// JobClientGetOptions contains the optional parameters for the JobClient.Get method.
type JobClientGetOptions struct {
	// placeholder for future optional parameters
}

// JobClientListByAccountOptions contains the optional parameters for the JobClient.ListByAccount method.
type JobClientListByAccountOptions struct {
	ContinuationToken *string
}

// JobClientRenewKeyOptions contains the optional parameters for the JobClient.RenewKey method.
type JobClientRenewKeyOptions struct {
	// placeholder for future optional parameters
}

// JobPatchProperties - Describes all properties which can be updated for a Singularity job resource.
type JobPatchProperties struct {
	// User-friendly description of the job.
	Description        *string             `json:"description,omitempty"`
	SchedulingPriority *SchedulingPriority `json:"schedulingPriority,omitempty"`
}

// JobResourceDescription - Describes a job resource in Singularity.
type JobResourceDescription struct {
	// REQUIRED
	Properties *JobResourceDescriptionProperties `json:"properties,omitempty"`
	Identity   *ResourceIdentity                 `json:"identity,omitempty"`
	SystemData *ResourceSystemData               `json:"systemData,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier for the resource. For example, /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. For example, Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobResourceDescription.
func (j JobResourceDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", j.ID)
	populate(objectMap, "identity", j.Identity)
	populate(objectMap, "name", j.Name)
	populate(objectMap, "properties", j.Properties)
	populate(objectMap, "systemData", j.SystemData)
	populate(objectMap, "tags", j.Tags)
	populate(objectMap, "type", j.Type)
	return json.Marshal(objectMap)
}

// JobResourceDescriptionList - A pageable list of Job resources.
type JobResourceDescriptionList struct {
	// READ-ONLY; URI to fetch the next page of the list.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; One page of the list.
	Value []*JobResourceDescription `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobResourceDescriptionList.
func (j JobResourceDescriptionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", j.NextLink)
	populate(objectMap, "value", j.Value)
	return json.Marshal(objectMap)
}

type JobResourceDescriptionProperties struct {
	// REQUIRED; Describes the container image for the job resource.
	ContainerImage ContainerImageBaseClassification `json:"containerImage,omitempty"`

	// REQUIRED; Collection of placement policies to use for the training job.
	PlacementPolicies []*PlacementPolicy `json:"placementPolicies,omitempty"`

	// Describes the checkpointing policy for job
	CheckpointPolicy *CheckpointPolicy `json:"checkpointPolicy,omitempty"`

	// Describes the location of a storage source and how it will be accessed.
	CodeLocation *StorageLocation `json:"codeLocation,omitempty"`

	// Job input data location.
	DataLocation []*StorageLocation `json:"dataLocation,omitempty"`

	// User-friendly description of the job.
	Description *string `json:"description,omitempty"`

	// User specified job environment variables.
	EnvironmentVariables map[string]*string `json:"environmentVariables,omitempty"`

	// Group policy name associated with the training job.
	GroupPolicyName *string `json:"groupPolicyName,omitempty"`

	// Maximum execution time for a training job in the account (in hours).
	MaxJobExecutionTime *float64 `json:"maxJobExecutionTime,omitempty"`

	// Describes a network resource reference.
	NetworkResourceRef *NetworkReference `json:"networkResourceRef,omitempty"`

	// Describes the location of a storage source and how it will be accessed.
	OutputLocation *StorageLocation `json:"outputLocation,omitempty"`

	// The entry script for your Job in the codeLocation. For interactive jobs, specify null.
	Program *string `json:"program,omitempty"`

	// Command line arguments to be passed to the program.
	ProgramArgs        *string             `json:"programArgs,omitempty"`
	ProvisioningState  *ProvisioningState  `json:"provisioningState,omitempty"`
	SLATier            *SLATier            `json:"slaTier,omitempty"`
	SchedulingPriority *SchedulingPriority `json:"schedulingPriority,omitempty"`
	Status             *JobStatus          `json:"status,omitempty"`

	// Minimum idle time before job gets automatically suspended (in hours).
	SuspendOnIdleTime *float64 `json:"suspendOnIdleTime,omitempty"`

	// The directory which TensorBoard will be configured to use as the log directory.
	TensorBoardLogDirectory *string `json:"tensorBoardLogDirectory,omitempty"`

	// READ-ONLY; Url to access Grafana endpoint of the job.
	GrafanaEndpoint *string `json:"grafanaEndpoint,omitempty" azure:"ro"`

	// READ-ONLY; System generated globally unique id for the job. This property is read only.
	JobID *string `json:"jobId,omitempty" azure:"ro"`

	// READ-ONLY; Url to access logs of the job.
	JobLogsEndpoint *string `json:"jobLogsEndpoint,omitempty" azure:"ro"`

	// READ-ONLY; Url to access Jupyter notebook endpoint of the job.
	NotebookEndpoint *string `json:"notebookEndpoint,omitempty" azure:"ro"`

	// READ-ONLY; Gives additional information about the current status of the job.
	StatusDetails *string `json:"statusDetails,omitempty" azure:"ro"`

	// READ-ONLY; Url to access TensorBoard endpoint of the job.
	TensorBoardEndpoint *string `json:"tensorBoardEndpoint,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobResourceDescriptionProperties.
func (j JobResourceDescriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "checkpointPolicy", j.CheckpointPolicy)
	populate(objectMap, "codeLocation", j.CodeLocation)
	populate(objectMap, "containerImage", j.ContainerImage)
	populate(objectMap, "dataLocation", j.DataLocation)
	populate(objectMap, "description", j.Description)
	populate(objectMap, "environmentVariables", j.EnvironmentVariables)
	populate(objectMap, "grafanaEndpoint", j.GrafanaEndpoint)
	populate(objectMap, "groupPolicyName", j.GroupPolicyName)
	populate(objectMap, "jobId", j.JobID)
	populate(objectMap, "jobLogsEndpoint", j.JobLogsEndpoint)
	populate(objectMap, "maxJobExecutionTime", j.MaxJobExecutionTime)
	populate(objectMap, "networkResourceRef", j.NetworkResourceRef)
	populate(objectMap, "notebookEndpoint", j.NotebookEndpoint)
	populate(objectMap, "outputLocation", j.OutputLocation)
	populate(objectMap, "placementPolicies", j.PlacementPolicies)
	populate(objectMap, "program", j.Program)
	populate(objectMap, "programArgs", j.ProgramArgs)
	populate(objectMap, "provisioningState", j.ProvisioningState)
	populate(objectMap, "slaTier", j.SLATier)
	populate(objectMap, "schedulingPriority", j.SchedulingPriority)
	populate(objectMap, "status", j.Status)
	populate(objectMap, "statusDetails", j.StatusDetails)
	populate(objectMap, "suspendOnIdleTime", j.SuspendOnIdleTime)
	populate(objectMap, "tensorBoardEndpoint", j.TensorBoardEndpoint)
	populate(objectMap, "tensorBoardLogDirectory", j.TensorBoardLogDirectory)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobResourceDescriptionProperties.
func (j *JobResourceDescriptionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "checkpointPolicy":
			err = unpopulate(val, &j.CheckpointPolicy)
			delete(rawMsg, key)
		case "codeLocation":
			err = unpopulate(val, &j.CodeLocation)
			delete(rawMsg, key)
		case "containerImage":
			j.ContainerImage, err = unmarshalContainerImageBaseClassification(val)
			delete(rawMsg, key)
		case "dataLocation":
			err = unpopulate(val, &j.DataLocation)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &j.Description)
			delete(rawMsg, key)
		case "environmentVariables":
			err = unpopulate(val, &j.EnvironmentVariables)
			delete(rawMsg, key)
		case "grafanaEndpoint":
			err = unpopulate(val, &j.GrafanaEndpoint)
			delete(rawMsg, key)
		case "groupPolicyName":
			err = unpopulate(val, &j.GroupPolicyName)
			delete(rawMsg, key)
		case "jobId":
			err = unpopulate(val, &j.JobID)
			delete(rawMsg, key)
		case "jobLogsEndpoint":
			err = unpopulate(val, &j.JobLogsEndpoint)
			delete(rawMsg, key)
		case "maxJobExecutionTime":
			err = unpopulate(val, &j.MaxJobExecutionTime)
			delete(rawMsg, key)
		case "networkResourceRef":
			err = unpopulate(val, &j.NetworkResourceRef)
			delete(rawMsg, key)
		case "notebookEndpoint":
			err = unpopulate(val, &j.NotebookEndpoint)
			delete(rawMsg, key)
		case "outputLocation":
			err = unpopulate(val, &j.OutputLocation)
			delete(rawMsg, key)
		case "placementPolicies":
			err = unpopulate(val, &j.PlacementPolicies)
			delete(rawMsg, key)
		case "program":
			err = unpopulate(val, &j.Program)
			delete(rawMsg, key)
		case "programArgs":
			err = unpopulate(val, &j.ProgramArgs)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &j.ProvisioningState)
			delete(rawMsg, key)
		case "slaTier":
			err = unpopulate(val, &j.SLATier)
			delete(rawMsg, key)
		case "schedulingPriority":
			err = unpopulate(val, &j.SchedulingPriority)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &j.Status)
			delete(rawMsg, key)
		case "statusDetails":
			err = unpopulate(val, &j.StatusDetails)
			delete(rawMsg, key)
		case "suspendOnIdleTime":
			err = unpopulate(val, &j.SuspendOnIdleTime)
			delete(rawMsg, key)
		case "tensorBoardEndpoint":
			err = unpopulate(val, &j.TensorBoardEndpoint)
			delete(rawMsg, key)
		case "tensorBoardLogDirectory":
			err = unpopulate(val, &j.TensorBoardLogDirectory)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobResourcePatchDescription - Describes all properties which can be updated for a Singularity job resource.
type JobResourcePatchDescription struct {
	// REQUIRED
	Properties *JobResourcePatchDescriptionProperties `json:"properties,omitempty"`
	SystemData *ResourceSystemData                    `json:"systemData,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier for the resource. For example, /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. For example, Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobResourcePatchDescription.
func (j JobResourcePatchDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", j.ID)
	populate(objectMap, "name", j.Name)
	populate(objectMap, "properties", j.Properties)
	populate(objectMap, "systemData", j.SystemData)
	populate(objectMap, "tags", j.Tags)
	populate(objectMap, "type", j.Type)
	return json.Marshal(objectMap)
}

type JobResourcePatchDescriptionProperties struct {
	// User-friendly description of the job.
	Description        *string             `json:"description,omitempty"`
	SchedulingPriority *SchedulingPriority `json:"schedulingPriority,omitempty"`
}

// JobResourceProperties - Describes the properties of a job resource.
type JobResourceProperties struct {
	// REQUIRED; Describes the container image for the job resource.
	ContainerImage ContainerImageBaseClassification `json:"containerImage,omitempty"`

	// REQUIRED; Collection of placement policies to use for the training job.
	PlacementPolicies []*PlacementPolicy `json:"placementPolicies,omitempty"`

	// Describes the checkpointing policy for job
	CheckpointPolicy *CheckpointPolicy `json:"checkpointPolicy,omitempty"`

	// Describes the location of a storage source and how it will be accessed.
	CodeLocation *StorageLocation `json:"codeLocation,omitempty"`

	// Job input data location.
	DataLocation []*StorageLocation `json:"dataLocation,omitempty"`

	// User-friendly description of the job.
	Description *string `json:"description,omitempty"`

	// User specified job environment variables.
	EnvironmentVariables map[string]*string `json:"environmentVariables,omitempty"`

	// Group policy name associated with the training job.
	GroupPolicyName *string `json:"groupPolicyName,omitempty"`

	// Maximum execution time for a training job in the account (in hours).
	MaxJobExecutionTime *float64 `json:"maxJobExecutionTime,omitempty"`

	// Describes a network resource reference.
	NetworkResourceRef *NetworkReference `json:"networkResourceRef,omitempty"`

	// Describes the location of a storage source and how it will be accessed.
	OutputLocation *StorageLocation `json:"outputLocation,omitempty"`

	// The entry script for your Job in the codeLocation. For interactive jobs, specify null.
	Program *string `json:"program,omitempty"`

	// Command line arguments to be passed to the program.
	ProgramArgs        *string             `json:"programArgs,omitempty"`
	ProvisioningState  *ProvisioningState  `json:"provisioningState,omitempty"`
	SLATier            *SLATier            `json:"slaTier,omitempty"`
	SchedulingPriority *SchedulingPriority `json:"schedulingPriority,omitempty"`
	Status             *JobStatus          `json:"status,omitempty"`

	// Minimum idle time before job gets automatically suspended (in hours).
	SuspendOnIdleTime *float64 `json:"suspendOnIdleTime,omitempty"`

	// The directory which TensorBoard will be configured to use as the log directory.
	TensorBoardLogDirectory *string `json:"tensorBoardLogDirectory,omitempty"`

	// READ-ONLY; Url to access Grafana endpoint of the job.
	GrafanaEndpoint *string `json:"grafanaEndpoint,omitempty" azure:"ro"`

	// READ-ONLY; System generated globally unique id for the job. This property is read only.
	JobID *string `json:"jobId,omitempty" azure:"ro"`

	// READ-ONLY; Url to access logs of the job.
	JobLogsEndpoint *string `json:"jobLogsEndpoint,omitempty" azure:"ro"`

	// READ-ONLY; Url to access Jupyter notebook endpoint of the job.
	NotebookEndpoint *string `json:"notebookEndpoint,omitempty" azure:"ro"`

	// READ-ONLY; Gives additional information about the current status of the job.
	StatusDetails *string `json:"statusDetails,omitempty" azure:"ro"`

	// READ-ONLY; Url to access TensorBoard endpoint of the job.
	TensorBoardEndpoint *string `json:"tensorBoardEndpoint,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobResourceProperties.
func (j JobResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "checkpointPolicy", j.CheckpointPolicy)
	populate(objectMap, "codeLocation", j.CodeLocation)
	populate(objectMap, "containerImage", j.ContainerImage)
	populate(objectMap, "dataLocation", j.DataLocation)
	populate(objectMap, "description", j.Description)
	populate(objectMap, "environmentVariables", j.EnvironmentVariables)
	populate(objectMap, "grafanaEndpoint", j.GrafanaEndpoint)
	populate(objectMap, "groupPolicyName", j.GroupPolicyName)
	populate(objectMap, "jobId", j.JobID)
	populate(objectMap, "jobLogsEndpoint", j.JobLogsEndpoint)
	populate(objectMap, "maxJobExecutionTime", j.MaxJobExecutionTime)
	populate(objectMap, "networkResourceRef", j.NetworkResourceRef)
	populate(objectMap, "notebookEndpoint", j.NotebookEndpoint)
	populate(objectMap, "outputLocation", j.OutputLocation)
	populate(objectMap, "placementPolicies", j.PlacementPolicies)
	populate(objectMap, "program", j.Program)
	populate(objectMap, "programArgs", j.ProgramArgs)
	populate(objectMap, "provisioningState", j.ProvisioningState)
	populate(objectMap, "slaTier", j.SLATier)
	populate(objectMap, "schedulingPriority", j.SchedulingPriority)
	populate(objectMap, "status", j.Status)
	populate(objectMap, "statusDetails", j.StatusDetails)
	populate(objectMap, "suspendOnIdleTime", j.SuspendOnIdleTime)
	populate(objectMap, "tensorBoardEndpoint", j.TensorBoardEndpoint)
	populate(objectMap, "tensorBoardLogDirectory", j.TensorBoardLogDirectory)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobResourceProperties.
func (j *JobResourceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "checkpointPolicy":
			err = unpopulate(val, &j.CheckpointPolicy)
			delete(rawMsg, key)
		case "codeLocation":
			err = unpopulate(val, &j.CodeLocation)
			delete(rawMsg, key)
		case "containerImage":
			j.ContainerImage, err = unmarshalContainerImageBaseClassification(val)
			delete(rawMsg, key)
		case "dataLocation":
			err = unpopulate(val, &j.DataLocation)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &j.Description)
			delete(rawMsg, key)
		case "environmentVariables":
			err = unpopulate(val, &j.EnvironmentVariables)
			delete(rawMsg, key)
		case "grafanaEndpoint":
			err = unpopulate(val, &j.GrafanaEndpoint)
			delete(rawMsg, key)
		case "groupPolicyName":
			err = unpopulate(val, &j.GroupPolicyName)
			delete(rawMsg, key)
		case "jobId":
			err = unpopulate(val, &j.JobID)
			delete(rawMsg, key)
		case "jobLogsEndpoint":
			err = unpopulate(val, &j.JobLogsEndpoint)
			delete(rawMsg, key)
		case "maxJobExecutionTime":
			err = unpopulate(val, &j.MaxJobExecutionTime)
			delete(rawMsg, key)
		case "networkResourceRef":
			err = unpopulate(val, &j.NetworkResourceRef)
			delete(rawMsg, key)
		case "notebookEndpoint":
			err = unpopulate(val, &j.NotebookEndpoint)
			delete(rawMsg, key)
		case "outputLocation":
			err = unpopulate(val, &j.OutputLocation)
			delete(rawMsg, key)
		case "placementPolicies":
			err = unpopulate(val, &j.PlacementPolicies)
			delete(rawMsg, key)
		case "program":
			err = unpopulate(val, &j.Program)
			delete(rawMsg, key)
		case "programArgs":
			err = unpopulate(val, &j.ProgramArgs)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &j.ProvisioningState)
			delete(rawMsg, key)
		case "slaTier":
			err = unpopulate(val, &j.SLATier)
			delete(rawMsg, key)
		case "schedulingPriority":
			err = unpopulate(val, &j.SchedulingPriority)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &j.Status)
			delete(rawMsg, key)
		case "statusDetails":
			err = unpopulate(val, &j.StatusDetails)
			delete(rawMsg, key)
		case "suspendOnIdleTime":
			err = unpopulate(val, &j.SuspendOnIdleTime)
			delete(rawMsg, key)
		case "tensorBoardEndpoint":
			err = unpopulate(val, &j.TensorBoardEndpoint)
			delete(rawMsg, key)
		case "tensorBoardLogDirectory":
			err = unpopulate(val, &j.TensorBoardLogDirectory)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobSasTokenDescription - Describes a Shared Access Signature (SAS) Token for Singularity Jobs.
type JobSasTokenDescription struct {
	// The time (UTC) after which the SAS token becomes invalid.
	ExpirationTime *time.Time `json:"expirationTime,omitempty"`

	// The name of the group policy.
	GroupPolicyName *string       `json:"groupPolicyName,omitempty"`
	Protocol        *ProtocolType `json:"protocol,omitempty"`

	// The SAS token is valid only after the start time (UTC).
	StartTime *time.Time `json:"startTime,omitempty"`

	// READ-ONLY; The SAS token generated by the service.
	Token *string `json:"token,omitempty" azure:"ro"`

	// READ-ONLY; The algorithm and API version the SAS token was generated with
	Version *string `json:"version,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type JobSasTokenDescription.
func (j JobSasTokenDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "expirationTime", j.ExpirationTime)
	populate(objectMap, "groupPolicyName", j.GroupPolicyName)
	populate(objectMap, "protocol", j.Protocol)
	populateTimeRFC3339(objectMap, "startTime", j.StartTime)
	populate(objectMap, "token", j.Token)
	populate(objectMap, "version", j.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobSasTokenDescription.
func (j *JobSasTokenDescription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expirationTime":
			err = unpopulateTimeRFC3339(val, &j.ExpirationTime)
			delete(rawMsg, key)
		case "groupPolicyName":
			err = unpopulate(val, &j.GroupPolicyName)
			delete(rawMsg, key)
		case "protocol":
			err = unpopulate(val, &j.Protocol)
			delete(rawMsg, key)
		case "startTime":
			err = unpopulateTimeRFC3339(val, &j.StartTime)
			delete(rawMsg, key)
		case "token":
			err = unpopulate(val, &j.Token)
			delete(rawMsg, key)
		case "version":
			err = unpopulate(val, &j.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobUserActionDescription - Describes properties for the user action of Singularity jobs.
type JobUserActionDescription struct {
	// The name of the group policy.
	GroupPolicyName *string `json:"groupPolicyName,omitempty"`
}

// ModelClientBeginCreateOrUpdateOptions contains the optional parameters for the ModelClient.BeginCreateOrUpdate method.
type ModelClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ModelClientBeginDeleteOptions contains the optional parameters for the ModelClient.BeginDelete method.
type ModelClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// ModelClientBeginUpdateOptions contains the optional parameters for the ModelClient.BeginUpdate method.
type ModelClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// ModelClientBeginValidateOptions contains the optional parameters for the ModelClient.BeginValidate method.
type ModelClientBeginValidateOptions struct {
	// placeholder for future optional parameters
}

// ModelClientGetOptions contains the optional parameters for the ModelClient.Get method.
type ModelClientGetOptions struct {
	// placeholder for future optional parameters
}

// ModelClientListByAccountOptions contains the optional parameters for the ModelClient.ListByAccount method.
type ModelClientListByAccountOptions struct {
	ContinuationToken *string
}

// ModelLocation - Describes properties of a model resource for a given geographic location.
type ModelLocation struct {
	// REQUIRED; Name of the geographic location.
	Location *string `json:"location,omitempty"`

	// Describes the scale policy of resource. This serves as the data parallel dimension for 3D parallelism (viz., data, pipeline
	// and model parallelism).There are two modes of scaling:1. Discrete: Resource
	// can be only be scaled to a specific instance count(s) specified by the "scaleSet" (for e.g., [2, 4, 8, 16]).2. Continuous:
	// Resource can be scaled to any instance count specified by the range ("min",
	// "max").
	ScalePolicy *ScalePolicyV2 `json:"scalePolicy,omitempty"`
	Status      *ModelStatus   `json:"status,omitempty"`

	// READ-ONLY; Current instance count of the model in this location
	CurrentInstanceCount *int32 `json:"currentInstanceCount,omitempty" azure:"ro"`

	// READ-ONLY; Endpoints of the model in this location.
	Endpoints []*Endpoint `json:"endpoints,omitempty" azure:"ro"`

	// READ-ONLY; Error code of the model in this location.
	ErrorCode *string `json:"errorCode,omitempty" azure:"ro"`

	// READ-ONLY; Gives additional information about the current status of the model in this location.
	StatusDetails *string `json:"statusDetails,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ModelLocation.
func (m ModelLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "currentInstanceCount", m.CurrentInstanceCount)
	populate(objectMap, "endpoints", m.Endpoints)
	populate(objectMap, "errorCode", m.ErrorCode)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "scalePolicy", m.ScalePolicy)
	populate(objectMap, "status", m.Status)
	populate(objectMap, "statusDetails", m.StatusDetails)
	return json.Marshal(objectMap)
}

// ModelPartition - Describes a partition of a model. A model consists of one or more partitions (in the tensor and pipeline
// parallel dimensions). A partition is scoped and mapped onto a device.
type ModelPartition struct {
	// REQUIRED; Describes placement of a model partition on a device.
	PartitionPlacement *ModelPartitionPlacement `json:"partitionPlacement,omitempty"`

	// REQUIRED; Index of pipeline partition.
	PipelinePartitionIndex *int32 `json:"pipelinePartitionIndex,omitempty"`

	// REQUIRED; Index of tensor partition.
	TensorPartitionIndex *int32 `json:"tensorPartitionIndex,omitempty"`

	// Path in modelPackageLocation where package for this model partition is located.
	PackagePath *string `json:"packagePath,omitempty"`
}

// ModelPartitionPlacement - Describes placement of a model partition on a device.
type ModelPartitionPlacement struct {
	// REQUIRED; Model partitions can target placement on the same or different instances of the InstanceType by referencing the
	// same or different InstanceTypeSetting name
	InstanceTypeSettingNameRef *string `json:"instanceTypeSettingNameRef,omitempty"`

	// Id of the device for placement of this model partition on the InstanceType referenced above.
	DeviceID *int32 `json:"deviceId,omitempty"`
}

// ModelPartitioningSetting - Describes the partitioning settings of the model. Models can be partitioned for scalability
// (when a model is too large to fit on a single device) and/or throughput.
type ModelPartitioningSetting struct {
	// The list of information about model partitions.
	Partitions []*ModelPartition `json:"partitions,omitempty"`

	// Specifies the pipeline-parallelism dimension of the model.
	PipelinePartitionCount *int32 `json:"pipelinePartitionCount,omitempty"`

	// Specifies the model-parallelism dimension of the model.
	TensorPartitionCount *int32 `json:"tensorPartitionCount,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ModelPartitioningSetting.
func (m ModelPartitioningSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "partitions", m.Partitions)
	populate(objectMap, "pipelinePartitionCount", m.PipelinePartitionCount)
	populate(objectMap, "tensorPartitionCount", m.TensorPartitionCount)
	return json.Marshal(objectMap)
}

// ModelPatchProperties - Describes all properties which can be updated for a Singularity Model resource.
type ModelPatchProperties struct {
	// User-friendly description of the model.
	Description *string `json:"description,omitempty"`

	// Collection of placement policies to use for placement of this model version.
	PlacementPolicies []*PlacementPolicy `json:"placementPolicies,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ModelPatchProperties.
func (m ModelPatchProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", m.Description)
	populate(objectMap, "placementPolicies", m.PlacementPolicies)
	return json.Marshal(objectMap)
}

// ModelProbeSetting - Describes the model probe setting.
type ModelProbeSetting struct {
	// Describes the settings of the probe.
	LivenessProbeSetting ProbeSettingClassification `json:"livenessProbeSetting,omitempty"`

	// Describes the settings of the probe.
	ReadinessProbeSetting ProbeSettingClassification `json:"readinessProbeSetting,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ModelProbeSetting.
func (m ModelProbeSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "livenessProbeSetting", m.LivenessProbeSetting)
	populate(objectMap, "readinessProbeSetting", m.ReadinessProbeSetting)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ModelProbeSetting.
func (m *ModelProbeSetting) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "livenessProbeSetting":
			m.LivenessProbeSetting, err = unmarshalProbeSettingClassification(val)
			delete(rawMsg, key)
		case "readinessProbeSetting":
			m.ReadinessProbeSetting, err = unmarshalProbeSettingClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ModelResourceDescription - Describes a model resource in Singularity.
type ModelResourceDescription struct {
	// REQUIRED
	Properties *ModelResourceDescriptionProperties `json:"properties,omitempty"`
	Identity   *ResourceIdentity                   `json:"identity,omitempty"`
	SystemData *ResourceSystemData                 `json:"systemData,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier for the resource. For example, /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. For example, Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ModelResourceDescription.
func (m ModelResourceDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	populate(objectMap, "identity", m.Identity)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// ModelResourceDescriptionList - A pageable list of model resources.
type ModelResourceDescriptionList struct {
	// READ-ONLY; URI to fetch the next page of the list.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; One page of the list.
	Value []*ModelResourceDescription `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ModelResourceDescriptionList.
func (m ModelResourceDescriptionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

type ModelResourceDescriptionProperties struct {
	// REQUIRED; The specification for the instance type for instantiating the model. For AOT compiled model this property specifies
	// the settings for the instance types where the model partitions needs to be
	// instantiated as specified by the ModelPlacementSetting. For JIT compiled model this property specifies the list of instance
	// types on which the model partitions can be instantiated.
	InstanceTypeSettings []*InstanceTypeSetting `json:"instanceTypeSettings,omitempty"`

	// REQUIRED; Describes the location of a storage source and how it will be accessed.
	PackageLocation *StorageLocation `json:"packageLocation,omitempty"`

	// REQUIRED; Describes the scale policy of resource. This serves as the data parallel dimension for 3D parallelism (viz.,
	// data, pipeline and model parallelism).There are two modes of scaling:1. Discrete: Resource
	// can be only be scaled to a specific instance count(s) specified by the "scaleSet" (for e.g., [2, 4, 8, 16]).2. Continuous:
	// Resource can be scaled to any instance count specified by the range ("min",
	// "max").
	ScalePolicy *ScalePolicyV2 `json:"scalePolicy,omitempty"`

	// This type describes the Compilation Policy of the model for training / inferencing.
	CompilationPolicy *CompilationPolicyBase `json:"compilationPolicy,omitempty"`

	// Group policy name associated with the model.
	GroupPolicyName *string        `json:"groupPolicyName,omitempty"`
	InferenceMode   *InferenceMode `json:"inferenceMode,omitempty"`

	// Collection of geographic locations where the model is deployed.
	Locations []*ModelLocation `json:"locations,omitempty"`

	// Describes the model probe setting.
	ModelProbeSetting *ModelProbeSetting `json:"modelProbeSetting,omitempty"`

	// Describes a network resource reference.
	NetworkResourceRef *NetworkReference `json:"networkResourceRef,omitempty"`

	// Describes the partitioning settings of the model. Models can be partitioned for scalability (when a model is too large
	// to fit on a single device) and/or throughput.
	PartitioningSetting *ModelPartitioningSetting `json:"partitioningSetting,omitempty"`
	ProvisioningState   *ProvisioningState        `json:"provisioningState,omitempty"`
	SLATier             *SLATier                  `json:"slaTier,omitempty"`

	// READ-ONLY; Global endpoints of the model that allow accessing the model across geographic locations.
	Endpoints []*Endpoint `json:"endpoints,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ModelResourceDescriptionProperties.
func (m ModelResourceDescriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compilationPolicy", m.CompilationPolicy)
	populate(objectMap, "endpoints", m.Endpoints)
	populate(objectMap, "groupPolicyName", m.GroupPolicyName)
	populate(objectMap, "inferenceMode", m.InferenceMode)
	populate(objectMap, "instanceTypeSettings", m.InstanceTypeSettings)
	populate(objectMap, "locations", m.Locations)
	populate(objectMap, "modelProbeSetting", m.ModelProbeSetting)
	populate(objectMap, "networkResourceRef", m.NetworkResourceRef)
	populate(objectMap, "packageLocation", m.PackageLocation)
	populate(objectMap, "partitioningSetting", m.PartitioningSetting)
	populate(objectMap, "provisioningState", m.ProvisioningState)
	populate(objectMap, "slaTier", m.SLATier)
	populate(objectMap, "scalePolicy", m.ScalePolicy)
	return json.Marshal(objectMap)
}

// ModelResourcePatchDescription - Describes all properties which can be updated for a Singularity Model resource.
type ModelResourcePatchDescription struct {
	// REQUIRED
	Properties *ModelResourcePatchDescriptionProperties `json:"properties,omitempty"`
	SystemData *ResourceSystemData                      `json:"systemData,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier for the resource. For example, /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. For example, Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ModelResourcePatchDescription.
func (m ModelResourcePatchDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

type ModelResourcePatchDescriptionProperties struct {
	// User-friendly description of the model.
	Description *string `json:"description,omitempty"`

	// Collection of placement policies to use for placement of this model version.
	PlacementPolicies []*PlacementPolicy `json:"placementPolicies,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ModelResourcePatchDescriptionProperties.
func (m ModelResourcePatchDescriptionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "description", m.Description)
	populate(objectMap, "placementPolicies", m.PlacementPolicies)
	return json.Marshal(objectMap)
}

// ModelResourceProperties - Describes the properties of a model resource.
type ModelResourceProperties struct {
	// REQUIRED; The specification for the instance type for instantiating the model. For AOT compiled model this property specifies
	// the settings for the instance types where the model partitions needs to be
	// instantiated as specified by the ModelPlacementSetting. For JIT compiled model this property specifies the list of instance
	// types on which the model partitions can be instantiated.
	InstanceTypeSettings []*InstanceTypeSetting `json:"instanceTypeSettings,omitempty"`

	// REQUIRED; Describes the location of a storage source and how it will be accessed.
	PackageLocation *StorageLocation `json:"packageLocation,omitempty"`

	// REQUIRED; Describes the scale policy of resource. This serves as the data parallel dimension for 3D parallelism (viz.,
	// data, pipeline and model parallelism).There are two modes of scaling:1. Discrete: Resource
	// can be only be scaled to a specific instance count(s) specified by the "scaleSet" (for e.g., [2, 4, 8, 16]).2. Continuous:
	// Resource can be scaled to any instance count specified by the range ("min",
	// "max").
	ScalePolicy *ScalePolicyV2 `json:"scalePolicy,omitempty"`

	// This type describes the Compilation Policy of the model for training / inferencing.
	CompilationPolicy *CompilationPolicyBase `json:"compilationPolicy,omitempty"`

	// Group policy name associated with the model.
	GroupPolicyName *string        `json:"groupPolicyName,omitempty"`
	InferenceMode   *InferenceMode `json:"inferenceMode,omitempty"`

	// Collection of geographic locations where the model is deployed.
	Locations []*ModelLocation `json:"locations,omitempty"`

	// Describes the model probe setting.
	ModelProbeSetting *ModelProbeSetting `json:"modelProbeSetting,omitempty"`

	// Describes a network resource reference.
	NetworkResourceRef *NetworkReference `json:"networkResourceRef,omitempty"`

	// Describes the partitioning settings of the model. Models can be partitioned for scalability (when a model is too large
	// to fit on a single device) and/or throughput.
	PartitioningSetting *ModelPartitioningSetting `json:"partitioningSetting,omitempty"`
	ProvisioningState   *ProvisioningState        `json:"provisioningState,omitempty"`
	SLATier             *SLATier                  `json:"slaTier,omitempty"`

	// READ-ONLY; Global endpoints of the model that allow accessing the model across geographic locations.
	Endpoints []*Endpoint `json:"endpoints,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ModelResourceProperties.
func (m ModelResourceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "compilationPolicy", m.CompilationPolicy)
	populate(objectMap, "endpoints", m.Endpoints)
	populate(objectMap, "groupPolicyName", m.GroupPolicyName)
	populate(objectMap, "inferenceMode", m.InferenceMode)
	populate(objectMap, "instanceTypeSettings", m.InstanceTypeSettings)
	populate(objectMap, "locations", m.Locations)
	populate(objectMap, "modelProbeSetting", m.ModelProbeSetting)
	populate(objectMap, "networkResourceRef", m.NetworkResourceRef)
	populate(objectMap, "packageLocation", m.PackageLocation)
	populate(objectMap, "partitioningSetting", m.PartitioningSetting)
	populate(objectMap, "provisioningState", m.ProvisioningState)
	populate(objectMap, "slaTier", m.SLATier)
	populate(objectMap, "scalePolicy", m.ScalePolicy)
	return json.Marshal(objectMap)
}

// NetworkClientBeginCreateOrUpdateOptions contains the optional parameters for the NetworkClient.BeginCreateOrUpdate method.
type NetworkClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// NetworkClientBeginDeleteOptions contains the optional parameters for the NetworkClient.BeginDelete method.
type NetworkClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// NetworkClientBeginUpdateOptions contains the optional parameters for the NetworkClient.BeginUpdate method.
type NetworkClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// NetworkClientGetOptions contains the optional parameters for the NetworkClient.Get method.
type NetworkClientGetOptions struct {
	// placeholder for future optional parameters
}

// NetworkClientListByAccountOptions contains the optional parameters for the NetworkClient.ListByAccount method.
type NetworkClientListByAccountOptions struct {
	ContinuationToken *string
}

// NetworkPropertiesBaseClassification provides polymorphic access to related types.
// Call the interface's GetNetworkPropertiesBase() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *DelegatedSubnetProperties, *NetworkPropertiesBase
type NetworkPropertiesBaseClassification interface {
	// GetNetworkPropertiesBase returns the NetworkPropertiesBase content of the underlying type.
	GetNetworkPropertiesBase() *NetworkPropertiesBase
}

// NetworkPropertiesBase - Describes the properties of a network resource.
type NetworkPropertiesBase struct {
	// REQUIRED
	Kind              *NetworkKind           `json:"kind,omitempty"`
	ProvisioningState *ProvisioningState     `json:"provisioningState,omitempty"`
	Status            *NetworkResourceStatus `json:"status,omitempty"`
}

// GetNetworkPropertiesBase implements the NetworkPropertiesBaseClassification interface for type NetworkPropertiesBase.
func (n *NetworkPropertiesBase) GetNetworkPropertiesBase() *NetworkPropertiesBase { return n }

// NetworkReference - Describes a network resource reference.
type NetworkReference struct {
	// Name of the network resource to reference.
	Name *string `json:"name,omitempty"`
}

// NetworkResourceDescription - Describes a network resource.
type NetworkResourceDescription struct {
	// REQUIRED; Describes the properties of a network resource.
	Properties NetworkPropertiesBaseClassification `json:"properties,omitempty"`
	SystemData *ResourceSystemData                 `json:"systemData,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier for the resource. For example, /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. For example, Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type NetworkResourceDescription.
func (n NetworkResourceDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", n.ID)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "properties", n.Properties)
	populate(objectMap, "systemData", n.SystemData)
	populate(objectMap, "tags", n.Tags)
	populate(objectMap, "type", n.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkResourceDescription.
func (n *NetworkResourceDescription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &n.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &n.Name)
			delete(rawMsg, key)
		case "properties":
			n.Properties, err = unmarshalNetworkPropertiesBaseClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &n.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &n.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &n.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// NetworkResourceDescriptionList - A pageable list of network resources.
type NetworkResourceDescriptionList struct {
	// READ-ONLY; URI to fetch the next page of the list.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; One page of the list.
	Value []*NetworkResourceDescription `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type NetworkResourceDescriptionList.
func (n NetworkResourceDescriptionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", n.NextLink)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// NetworkSettings - Describes the network settings for the account.
type NetworkSettings struct {
	// The resource id of the delegated subnet.
	SubnetID *string `json:"subnetId,omitempty"`
}

// NfsStorageCacheProperties - Describes the properties of a storage cache resource backed by NFS.
type NfsStorageCacheProperties struct {
	// REQUIRED
	Kind *StorageCacheKind `json:"kind,omitempty"`

	// Optional storage capacity to allocate.
	CapacityInGiB *int32 `json:"capacityInGiB,omitempty"`

	// Description of the storage cache resource.
	Description       *string            `json:"description,omitempty"`
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty"`

	// Optional region for managed storage resources (if any).
	Region *string             `json:"region,omitempty"`
	Status *StorageCacheStatus `json:"status,omitempty"`

	// READ-ONLY; Default mount path that will be used within a job or model if none is specified.
	DefaultMountPath *string `json:"defaultMountPath,omitempty" azure:"ro"`
}

// GetStorageCachePropertiesBase implements the StorageCachePropertiesBaseClassification interface for type NfsStorageCacheProperties.
func (n *NfsStorageCacheProperties) GetStorageCachePropertiesBase() *StorageCachePropertiesBase {
	return &StorageCachePropertiesBase{
		Kind:              n.Kind,
		Description:       n.Description,
		Region:            n.Region,
		ProvisioningState: n.ProvisioningState,
		Status:            n.Status,
		DefaultMountPath:  n.DefaultMountPath,
	}
}

// MarshalJSON implements the json.Marshaller interface for type NfsStorageCacheProperties.
func (n NfsStorageCacheProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "capacityInGiB", n.CapacityInGiB)
	populate(objectMap, "defaultMountPath", n.DefaultMountPath)
	populate(objectMap, "description", n.Description)
	objectMap["kind"] = StorageCacheKindNFS
	populate(objectMap, "provisioningState", n.ProvisioningState)
	populate(objectMap, "region", n.Region)
	populate(objectMap, "status", n.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NfsStorageCacheProperties.
func (n *NfsStorageCacheProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacityInGiB":
			err = unpopulate(val, &n.CapacityInGiB)
			delete(rawMsg, key)
		case "defaultMountPath":
			err = unpopulate(val, &n.DefaultMountPath)
			delete(rawMsg, key)
		case "description":
			err = unpopulate(val, &n.Description)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &n.Kind)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &n.ProvisioningState)
			delete(rawMsg, key)
		case "region":
			err = unpopulate(val, &n.Region)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &n.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// OperationListResult - Describes the result of the request to list Singularity operations.
type OperationListResult struct {
	// READ-ONLY; URL to get the next set of operation list results if there are any.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; List of operations supported by the Singularity resource provider.
	Value []*OperationResult `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OperationListResult.
func (o OperationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// OperationResult - List of operations available at the listed Azure resource provider.
type OperationResult struct {
	// An operation available at the listed Azure resource provider.
	Display *AvailableOperationDisplay `json:"display,omitempty"`

	// READ-ONLY; Indicates whether the operation is a data action.
	IsDataAction *bool `json:"isDataAction,omitempty" azure:"ro"`

	// READ-ONLY; The name of the operation
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The URL to use for getting the next set of results.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; Origin result.
	Origin *string `json:"origin,omitempty" azure:"ro"`
}

// OperationsClientListOptions contains the optional parameters for the OperationsClient.List method.
type OperationsClientListOptions struct {
	// placeholder for future optional parameters
}

// PlacementPolicy - Describes the placement policy for a Job or a Model.
type PlacementPolicy struct {
	// REQUIRED; The list of settings for instance types.
	InstanceTypes []*InstanceTypeSettings `json:"instanceTypes,omitempty"`

	// An optional location for instance type placement. If specified, this must be one of the account resource locations.
	Location *string `json:"location,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PlacementPolicy.
func (p PlacementPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "instanceTypes", p.InstanceTypes)
	populate(objectMap, "location", p.Location)
	return json.Marshal(objectMap)
}

// PlatformContainerImage - Describes a platform image.
type PlatformContainerImage struct {
	// REQUIRED
	Kind *ContainerImageKind `json:"kind,omitempty"`

	// REQUIRED; Name of the platform image. This supports fully qualified image names and image friendly names
	Name *string `json:"name,omitempty"`
}

// GetContainerImageBase implements the ContainerImageBaseClassification interface for type PlatformContainerImage.
func (p *PlatformContainerImage) GetContainerImageBase() *ContainerImageBase {
	return &ContainerImageBase{
		Kind: p.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PlatformContainerImage.
func (p PlatformContainerImage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = ContainerImageKindPlatform
	populate(objectMap, "name", p.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PlatformContainerImage.
func (p *PlatformContainerImage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &p.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &p.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ProbeSettingClassification provides polymorphic access to related types.
// Call the interface's GetProbeSetting() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ExecProbeSetting, *HTTPProbeSetting, *ProbeSetting
type ProbeSettingClassification interface {
	// GetProbeSetting returns the ProbeSetting content of the underlying type.
	GetProbeSetting() *ProbeSetting
}

// ProbeSetting - Describes the settings of the probe.
type ProbeSetting struct {
	// REQUIRED
	Kind *ProbeSettingKind `json:"kind,omitempty"`

	// Number of consecutive failures for the probe after which the container is restarted.
	FailureThreshold *int32 `json:"failureThreshold,omitempty"`

	// The period in seconds to specify the frequency of the probe.
	FrequencyInSeconds *int32 `json:"frequencyInSeconds,omitempty"`

	// The initial delay in seconds to start executing the probe after the container has started.
	InitialDelayInSeconds *int32 `json:"initialDelayInSeconds,omitempty"`

	// Minimum consecutive successes for the probe to be considered successful after having failed.
	SuccessThreshold *int32 `json:"successThreshold,omitempty"`

	// The period in seconds after which we consider the probe as failed, if it hasn't finished successfully.
	TimeoutInSeconds *int32 `json:"timeoutInSeconds,omitempty"`
}

// GetProbeSetting implements the ProbeSettingClassification interface for type ProbeSetting.
func (p *ProbeSetting) GetProbeSetting() *ProbeSetting { return p }

// Resource - The resource model definition for Azure Resource Manager resource.
type Resource struct {
	SystemData *ResourceSystemData `json:"systemData,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier for the resource. For example, /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. For example, Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

type ResourceIdentity struct {
	// REQUIRED; The type of identity used for the resource. The type 'None' will remove any identities from the resource.
	Type *string `json:"type,omitempty"`

	// The user assigned managed identities assigned to this resource (if any).
	UserAssignedIdentities map[string]*ResourceUserAssignedIdentity `json:"userAssignedIdentities,omitempty"`

	// READ-ONLY; The principal id of the resource identity. This property will only be provided for a system assigned identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`

	// READ-ONLY; The tenant id associated with the resource. This property will only be provided for a system assigned identity.
	TenantID *string `json:"tenantId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceIdentity.
func (r ResourceIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "principalId", r.PrincipalID)
	populate(objectMap, "tenantId", r.TenantID)
	populate(objectMap, "type", r.Type)
	populate(objectMap, "userAssignedIdentities", r.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

type ResourceSystemData struct {
	// READ-ONLY; The timestamp of resource creation (UTC).
	CreatedAt *string `json:"createdAt,omitempty" azure:"ro"`

	// READ-ONLY; A string identifier for the identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty" azure:"ro"`

	// READ-ONLY; The type of identity that created the resource: user, application, managedIdentity, key.
	CreatedByType *string `json:"createdByType,omitempty" azure:"ro"`

	// READ-ONLY; The timestamp of resource last modification (UTC).
	LastModifiedAt *string `json:"lastModifiedAt,omitempty" azure:"ro"`

	// READ-ONLY; A string identifier for the identity that last modified the resource
	LastModifiedBy *string `json:"lastModifiedBy,omitempty" azure:"ro"`

	// READ-ONLY; The type of identity that last modified the resource: user, application, managedIdentity, key.
	LastModifiedByType *string `json:"lastModifiedByType,omitempty" azure:"ro"`
}

type ResourceUserAssignedIdentity struct {
	// READ-ONLY; The client id of user assigned identity.
	ClientID *string `json:"clientId,omitempty" azure:"ro"`

	// READ-ONLY; The principal id of user assigned identity.
	PrincipalID *string `json:"principalId,omitempty" azure:"ro"`
}

// ScalePolicy - Describes the scale policy for a Job or a Model.
type ScalePolicy struct {
	// A hint on the interval to use for auto scaling.
	AutoScaleIntervalInSecondsHint *int32 `json:"autoScaleIntervalInSecondsHint,omitempty"`

	// Set of valid instance type counts that the job can be autoscaled to e.g., [2,4,8,16].
	InstanceTypeCountSet []*int32 `json:"instanceTypeCountSet,omitempty"`

	// Maximum instance type count (the limit) up to which to provision.
	MaxInstanceTypeCount *int32 `json:"maxInstanceTypeCount,omitempty"`

	// The minimum instance type count to provision.
	MinInstanceTypeCount *int32 `json:"minInstanceTypeCount,omitempty"`

	// READ-ONLY; The current instance type count.
	CurrentInstanceTypeCount *int32 `json:"currentInstanceTypeCount,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ScalePolicy.
func (s ScalePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "autoScaleIntervalInSecondsHint", s.AutoScaleIntervalInSecondsHint)
	populate(objectMap, "currentInstanceTypeCount", s.CurrentInstanceTypeCount)
	populate(objectMap, "instanceTypeCountSet", s.InstanceTypeCountSet)
	populate(objectMap, "maxInstanceTypeCount", s.MaxInstanceTypeCount)
	populate(objectMap, "minInstanceTypeCount", s.MinInstanceTypeCount)
	return json.Marshal(objectMap)
}

// ScalePolicyV2 - Describes the scale policy of resource. This serves as the data parallel dimension for 3D parallelism (viz.,
// data, pipeline and model parallelism).There are two modes of scaling:1. Discrete: Resource
// can be only be scaled to a specific instance count(s) specified by the "scaleSet" (for e.g., [2, 4, 8, 16]).2. Continuous:
// Resource can be scaled to any instance count specified by the range ("min",
// "max").
type ScalePolicyV2 struct {
	// Maximum instance count of the resource.
	Max *int32 `json:"max,omitempty"`

	// The minimum instance count of the resource.
	Min *int32 `json:"min,omitempty"`

	// Set of valid instance counts that the resource can be scaled to e.g., [2,4,8,16]. This is required for discrete scaling.
	ScaleSet []*int32 `json:"scaleSet,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ScalePolicyV2.
func (s ScalePolicyV2) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "max", s.Max)
	populate(objectMap, "min", s.Min)
	populate(objectMap, "scaleSet", s.ScaleSet)
	return json.Marshal(objectMap)
}

// StorageCacheClientBeginCreateOrUpdateOptions contains the optional parameters for the StorageCacheClient.BeginCreateOrUpdate
// method.
type StorageCacheClientBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// StorageCacheClientBeginDeleteOptions contains the optional parameters for the StorageCacheClient.BeginDelete method.
type StorageCacheClientBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// StorageCacheClientBeginResumeOptions contains the optional parameters for the StorageCacheClient.BeginResume method.
type StorageCacheClientBeginResumeOptions struct {
	// placeholder for future optional parameters
}

// StorageCacheClientBeginSuspendOptions contains the optional parameters for the StorageCacheClient.BeginSuspend method.
type StorageCacheClientBeginSuspendOptions struct {
	// placeholder for future optional parameters
}

// StorageCacheClientBeginUpdateOptions contains the optional parameters for the StorageCacheClient.BeginUpdate method.
type StorageCacheClientBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// StorageCacheClientGetDiagnosticsOptions contains the optional parameters for the StorageCacheClient.GetDiagnostics method.
type StorageCacheClientGetDiagnosticsOptions struct {
	// placeholder for future optional parameters
}

// StorageCacheClientGetOptions contains the optional parameters for the StorageCacheClient.Get method.
type StorageCacheClientGetOptions struct {
	// placeholder for future optional parameters
}

// StorageCacheClientListByAccountOptions contains the optional parameters for the StorageCacheClient.ListByAccount method.
type StorageCacheClientListByAccountOptions struct {
	ContinuationToken *string
}

// StorageCachePropertiesBaseClassification provides polymorphic access to related types.
// Call the interface's GetStorageCachePropertiesBase() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *AdlsStorageCacheProperties, *BlobStorageCacheProperties, *NfsStorageCacheProperties, *StorageCachePropertiesBase
type StorageCachePropertiesBaseClassification interface {
	// GetStorageCachePropertiesBase returns the StorageCachePropertiesBase content of the underlying type.
	GetStorageCachePropertiesBase() *StorageCachePropertiesBase
}

// StorageCachePropertiesBase - Describes the properties of a storage cache resource.
type StorageCachePropertiesBase struct {
	// REQUIRED
	Kind *StorageCacheKind `json:"kind,omitempty"`

	// Description of the storage cache resource.
	Description       *string            `json:"description,omitempty"`
	ProvisioningState *ProvisioningState `json:"provisioningState,omitempty"`

	// Optional region for managed storage resources (if any).
	Region *string             `json:"region,omitempty"`
	Status *StorageCacheStatus `json:"status,omitempty"`

	// READ-ONLY; Default mount path that will be used within a job or model if none is specified.
	DefaultMountPath *string `json:"defaultMountPath,omitempty" azure:"ro"`
}

// GetStorageCachePropertiesBase implements the StorageCachePropertiesBaseClassification interface for type StorageCachePropertiesBase.
func (s *StorageCachePropertiesBase) GetStorageCachePropertiesBase() *StorageCachePropertiesBase {
	return s
}

// StorageCacheResourceDescription - Describes a storage cache resource.
type StorageCacheResourceDescription struct {
	// REQUIRED; Describes the properties of a storage cache resource.
	Properties StorageCachePropertiesBaseClassification `json:"properties,omitempty"`
	SystemData *ResourceSystemData                      `json:"systemData,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier for the resource. For example, /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. For example, Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageCacheResourceDescription.
func (s StorageCacheResourceDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "properties", s.Properties)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "type", s.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageCacheResourceDescription.
func (s *StorageCacheResourceDescription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &s.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &s.Name)
			delete(rawMsg, key)
		case "properties":
			s.Properties, err = unmarshalStorageCachePropertiesBaseClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &s.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &s.Tags)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &s.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StorageCacheResourceDescriptionList - A pageable list of storage cache resources.
type StorageCacheResourceDescriptionList struct {
	// READ-ONLY; URI to fetch the next page of the list.
	NextLink *string `json:"nextLink,omitempty" azure:"ro"`

	// READ-ONLY; One page of the list.
	Value []*StorageCacheResourceDescription `json:"value,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageCacheResourceDescriptionList.
func (s StorageCacheResourceDescriptionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// StorageCacheResourceDiagnosticsInfo - Storage cache resource diagnostics information.
type StorageCacheResourceDiagnosticsInfo struct {
	SystemData *ResourceSystemData `json:"systemData,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier for the resource. For example, /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. For example, Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty" azure:"ro"`

	// READ-ONLY; The used storage capacity.
	UsageInMiB *int32 `json:"usageInMiB,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageCacheResourceDiagnosticsInfo.
func (s StorageCacheResourceDiagnosticsInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", s.ID)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "systemData", s.SystemData)
	populate(objectMap, "tags", s.Tags)
	populate(objectMap, "type", s.Type)
	populate(objectMap, "usageInMiB", s.UsageInMiB)
	return json.Marshal(objectMap)
}

// StorageLocation - Describes the location of a storage source and how it will be accessed.
type StorageLocation struct {
	// Describes the target mountpoint of a storage source.
	Mount *StorageMount `json:"mount,omitempty"`

	// This type describes Singularity storage for a job or service.
	Source StorageSourceBaseClassification `json:"source,omitempty"`

	// Name of the managed storage resource to mount.
	StorageCacheContainerName *string `json:"storageCacheContainerName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageLocation.
func (s StorageLocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "mount", s.Mount)
	populate(objectMap, "source", s.Source)
	populate(objectMap, "storageCacheContainerName", s.StorageCacheContainerName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageLocation.
func (s *StorageLocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "mount":
			err = unpopulate(val, &s.Mount)
			delete(rawMsg, key)
		case "source":
			s.Source, err = unmarshalStorageSourceBaseClassification(val)
			delete(rawMsg, key)
		case "storageCacheContainerName":
			err = unpopulate(val, &s.StorageCacheContainerName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StorageMount - Describes the target mountpoint of a storage source.
type StorageMount struct {
	// The target mountpoint path.
	Path *string `json:"path,omitempty"`
}

// StorageSourceAzureAISupercomputerStorage - This type describes Singularity storage for a job or service.
type StorageSourceAzureAISupercomputerStorage struct {
	// REQUIRED
	Kind *StorageSourceKind `json:"kind,omitempty"`

	// REQUIRED; Path to the Singularity storage.
	StorageContainerName *string `json:"storageContainerName,omitempty"`
}

// GetStorageSourceBase implements the StorageSourceBaseClassification interface for type StorageSourceAzureAISupercomputerStorage.
func (s *StorageSourceAzureAISupercomputerStorage) GetStorageSourceBase() *StorageSourceBase {
	return &StorageSourceBase{
		Kind: s.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type StorageSourceAzureAISupercomputerStorage.
func (s StorageSourceAzureAISupercomputerStorage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["kind"] = StorageSourceKindAzureAISupercomputerStorage
	populate(objectMap, "storageContainerName", s.StorageContainerName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageSourceAzureAISupercomputerStorage.
func (s *StorageSourceAzureAISupercomputerStorage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
			err = unpopulate(val, &s.Kind)
			delete(rawMsg, key)
		case "storageContainerName":
			err = unpopulate(val, &s.StorageContainerName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StorageSourceAzureBlob - This type describes Singularity storage for a job or service.
type StorageSourceAzureBlob struct {
	// REQUIRED; For SasToken AuthenticationType: Container Endpoint with the associated SAS token. For SystemAssignedIdentity
	// and UserAssignedIdentity AuthenticationType: Container Endpoint only.
	BlobEndpoint *string `json:"blobEndpoint,omitempty"`

	// REQUIRED
	Kind *StorageSourceKind `json:"kind,omitempty"`

	// Storage account ResourceId for the Azure blob. Required when AuthenticationType is SystemAssignedIdentity.
	AccountResourceID  *string                    `json:"accountResourceId,omitempty"`
	AuthenticationType *StorageAuthenticationType `json:"authenticationType,omitempty"`

	// User assigned managed identity. Required when AuthenticationType is UserAssignedIdentity.
	UserAssignedIdentity *string `json:"userAssignedIdentity,omitempty"`
}

// GetStorageSourceBase implements the StorageSourceBaseClassification interface for type StorageSourceAzureBlob.
func (s *StorageSourceAzureBlob) GetStorageSourceBase() *StorageSourceBase {
	return &StorageSourceBase{
		Kind: s.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type StorageSourceAzureBlob.
func (s StorageSourceAzureBlob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accountResourceId", s.AccountResourceID)
	populate(objectMap, "authenticationType", s.AuthenticationType)
	populate(objectMap, "blobEndpoint", s.BlobEndpoint)
	objectMap["kind"] = StorageSourceKindAzureBlobStorage
	populate(objectMap, "userAssignedIdentity", s.UserAssignedIdentity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageSourceAzureBlob.
func (s *StorageSourceAzureBlob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountResourceId":
			err = unpopulate(val, &s.AccountResourceID)
			delete(rawMsg, key)
		case "authenticationType":
			err = unpopulate(val, &s.AuthenticationType)
			delete(rawMsg, key)
		case "blobEndpoint":
			err = unpopulate(val, &s.BlobEndpoint)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &s.Kind)
			delete(rawMsg, key)
		case "userAssignedIdentity":
			err = unpopulate(val, &s.UserAssignedIdentity)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// StorageSourceBaseClassification provides polymorphic access to related types.
// Call the interface's GetStorageSourceBase() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *StorageSourceAzureAISupercomputerStorage, *StorageSourceAzureBlob, *StorageSourceBase
type StorageSourceBaseClassification interface {
	// GetStorageSourceBase returns the StorageSourceBase content of the underlying type.
	GetStorageSourceBase() *StorageSourceBase
}

// StorageSourceBase - This type describes Singularity storage for a job or service.
type StorageSourceBase struct {
	// REQUIRED
	Kind *StorageSourceKind `json:"kind,omitempty"`
}

// GetStorageSourceBase implements the StorageSourceBaseClassification interface for type StorageSourceBase.
func (s *StorageSourceBase) GetStorageSourceBase() *StorageSourceBase { return s }

// SubscriptionQuotaClientGetOptions contains the optional parameters for the SubscriptionQuotaClient.Get method.
type SubscriptionQuotaClientGetOptions struct {
	// Subscription id that uniquely identify a Microsoft Azure subscription. The owner subscription id is sent as a query parameter
	// when subscription for the request is different from the subscription ID of
	// the URI
	OwnerSubscriptionID *string
}

// TrackedResource - The resource model definition for Azure Resource Manager tracked top-level resource.
type TrackedResource struct {
	// REQUIRED; The geo-location where the resource lives.
	Location   *string             `json:"location,omitempty"`
	SystemData *ResourceSystemData `json:"systemData,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Fully qualified identifier for the resource. For example, /subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/{resourceProviderNamespace}/{resourceType}/{resourceName}
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the resource
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of the resource. For example, Microsoft.Compute/virtualMachines or Microsoft.Storage/storageAccounts.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", t.ID)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "name", t.Name)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "tags", t.Tags)
	populate(objectMap, "type", t.Type)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
